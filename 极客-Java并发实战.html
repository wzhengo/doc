<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  极客-Java并发实战 - 
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html">Android开发艺术探索</a></li>
        
            <li><a href="Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html">Android进阶之光</a></li>
        
            <li><a href="Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html">Android进阶解密</a></li>
        
            <li><a href="Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html">Java核心技术</a></li>
        
            <li><a href="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA.html">深入理解虚拟机</a></li>
        
            <li><a href="%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html">极客-Java并发实战</a></li>
        
            <li><a href="%E6%9E%81%E5%AE%A2-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html">极客-深入拆解Java虚拟机</a></li>
        
            <li><a href="%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html">极客-数据结构与算法之美</a></li>
        
            <li><a href="%E8%8F%9C%E9%B8%9F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">菜鸟-设计模式</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15755329598422.html">
                
                  <h1>00 学习攻略 | 如何才能学好并发编程？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>并发编程领域可以抽象成三个核心问题：<strong>分工、同步和互斥</strong>。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755329598422/15755335392546.jpg" alt=""/></p>

<p><strong>1. 分工</strong></p>

<p>所谓分工，即拆分任务，例如不同的线程做不同的事情。</p>

<p>Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是一种分工方法。除此之外，并发编程领域还总结了一些设计模式，基本上都是和分工方法相关的，例如生产者 - 消费者、Thread-Per-Message、Worker Thread 模式等都是用来指导你如何分工的。</p>

<p><strong>2. 同步</strong></p>

<p>一个线程执行完了一个任务，如何通知执行后续任务的线程开工而已。</p>

<p>协作一般是和分工相关的。Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是分工方法，但同时也能解决线程协作的问题。除此之外，Java SDK 里提供的 CountDownLatch、CyclicBarrier、Phaser、Exchanger 也都是用来解决线程协作问题的。</p>

<p><strong>当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行。</strong></p>

<p>在 Java 并发编程领域，解决协作问题的核心技术是<strong>管程</strong>。<strong>管程是解决并发问题的万能钥匙。</strong></p>

<p><strong>3. 互斥</strong></p>

<p>分工、同步主要强调的是性能，但并发程序里还有一部分是关于<mark>正确性</mark>的，用专业术语叫“<strong>线程安全</strong>”。并发程序里，当多个线程同时访问同一个共享变量的时候，结果是不确定的。不确定，则意味着可能正确，也可能错误，事先是不知道的。而导致不确定的主要源头是<strong>可见性问题、有序性问题和原子性问题</strong>，为了解决这三个问题，Java 语言引入了<mark>内存模型</mark>，内存模型提供了一系列的规则，利用这些规则，我们可以避免可见性问题、有序性问题，但是还不足以完全解决线程安全问题。解决线程安全问题的核心方案还是<mark>互斥</mark>。</p>

<p><strong>所谓互斥，指的是同一时刻，只允许一个线程访问共享变量。</strong></p>

<p>实现互斥的核心技术就是<mark>锁</mark>，Java 语言里 synchronized、SDK 里的各种 Lock 都能解决互斥问题。虽说锁解决了安全性问题，但同时也带来了<mark>性能问题</mark>，那如何保证安全性的同时又尽量提高性能呢？可以<mark>分场景优化</mark>，Java SDK 里提供的 ReadWriteLock、StampedLock 就可以优化读多写少场景下锁的性能。还可以使用<mark>无锁的数据结构</mark>，例如 Java SDK 里提供的原子类都是基于无锁技术实现的。</p>

<p>除此之外，还有一些其他的方案，原理是<mark>不共享变量</mark>或者<mark>变量只允许读</mark>。这方面，Java 提供了 Thread Local 和 final 关键字，还有一种 Copy-on-write 的模式。</p>

<p>使用锁除了要注意性能问题外，还需要注意<mark>死锁</mark>问题。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755331524883.html">
                
                  <h1>01 | 可见性、原子性和有序性问题：并发编程Bug的源头</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>并发程序幕后的故事</li>
<li>源头之一：缓存导致的可见性问题</li>
<li>源头之二：线程切换带来的原子性问题</li>
<li>源头之三：编译优化带来的有序性问题</li>
</ul>

<h3 id="toc_0">并发程序幕后的故事</h3>

<p>CPU、内存、I/O 设备都在不断迭代，但<strong>有一个核心矛盾一直存在，就是这三者的速度差异</strong>。</p>

<p>为了合理利用 CPU 的高性能，平衡这三者的速度差异，<mark>计算机体系结构、操作系统、编译程序</mark>都做出了贡献，主要体现为：</p>

<ol>
<li>CPU 增加了缓存，以均衡与内存的速度差异；</li>
<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；</li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。</li>
</ol>

<p>现在我们几乎所有的程序都默默地享受着这些成果，但是天下没有免费的午餐，并发程序很多诡异问题的根源也在这里。</p>

<h3 id="toc_1">源头之一：缓存导致的可见性问题</h3>

<p>在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755331524883/15755429758709.jpg" alt=""/></p>

<p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为<strong>可见性</strong>。</p>

<p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755331524883/15755430331349.jpg" alt=""/></p>

<h3 id="toc_2">源头之二：线程切换带来的原子性问题</h3>

<p>由于 IO 太慢，早期的操作系统就发明了多进程，即便在单核的 CPU 上我们也可以一边听着歌，一边写 Bug，这个就是多进程的功劳。</p>

<p>高级语言里一条语句往往需要多条 CPU 指令完成，例如<code>count += 1</code>，至少需要三条 CPU 指令：</p>

<ul>
<li>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</li>
<li>指令 2：之后，在寄存器中执行 +1 操作；</li>
<li>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li>
</ul>

<p>操作系统做任务切换，可以发生在任何一条 <mark>CPU 指令</mark>执行完。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755331524883/15755448506477.jpg" alt=""/></p>

<p><strong>我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。</strong>CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符。因此，很多时候我们需要在高级语言层面保证操作的原子性。</p>

<h3 id="toc_3">源头之三：编译优化带来的有序性问题</h3>

<p>编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”</p>

<p>在 Java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：</p>

<pre><code class="language-text">public class Singleton {
  static Singleton instance;
  static Singleton getInstance(){
    if (instance == null) {
      synchronized(Singleton.class) {
        if (instance == null)
          instance = new Singleton();
        }
    }
    return instance;
  }
}
</code></pre>

<p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance() 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：</p>

<ol>
<li>分配一块内存 M；</li>
<li>在内存 M 上初始化 Singleton 对象；</li>
<li>然后 M 的地址赋值给 instance 变量。</li>
</ol>

<p>但是实际上优化后的执行路径却是这样的：</p>

<ol>
<li>分配一块内存 M；</li>
<li>将 M 的地址赋值给 instance 变量；</li>
<li>最后在内存 M 上初始化 Singleton 对象。</li>
</ol>

<p>优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755331524883/15756025312634.jpg" alt=""/></p>

<h3 id="toc_4">总结</h3>

<p>只要我们能够深刻理解可见性、原子性、有序性在并发场景下的原理，很多并发 Bug 都是可以理解、可以诊断的。</p>

<p>在介绍可见性、原子性、有序性的时候，特意提到<mark>缓存</mark>导致的可见性问题，<mark>线程切换</mark>带来的原子性问题，<mark>编译优化</mark>带来的有序性问题，其实缓存、线程、编译优化的目的和我们写并发程序的目的是相同的，都是提高程序性能。但是<mark>技术在解决一个问题的同时，必然会带来另外一个问题</mark>，所以在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避。</p>

<h3 id="toc_5">课后思考</h3>

<p><strong>常听人说，在 32 位的机器上对 long 型变量进行加减操作存在并发隐患，到底是不是这样呢？</strong></p>

<blockquote>
<p>答：long类型64位，所以在32位的机器上，对long类型的数据操作通常需要多条指令组合出来，无法保证原子性，所以并发的时候会出问题。</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755331803780.html">
                
                  <h1>02 | Java内存模型：看Java如何解决可见性和有序性问题</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>什么是Java内存模型？</li>
<li>使用volatile的困惑</li>
<li>Happen-Before规则
<ol>
<li>程序的顺序性规则</li>
<li>volatile 变量规则</li>
<li>传递性</li>
<li>管程中锁的规则</li>
<li>线程 start() 规则</li>
<li>线程 join() 规则</li>
</ol></li>
<li>被我们忽视的final</li>
<li>总结</li>
</ul>

<h3 id="toc_0">什么是Java内存模型？</h3>

<p>导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最合理的方案应该是<strong>按需禁用缓存以及编译优化</strong>。</p>

<p>Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 <strong>volatile</strong>、<strong>synchronized</strong> 和 <strong>final</strong> 三个关键字，以及六项 <strong>Happens-Before</strong> 规则。</p>

<h3 id="toc_1">使用volatile的困惑</h3>

<p>volatile 关键字并不是 Java 语言的特产，古老的 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。</p>

<p>Java 内存模型在 1.5 版本对 volatile 语义进行了增强。怎么增强的呢？答案是一项 Happens-Before 规则。</p>

<h3 id="toc_2">Happen-Before规则</h3>

<p>如何理解 Happens-Before 呢？<br/>
<strong>前面一个操作的结果对后续操作是可见的</strong>。Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则。</p>

<h4 id="toc_3">1. 程序的顺序性规则</h4>

<p>在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。</p>

<h4 id="toc_4">2. volatile 变量规则</h4>

<p>对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。</p>

<h4 id="toc_5">3. 传递性</h4>

<p>如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755331803780/15756041169729.jpg" alt=""/></p>

<h4 id="toc_6">4. 管程中锁的规则</h4>

<p>对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p>

<p>“管程指的是什么”。<strong>管程</strong>是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。<br/>
管程中的锁在 Java 里是隐式实现的，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。</p>

<h4 id="toc_7">5. 线程 start() 规则</h4>

<p>这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。</p>

<h4 id="toc_8">6. 线程 join() 规则</h4>

<p>这条是关于线程等待的。它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。</p>

<h3 id="toc_9">被我们忽视的final</h3>

<p>有没有办法告诉编译器优化得更好一点呢？这个可以有，就是<strong>final关键字</strong>。final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。</p>

<h3 id="toc_10">总结</h3>

<p>在 Java 语言里面，Happens-Before 的语义本质上是一种可见性，A Happens-Before B 意味着 A 事件对 B 事件来说是可见的，无论 A 事件和 B 事件是否发生在同一个线程里。例如 A 事件发生在线程 1 上，B 事件发生在线程 2 上，Happens-Before 规则保证线程 2 上也能看到 A 事件的发生。</p>

<h3 id="toc_11">课后思考</h3>

<p><strong>有一个共享变量 abc，在一个线程里设置了 abc 的值 abc=3，你思考一下，有哪些办法可以让其他线程能够看到abc==3？</strong></p>

<blockquote>
<p>答：</p>

<ol>
<li>声明共享变量abc，并使用volatile关键字修饰abc</li>
<li>声明共享变量abc，在synchronized关键字对abc的赋值代码块加锁，由于Happen-before管程锁的规则，可以使得后续的线程可以看到abc的值。</li>
<li>A线程启动后，使用A.JOIN()方法来完成运行，后续线程再启动，则一定可以看到abc==3</li>
</ol>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755331950338.html">
                
                  <h1>03 | 互斥锁（上）：解决原子性问题</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>简易锁模型</li>
<li>改进后的锁模型</li>
<li>Java 语言提供的锁技术：synchronized</li>
<li>用 synchronized 解决 count+=1 问题</li>
<li>锁和受保护资源的关系</li>
</ul>

<p><strong>那原子性问题到底该如何解决呢？</strong></p>

<p><strong>“同一时刻只有一个线程执行”</strong>这个条件非常重要，我们称之为<strong>互斥</strong>。如果我们能够<mark>保证对共享变量的修改是互斥</mark>的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性了。</p>

<h3 id="toc_0">简易锁模型</h3>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755331950338/15756051366392.jpg" alt=""/></p>

<p>我们把一段需要互斥执行的代码称为<strong>临界区</strong>。线程在进入临界区之前，首先尝试加锁 lock()，如果成功，则进入临界区，此时我们称这个线程持有锁；否则呢就等待，直到持有锁的线程解锁；持有锁的线程执行完临界区的代码后，执行解锁 unlock()。</p>

<h3 id="toc_1">改进后的锁模型</h3>

<p>锁和锁要保护的资源是有对应关系的，在并发编程世界里，锁和资源也应该有这个关系，但这个关系在我们上面的模型中是没有体现的，所以我们需要完善一下我们的模型。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755331950338/15756052110770.jpg" alt=""/></p>

<ol>
<li>首先，我们要把临界区要保护的资源标注出来，如图中临界区里增加了一个元素：受保护的资源 R；</li>
<li>其次，我们要保护资源 R 就得为它创建一把锁 LR；</li>
<li>最后，针对这把锁 LR，我们还需在进出临界区时添上加锁操作和解锁操作。</li>
<li>另外，在锁 LR 和受保护资源之间，我特地用一条线做了关联，这个关联关系非常重要。很多并发 Bug 的出现都是因为把它忽略了，然后就出现了类似锁自家门来保护他家资产的事情。</li>
</ol>

<h3 id="toc_2">Java 语言提供的锁技术：synchronized</h3>

<p>锁是一种通用的技术方案，Java 语言提供的 synchronized 关键字，就是锁的一种实现。synchronized 关键字可以用来修饰方法，也可以用来修饰代码块，它的使用示例基本上都是下面这个样子：</p>

<pre><code class="language-text">class X {
  // 修饰非静态方法
  synchronized void foo() {
    // 临界区
  }
  // 修饰静态方法
  synchronized static void bar() {
    // 临界区
  }
  // 修饰代码块
  Object obj = new Object()；
  void baz() {
    synchronized(obj) {
      // 临界区
    }
  }
}  
</code></pre>

<ul>
<li>Java 编译器会在 synchronized 修饰的方法或代码块前后自动加上加锁 lock() 和解锁 unlock()。</li>
<li>当修饰静态方法的时候，锁定的是当前类的 Class 对象，在上面的例子中就是 Class X；当修饰非静态方法的时候，锁定的是当前实例对象 this。</li>
</ul>

<pre><code class="language-text">class X {
  // 修饰静态方法
  synchronized(X.class) static void bar() {
    // 临界区
  }
}
class X {
  // 修饰非静态方法
  synchronized(this) void foo() {
    // 临界区
  }
}
</code></pre>

<h3 id="toc_3">用 synchronized 解决 count+=1 问题</h3>

<h3 id="toc_4">锁和受保护资源的关系</h3>

<p>受保护资源和锁之间的关联关系是 N:1 的关系。</p>

<pre><code class="language-text">class SafeCalc {
  static long value = 0L;
  synchronized long get() {
    return value;
  }
  synchronized static void addOne() {
    value += 1;
  }
}
</code></pre>

<p>如果你仔细观察，就会发现改动后的代码是用两个锁保护一个资源。这个受保护的资源就是静态变量 value，两个锁分别是 this 和 SafeCalc.class。我们可以用下面这幅图来形象描述这个关系。由于临界区 get() 和 addOne() 是用两个锁保护的，因此这两个临界区没有互斥关系，临界区 addOne() 对 value 的修改对临界区 get() 也没有可见性保证，这就导致并发问题了。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755331950338/15756138814606.jpg" alt=""/></p>

<h3 id="toc_5">总结</h3>

<p>互斥锁，在并发领域的知名度极高，只要有了并发问题，大家首先容易想到的就是加锁，因为大家都知道，加锁能够保证执行临界区代码的互斥性。临界区的代码是操作受保护资源的路径，不是随便一把锁都能有效。所以必须深入分析锁定的对象和受保护资源的关系，综合考虑受保护资源的访问路径，多方面考量才能用好互斥锁。</p>

<h3 id="toc_6">课后思考</h3>

<p><strong>下面的代码用 synchronized 修饰代码块来尝试解决并发问题，你觉得这个使用方式正确吗？有哪些问题呢？能解决可见性和原子性问题吗？</strong></p>

<pre><code class="language-text">class SafeCalc {
  long value = 0L;
  long get() {
    synchronized (new Object()) {
      return value;
    }
  }
  void addOne() {
    synchronized (new Object()) {
      value += 1;
    }
  }
}
</code></pre>

<blockquote>
<p>答：加锁本质就是在锁对象的对象头中写入当前线程id，但是new object每次在内存中都是新对象，所以加锁无效。<br/>
老师：<strong>一个合理的受保护资源与锁之间的关联关系应该是 N:1</strong>。只有共享一把锁才能起到互斥的作用。</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755331997391.html">
                
                  <h1>04 | 互斥锁（下）：如何用一把锁保护多个资源？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>保护没有关联关系的多个资源</li>
<li>保护有关联关系的多个资源</li>
<li>使用锁的正确姿势</li>
</ul>

<p>当我们要保护多个资源时，首先要区分这些资源是否存在关联关系。</p>

<h3 id="toc_0">保护没有关联关系的多个资源</h3>

<p>银行业务中有针对账户余额（余额是一种资源）的取款操作，也有针对账户密码（密码也是一种资源）的更改操作，我们可以为账户余额和账户密码<mark>分配不同的锁</mark>来解决并发问题，这个还是很简单的。</p>

<p><strong>用不同的锁对受保护资源进行精细化管理，能够提升性能。</strong>这种锁还有个名字，叫<strong>细粒度锁</strong>。</p>

<h3 id="toc_1">保护有关联关系的多个资源</h3>

<h3 id="toc_2">使用锁的正确姿势</h3>

<p>用同一把锁来保护多个资源，要求<strong>锁能覆盖所有受保护资源</strong>。<br/>
如何让 A 对象和 B 对象共享一把锁呢？<br/>
答：<strong>用 Account.class 作为共享的锁</strong>。Account.class 是所有 Account 对象共享的，而且这个对象是 Java 虚拟机在加载 Account 类的时候创建的，所以我们不用担心它的唯一性。使用 Account.class 作为共享的锁，我们就无需在创建 Account 对象时传入了，代码更简单。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755331997391/15756152046133.jpg" alt=""/></p>

<h3 id="toc_3">总结</h3>

<p>相信你看完这篇文章后，对如何保护多个资源已经很有心得了，关键是要<mark>分析多个资源之间的关系</mark>。</p>

<ul>
<li>如果资源之间没有关系，很好处理，每个资源一把锁就可以了。</li>
<li>如果资源之间有关联关系，就要选择一个粒度更大的锁，这个锁应该能够覆盖所有相关的资源。</li>
<li>除此之外，还要梳理出有哪些访问路径，所有的访问路径都要设置合适的锁，这个过程可以类比一下门票管理。</li>
</ul>

<p>关联关系如果用更具体、更专业的语言来描述的话，其实是一种“原子性”特征。<strong>“原子性”的本质</strong>是什么？其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，<strong>操作的中间状态对外不可见</strong>。所以<mark>解决原子性问题，是要保证中间状态对外不可见</mark>。</p>

<h3 id="toc_4">课后思考</h3>

<p><strong>在第一个示例程序里，我们用了两把不同的锁来分别保护账户余额、账户密码，创建锁的时候，我们用的是：private final Object xxxLock = new Object();，如果账户余额用 this.balance 作为互斥锁，账户密码用 this.password 作为互斥锁，你觉得是否可以呢？</strong></p>

<blockquote>
<p>答：用this.balance 和this.password 都不行。不能用可变对象做锁。<br/>
老师：一个是锁有可能会变化，另一个是 Integer 和 String 类型的对象不适合做锁。如果锁发生变化，就意味着失去了互斥功能。 Integer和String 类型的对象在 JVM 里面是可能被重用的，除此之外，JVM 里可能被重用的对象还有 Boolean，那重用意味着什么呢？意味着你的锁可能被其他代码使用，如果其他代码 synchronized(你的锁)，而且不释放，那你的程序就永远拿不到锁，这是隐藏的风险。<br/>
<strong>锁，应是私有的、不可变的、不可重用的。</strong></p>
</blockquote>

<p>锁的最佳实践：</p>

<pre><code class="language-text">// 普通对象锁
private final Object 
  lock = new Object();
// 静态对象锁
private static final Object
  lock = new Object(); 
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755332037088.html">
                
                  <h1>05 | 一不小心就死锁了，怎么办？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>向现实世界要答案</li>
<li>没有免费的午餐</li>
<li>如何预防死锁
<ol>
<li>破坏占用且等待条件</li>
<li>破坏不可抢占条件</li>
<li>破坏循环等待条件</li>
</ol></li>
</ul>

<p>在上一篇文章中，我们用 Account.class 作为互斥锁，来解决银行业务里面的转账问题，虽然这个方案不存在并发问题，但是所有账户的转账操作都是串行的，性能太差。</p>

<h3 id="toc_0">向现实世界要答案</h3>

<p>其实用两把锁就实现了，转出账本一把，转入账本另一把。在 transfer() 方法内部，我们首先尝试锁定转出账户 this（先把转出账本拿到手），然后尝试锁定转入账户 target（再把转入账本拿到手），只有当两者都成功时，才执行转账操作。这个逻辑可以图形化为下图这个样子。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332037088/15756196793198.jpg" alt=""/></p>

<pre><code class="language-text">class Account {
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    // 锁定转出账户
    synchronized(this) {              
      // 锁定转入账户
      synchronized(target) {           
        if (this.balance &gt; amt) {
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  } 
}
</code></pre>

<h3 id="toc_1">没有免费的午餐</h3>

<p>相对于用 Account.class 作为互斥锁，锁定的范围太大，我们锁定两个账户范围就小多了，这样的锁，上一章我们介绍过，叫<strong>细粒度锁</strong>。<mark>使用细粒度锁可以提高并行度，是性能优化的一个重要手段</mark>。</p>

<p>使用细粒度锁是有代价的，这个代价就是可能会导致<strong>死锁</strong>。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332037088/15756198699495.jpg" alt=""/></p>

<p>死锁的一个比较专业的定义是：<strong>一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象</strong>。</p>

<h3 id="toc_2">如何预防死锁</h3>

<p>要避免死锁就需要分析死锁发生的条件，只有以下这四个条件<mark>都发生</mark>时才会出现死锁：</p>

<ol>
<li>互斥，共享资源 X 和 Y 只能被一个线程占用；</li>
<li>占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</li>
<li>不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</li>
<li>循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</li>
</ol>

<p>也就是说只要我们破坏其中一个，就可以成功避免死锁的发生。其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥，不过其他三个条件都是有办法破坏掉的。</p>

<ol>
<li>对于“占用且等待”这个条件，我们可以<mark>一次性申请所有的资源</mark>，这样就不存在等待了。</li>
<li>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果<mark>申请不到，可以主动释放它占有的资源</mark>，这样不可抢占这个条件就破坏掉了。</li>
<li>对于“循环等待”这个条件，可以靠<mark>按序申请</mark>资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li>
</ol>

<p><strong>1. 破坏占用且等待条件</strong></p>

<p>对于“占用且等待”这个条件，我们可以<mark>一次性申请所有的资源</mark>，这样就不存在等待了。</p>

<p>可以增加一个账本管理员，然后只允许账本管理员从文件架上拿账本，只有账本 A 和 B 都在的时候才会给账本申请者。</p>

<p>对应到编程领域，“同时申请”这个操作是一个临界区，我们也需要一个角色（Java 里面的类）来管理这个临界区，我们就把这个角色定为 Allocator。它有两个重要功能，分别是：同时申请资源 apply() 和同时释放资源 free()。</p>

<p>账户 Account 类里面持有一个 Allocator 的单例（必须是单例，只能由一个人来分配资源）。</p>

<p>当账户 Account 在执行转账操作的时候：</p>

<ol>
<li>首先向 Allocator 同时申请转出账户和转入账户这两个资源，成功后再锁定这两个资源；</li>
<li>当转账操作执行完，释放锁之后，我们需通知 Allocator 同时释放转出账户和转入账户这两个资源。</li>
</ol>

<p>具体的代码实现如下：</p>

<pre><code class="language-text">class Allocator {
  private List&lt;Object&gt; als =
    new ArrayList&lt;&gt;();
  // 一次性申请所有资源
  synchronized boolean apply(
    Object from, Object to){
    if(als.contains(from) ||
         als.contains(to)){
      return false;  
    } else {
      als.add(from);
      als.add(to);  
    }
    return true;
  }
  // 归还资源
  synchronized void free(
    Object from, Object to){
    als.remove(from);
    als.remove(to);
  }
}

class Account {
  // actr应该为单例
  private Allocator actr;
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    // 一次性申请转出账户和转入账户，直到成功
    while(!actr.apply(this, target))
      ；
    try{
      // 锁定转出账户
      synchronized(this){              
        // 锁定转入账户
        synchronized(target){           
          if (this.balance &gt; amt){
            this.balance -= amt;
            target.balance += amt;
          }
        }
      }
    } finally {
      actr.free(this, target)
    }
  } 
}
</code></pre>

<p><strong>2. 破坏不可抢占条件</strong></p>

<p>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果<mark>申请不到，可以主动释放它占有的资源</mark>，这样不可抢占这个条件就破坏掉了。</p>

<p>破坏不可抢占条件看上去很简单，核心是要能够主动释放它占有的资源，这一点 synchronized 是做不到的。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。</p>

<p>后续 java.util.concurrent 这个包下面提供的 Lock 是可以解决这个问题的。</p>

<p><strong>3. 破坏循环等待条件</strong></p>

<p>对于“循环等待”这个条件，可以靠<mark>按序申请</mark>资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</p>

<p>这个实现非常简单，我们假设每个账户都有不同的属性 id，这个 id 可以作为排序字段，申请的时候，我们可以按照从小到大的顺序来申请。比如下面代码中，①~⑥处的代码对转出账户（this）和转入账户（target）排序，然后按照序号从小到大的顺序锁定账户。</p>

<pre><code class="language-text">class Account {
  private int id;
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    Account left = this        ①
    Account right = target;    ②
    if (this.id &gt; target.id) { ③
      left = target;           ④
      right = this;            ⑤
    }                          ⑥
    // 锁定序号小的账户
    synchronized(left){
      // 锁定序号大的账户
      synchronized(right){ 
        if (this.balance &gt; amt){
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  } 
}
</code></pre>

<h3 id="toc_3">总结</h3>

<p>我们今天这一篇文章主要讲了<strong>用细粒度锁来锁定多个资源时，要注意死锁的问题</strong>。这个就需要你能把它强化为一个思维定势，遇到这种场景，马上想到可能存在死锁问题。当你知道风险之后，才有机会谈如何预防和避免，因此，<strong>识别出风险很重要。</strong></p>

<p>预防死锁主要是破坏三个条件中的一个，有了这个思路后，实现就简单了。但仍需注意的是，有时候预防死锁成本也是很高的。例如上面转账那个例子，我们破坏占用且等待条件的成本就比破坏循环等待条件的成本高，破坏占用且等待条件，我们也是锁了所有的账户，而且还是用了死循环 while(!actr.apply(this, target));方法，不过好在 apply() 这个方法基本不耗时。 在转账这个例子中，破坏循环等待条件就是成本最低的一个方案。</p>

<p>所以我们在选择具体方案的时候，还需要<mark>评估一下操作成本</mark>，从中选择一个成本最低的方案。</p>

<h3 id="toc_4">课后思考</h3>

<p><strong>我们上面提到：破坏占用且等待条件，我们也是锁了所有的账户，而且还是用了死循环 while(!actr.apply(this, target));这个方法，那它比 synchronized(Account.class) 有没有性能优势呢？</strong></p>

<blockquote>
<p>synchronized(Account.class) 锁了Account类相关的所有操作。while死循环的方式只锁定了当前操作的两个相关的对象。两种影响到的范围不同。<br/>
while循环可以加个timeout，避免一直阻塞下去。</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755332090020.html">
                
                  <h1>06 | 用“等待-通知”机制优化循环等待</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>完美的就医流程</li>
<li>用 synchronized 实现等待 - 通知机制</li>
<li>小试牛刀：一个更好地资源分配器</li>
<li>尽量使用 notifyAll()</li>
</ul>

<h3 id="toc_0">完美的就医流程</h3>

<p>一个完整的等待 - 通知机制：</p>

<ol>
<li>线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；</li>
<li>当要求的条件满足时，通知等待的线程，重新获取互斥锁。</li>
</ol>

<h3 id="toc_1">用 synchronized 实现等待 - 通知机制</h3>

<p>在 Java 语言里，等待 - 通知机制可以有多种实现方式，比如 Java 语言内置的 synchronized 配合 wait()、notify()、notifyAll() 这三个方法就能轻松实现。</p>

<p>在下面这个图里，左边有一个等待队列，同一时刻，只允许一个线程进入 synchronized 保护的临界区（这个临界区可以看作大夫的诊室），当有一个线程进入临界区后，其他线程就只能进入图中左边的等待队列里等待（相当于患者分诊等待）。<strong>这个等待队列和互斥锁是一对一的关系，每个互斥锁都有自己独立的等待队列。</strong></p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332090020/15756237958943.jpg" alt=""/></p>

<p>在并发程序中，当一个线程进入临界区后，由于某些条件不满足，需要进入等待状态，Java 对象的 wait() 方法就能够满足这种需求。如上图所示，当调用 wait() 方法后，当前线程就会被阻塞，并且进入到右边的等待队列中，<strong>这个等待队列也是互斥锁的等待队列</strong>。 线程在进入等待队列的同时，<strong>会释放持有的互斥锁</strong>，线程释放锁后，其他线程就有机会获得锁，并进入临界区了。</p>

<p>那线程要求的条件满足时，该怎么通知这个等待的线程呢？很简单，就是 Java 对象的 notify() 和 notifyAll() 方法。当条件满足时调用 notify()，会通知等待队列（<strong>互斥锁的等待队列</strong>）中的线程，告诉它<strong>条件曾经满足过</strong>。</p>

<p>为什么说是曾经满足过呢？因为 <strong>notify() 只能保证在通知时间点，条件是满足的</strong>。而被通知线程的<strong>执行时间点和通知的时间点</strong>基本上不会重合，所以当线程执行的时候，很可能条件已经不满足了（保不齐有其他线程插队）。</p>

<h3 id="toc_2">小试牛刀：一个更好地资源分配器</h3>

<p>等待 - 通知机制的基本原理搞清楚后，我们就来看看它如何解决一次性申请转出账户和转入账户的问题吧。在这个等待 - 通知机制中，我们需要考虑以下四个要素。</p>

<ol>
<li>互斥锁：上一篇文章我们提到 Allocator 需要是单例的，所以我们可以用 this 作为互斥锁。</li>
<li>线程要求的条件：转出账户和转入账户都没有被分配过。</li>
<li>何时等待：线程要求的条件不满足就等待。</li>
<li>何时通知：当有线程释放账户时就通知。</li>
</ol>

<pre><code class="language-text">class Allocator {
  private List&lt;Object&gt; als;
  // 一次性申请所有资源
  synchronized void apply(
    Object from, Object to){
    // 经典写法
    while(als.contains(from) ||
         als.contains(to)){
      try{
        wait();
      }catch(Exception e){
      }   
    } 
    als.add(from);
    als.add(to);  
  }
  // 归还资源
  synchronized void free(
    Object from, Object to){
    als.remove(from);
    als.remove(to);
    notifyAll();
  }
}
</code></pre>

<h3 id="toc_3">尽量使用 notifyAll()</h3>

<p><strong>notify() 是会随机地通知等待队列中的一个线程，而 notifyAll() 会通知等待队列中的所有线程。</strong>使用 notify() 有风险，它的风险在于可能导致某些线程永远不会被通知到。</p>

<h3 id="toc_4">总结</h3>

<p>等待 - 通知机制是一种非常普遍的线程间协作的方式。工作中经常看到有同学使用轮询的方式来等待某个状态，其实很多情况下都可以用今天我们介绍的等待 - 通知机制来优化。Java 语言内置的 synchronized 配合 wait()、notify()、notifyAll() 这三个方法可以快速实现这种机制，但是它们的使用看上去还是有点复杂，所以你需要认真理解等待队列和 wait()、notify()、notifyAll() 的关系。</p>

<h3 id="toc_5">课后思考</h3>

<p><strong>很多面试都会问到，wait() 方法和 sleep() 方法都能让当前线程挂起一段时间，那它们的区别是什么？</strong></p>

<blockquote>
<p>wait与sleep区别在于：<br/>
    1. wait会释放所有锁而sleep不会释放锁资源；<br/>
    2. wait只能在同步方法和同步块中使用，而sleep任何地方都可以；<br/>
    3. wait无需捕捉异常，而sleep需要。<br/>
两者相同点：都会让渡CPU执行时间，等待再次调度！</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755332130103.html">
                
                  <h1>07 | 安全性、活跃性以及性能问题</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>安全性问题</li>
<li>活跃性问题</li>
<li>性能问题</li>
</ul>

<p>并发编程中我们需要注意的问题有很多，主要有三个方面，分别是：安全性问题、活跃性问题和性能问题。</p>

<h3 id="toc_0">安全性问题</h3>

<p>什么是线程安全？其实本质上就是正确性，而正确性的含义就是<strong>程序按照我们期望的执行</strong>。</p>

<p>那如何才能写出线程安全的程序呢？理论上线程安全的程序，就要避免出现原子性问题、可见性问题和有序性问题。</p>

<p>那是不是所有的代码都需要认真分析一遍是否存在这三个问题呢？当然不是，其实只有一种情况需要：<strong>存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据。</strong></p>

<p>当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发 Bug，对此还有一个专业的术语，叫做<strong>数据竞争</strong>（Data Race）。</p>

<p><strong>竞态条件</strong>（Race Condition），<strong>指的是程序的执行结果依赖线程执行的顺序。</strong></p>

<p>在并发场景中，程序的执行依赖于某个状态变量，当某个线程发现状态变量满足执行条件后，开始执行操作；可是就在这个线程执行操作的时候，其他线程同时修改了状态变量，导致状态变量不满足执行条件了。</p>

<p>那面对数据竞争和竞态条件问题，又该如何保证线程的安全性呢？其实这两类问题，都可以用<strong>互斥</strong>这个技术方案，而实现互斥的方案有很多，CPU 提供了相关的互斥指令，操作系统、编程语言也会提供相关的 API。从逻辑上来看，我们可以统一归为：<strong>锁</strong>。</p>

<h3 id="toc_1">活跃性问题</h3>

<p>所谓活跃性问题，指的是某个操作无法执行下去。我们常见的<strong>“死锁”</strong>就是一种典型的活跃性问题，当然除了死锁外，还有两种情况，分别是<strong>“活锁”和“饥饿”</strong>。</p>

<p><strong>有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的“活锁”。</strong>可以类比现实世界里的例子，路人甲从左手边出门，路人乙从右手边进门，两人为了不相撞，互相谦让，路人甲让路走右手边，路人乙也让路走左手边，结果是两人又相撞了。这种情况，基本上谦让几次就解决了，因为人会交流啊。</p>

<p>解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。</p>

<p>那“饥饿”该怎么去理解呢？<strong>所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况。</strong>如果线程优先级“不均”，在 CPU 繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。</p>

<p>解决“饥饿”问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。</p>

<p>那如何公平地分配资源呢？在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。</p>

<h3 id="toc_2">性能问题</h3>

<p>使用“锁”要非常小心，但是如果小心过度，也可能出“性能问题”。“锁”的过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了，而我们之所以使用多线程搞并发程序，为的就是提升性能。</p>

<p>使用锁的时候一定要关注对性能的影响。 那怎么才能避免锁带来的性能问题呢？这个问题很复杂，Java SDK 并发包里之所以有那么多东西，有很大一部分原因就是要提升在某个特定领域的性能。</p>

<p>不过从方案层面，我们可以这样来解决这个问题：</p>

<p>第一，既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。在这方面有很多相关的技术，例如线程本地存储 (Thread Local Storage, TLS)、写入时复制 (Copy-on-write)、乐观锁等；Java 并发包里面的原子类也是一种无锁的数据结构；Disruptor 则是一个无锁的内存队列，性能都非常好……</p>

<p>第二，减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是 Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术（这个技术后面我们会详细介绍）；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。</p>

<p>性能方面的度量指标有很多，我觉得有三个指标非常重要，就是：吞吐量、延迟和并发量。</p>

<ul>
<li>吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。</li>
<li>延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。</li>
<li>并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。</li>
</ul>

<h3 id="toc_3">总结</h3>

<p>并发编程是一个复杂的技术领域，微观上涉及到原子性问题、可见性问题和有序性问题，宏观则表现为安全性、活跃性以及性能问题。</p>

<p>我们在设计并发程序的时候，主要是从宏观出发，也就是要重点关注它的安全性、活跃性以及性能。安全性方面要注意数据竞争和竞态条件，活跃性方面需要注意死锁、活锁、饥饿等问题，性能方面我们虽然介绍了两个方案，但是遇到具体问题，你还是要具体分析，根据特定的场景选择合适的数据结构和算法。</p>

<h3 id="toc_4">课后思考</h3>

<p><strong>Java 语言提供的 Vector 是一个线程安全的容器，有同学写了下面的代码，你看看是否存在并发问题呢？</strong></p>

<pre><code class="language-text">void addIfNotExist(Vector v, 
    Object o){
  if(!v.contains(o)) {
    v.add(o);
  }
}
</code></pre>

<blockquote>
<p>答：vector是线程安全，指的是它方法单独执行的时候没有并发正确性问题，并不代表把它的<strong>操作组合</strong>在一起没有问题，而这个程序显然有老师讲的竞态条件问题。<br/>
老师：你需要将共享变量 v 封装在对象的内部，而后控制并发访问的路径，这样就能有效防止对 Vector v 变量的滥用，从而导致并发问题。</p>
</blockquote>

<pre><code class="language-text">class SafeVector{
  private Vector v; 
  // 所有公共方法增加同步控制
  synchronized 
  void addIfNotExist(Object o){
    if(!v.contains(o)) {
      v.add(o);
    }
  }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755332165533.html">
                
                  <h1>08 | 管程：并发编程的万能钥匙</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>什么是管程</li>
<li>MESA 模型</li>
<li>wait() 的正确姿势</li>
<li>notify() 何时可以使用</li>
</ul>

<h3 id="toc_0">什么是管程</h3>

<p><strong>管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。</strong></p>

<p><strong>管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。</strong></p>

<h3 id="toc_1">MESA 模型</h3>

<p>在管程的发展史上，先后出现过三种不同的<strong>管程模型</strong>，分别是：Hasen 模型、Hoare 模型和 MESA 模型。其中，现在广泛应用的是 MESA 模型，并且 Java 管程的实现参考的也是 MESA 模型。所以今天我们重点介绍一下 MESA 模型。</p>

<p>在并发编程领域，有两大核心问题：一个是<strong>互斥</strong>，即同一时刻只允许一个线程访问共享资源；另一个是<strong>同步</strong>，即线程之间如何通信、协作。这两大问题，管程都是能够解决的。</p>

<p><strong>管程是如何解决互斥问题的</strong></p>

<p>管程解决互斥问题的思路很简单，就是<mark>将共享变量及其对共享变量的操作统一封装起来</mark>。在下图中，管程 X 将共享变量 queue 这个队列和相关的操作入队 enq()、出队 deq() 都封装起来了；线程 A 和线程 B 如果想访问共享变量 queue，只能通过调用管程提供的 enq()、deq() 方法来实现；enq()、deq() 保证<mark>互斥性</mark>，只允许一个线程进入管程。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332165533/15758857831652.jpg" alt=""/></p>

<p><strong>管程如何解决线程间的同步问题?</strong></p>

<p>在管程模型里，共享变量和对共享变量的操作是被封装起来的，图中最外层的框就代表封装的意思。框的上面只有一个入口，并且在入口旁边还有一个入口等待队列。当多个线程同时试图进入管程内部时，只允许一个线程进入，其他线程则在入口等待队列中等待。这个过程类似就医流程的分诊，只允许一个患者就诊，其他患者都在门口等待。管程里还引入了条件变量的概念，而且<strong>每个条件变量都对应有一个等待队列</strong>，如下图，条件变量 A 和条件变量 B 分别都有自己的等待队列。</p>

<p>那<mark>条件变量和等待队列</mark>的作用是什么呢？其实就是解决线程同步问题。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332165533/15758858118089.jpg" alt=""/></p>

<pre><code class="language-text">public class BlockedQueue&lt;T&gt;{
  final Lock lock =
    new ReentrantLock();
  // 条件变量：队列不满  
  final Condition notFull =
    lock.newCondition();
  // 条件变量：队列不空  
  final Condition notEmpty =
    lock.newCondition();

  // 入队
  void enq(T x) {
    lock.lock();
    try {
      while (队列已满){
        // 等待队列不满 
        notFull.await();
      }  
      // 省略入队操作...
      //入队后,通知可出队
      notEmpty.signal();
    }finally {
      lock.unlock();
    }
  }
  // 出队
  void deq(){
    lock.lock();
    try {
      while (队列已空){
        // 等待队列不空
        notEmpty.await();
      }
      // 省略出队操作...
      //出队后，通知可入队
      notFull.signal();
    }finally {
      lock.unlock();
    }  
  }
}
</code></pre>

<h3 id="toc_2">wait() 的正确姿势</h3>

<p>但是有一点，需要再次提醒，对于 MESA 管程来说，有一个编程范式，就是需要在一个 while 循环里面调用 wait()。这个是 MESA 管程特有的。</p>

<pre><code class="language-text">while(条件不满足) {
  wait();
}
</code></pre>

<h3 id="toc_3">notify() 何时可以使用</h3>

<p>还有一个需要注意的地方，就是 notify() 和 notifyAll() 的使用，前面章节，我曾经介绍过，<strong>除非经过深思熟虑，否则尽量使用 notifyAll()。</strong>那什么时候可以使用 notify() 呢？需要满足以下三个条件：</p>

<ol>
<li>所有等待线程拥有相同的等待条件；</li>
<li>所有等待线程被唤醒后，执行相同的操作；</li>
<li>只需要唤醒一个线程。</li>
</ol>

<h3 id="toc_4">总结</h3>

<p>Java 参考了 MESA 模型，语言内置的管程（synchronized）对 MESA 模型进行了精简。MESA 模型中，条件变量可以有多个，Java 语言内置的管程里只有一个条件变量。具体如下图所示。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332165533/15758864080151.jpg" alt=""/></p>

<p>Java 内置的管程方案（synchronized）使用简单，synchronized 关键字修饰的代码块，在编译期会自动生成相关加锁和解锁的代码，但是仅支持一个条件变量；而 Java SDK 并发包实现的管程支持多个条件变量，不过并发包里的锁，需要开发人员自己进行加锁和解锁操作。</p>

<p>并发编程里两大核心问题——互斥和同步，都可以由管程来帮你解决。学好管程，理论上所有的并发问题你都可以解决，并且很多并发工具类底层都是管程实现的，所以学好管程，就是相当于掌握了一把并发编程的万能钥匙。</p>

<h3 id="toc_5">课后思考</h3>

<p><strong>wait() 方法，在 Hasen 模型和 Hoare 模型里面，都是没有参数的，而在 MESA 模型里面，增加了超时参数，你觉得这个参数有必要吗？</strong></p>

<blockquote>
<p>有hasen 是执行完，再去唤醒另外一个线程。能够保证线程的执行。hoare，是中断当前线程，唤醒另外一个线程，执行玩再去唤醒，也能够保证完成。而mesa是进入等待队列，不一定有机会能够执行。</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755332204025.html">
                
                  <h1>09 | Java线程（上）：Java线程的生命周期</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>通用的线程生命周期</li>
<li>Java 中线程的生命周期
<ol>
<li>RUNNABLE 与 BLOCKED 的状态转换</li>
<li>RUNNABLE 与 WAITING 的状态转换</li>
<li>RUNNABLE 与 TIMED_WAITING 的状态转换</li>
<li>从 NEW 到 RUNNABLE 状态</li>
<li>从 RUNNABLE 到 TERMINATED 状态</li>
</ol></li>
</ul>

<h3 id="toc_0">通用的线程生命周期</h3>

<p>通用的线程生命周期基本上可以用下图这个“五态模型”来描述。这五态分别是：<strong>初始状态、可运行状态、运行状态、休眠状态和终止状态。</strong></p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332204025/15759596960027.jpg" alt=""/></p>

<p>这“五态模型”的详细情况如下所示：</p>

<ol>
<li><strong>初始状态</strong>，指的是线程已经被创建，但是还不允许分配 CPU 执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还没有创建。</li>
<li><strong>可运行状态</strong>，指的是线程可以分配 CPU 执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配 CPU 执行。</li>
<li>当有空闲的 CPU 时，操作系统会将其分配给一个处于可运行状态的线程，被分配到 CPU 的线程的状态就转换成了<strong>运行状态</strong>。</li>
<li>运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会转换到<strong>休眠状态</strong>，同时释放 CPU 使用权，休眠状态的线程永远没有机会获得 CPU 使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。</li>
<li>线程执行完或者出现异常就会进入<strong>终止状态</strong>，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。</li>
</ol>

<h3 id="toc_1">Java 中线程的生命周期</h3>

<p>Java 语言中线程共有六种状态，分别是：</p>

<ol>
<li>NEW（初始化状态）</li>
<li>RUNNABLE（可运行 / 运行状态）</li>
<li>BLOCKED（阻塞状态）</li>
<li>WAITING（无时限等待）</li>
<li>TIMED_WAITING（有时限等待）</li>
<li>TERMINATED（终止状态）</li>
</ol>

<p>在操作系统层面，Java 线程中的 BLOCKED、WAITING、TIMED_WAITING 是一种状态，即前面我们提到的<mark>休眠状态</mark>。也就是说<strong>只要 Java 线程处于这三种状态之一，那么这个线程就永远没有 CPU 的使用权</strong>。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332204025/15759598450498.jpg" alt=""/></p>

<p><strong>1. RUNNABLE 与 BLOCKED 的状态转换</strong></p>

<p>只有一种场景会触发这种转换，就是线程等待 synchronized 的隐式锁。</p>

<p><strong>2. RUNNABLE 与 WAITING 的状态转换</strong></p>

<p>总体来说，有三种场景会触发这种转换。</p>

<ul>
<li>第一种场景，获得 synchronized 隐式锁的线程，调用无参数的 Object.wait() 方法。</li>
<li>第二种场景，调用无参数的 Thread.join() 方法。其中的 join() 是一种线程同步方法，例如有一个线程对象 thread A，当调用 A.join() 的时候，执行这条语句的线程会等待 thread A 执行完，而等待中的这个线程，其状态会从 RUNNABLE 转换到 WAITING。当线程 thread A 执行完，原来等待它的线程又会从 WAITING 状态转换到 RUNNABLE。</li>
<li>第三种场景，调用 LockSupport.park() 方法。调用 LockSupport.park() 方法，当前线程会阻塞，线程的状态会从 RUNNABLE 转换到 WAITING。调用 LockSupport.unpark(Thread thread) 可唤醒目标线程，目标线程的状态又会从 WAITING 状态转换到 RUNNABLE。</li>
</ul>

<p><strong>3. RUNNABLE 与 TIMED_WAITING 的状态转换</strong></p>

<p>有五种场景会触发这种转换：</p>

<ol>
<li>调用带超时参数的 Thread.<mark>sleep</mark>(long millis) 方法；</li>
<li>获得 synchronized 隐式锁的线程，调用带超时参数的 Object.<mark>wait</mark>(long timeout) 方法；</li>
<li>调用带超时参数的 Thread.<mark>join</mark>(long millis) 方法；</li>
<li>调用带超时参数的 LockSupport.<mark>parkNanos</mark>(Object blocker, long deadline) 方法；</li>
<li>调用带超时参数的 LockSupport.<mark>parkUntil</mark>(long deadline) 方法。</li>
</ol>

<p>这里你会发现 TIMED_WAITING 和 WAITING 状态的区别，仅仅是触发条件多了<mark>超时参数</mark>。</p>

<p><strong>4. 从 NEW 到 RUNNABLE 状态</strong></p>

<p>Java 刚创建出来的 Thread 对象就是 NEW 状态，而创建 Thread 对象主要有两种方法。一种是继承 Thread 对象，重写 run() 方法。</p>

<p><strong>5. 从 RUNNABLE 到 TERMINATED 状态</strong></p>

<p>线程执行完 run() 方法后，会自动转换到 TERMINATED 状态，当然如果执行 run() 方法的时候异常抛出，也会导致线程终止。有时候我们需要强制中断 run() 方法的执行，Java 的 Thread 类里面有个 stop() 方法，不过已经标记为 @Deprecated，所以不建议使用了。正确的姿势其实是调用 interrupt() 方法。</p>

<p><strong>那 stop() 和 interrupt() 方法的主要区别是什么呢？</strong></p>

<p>stop() 方法会真的杀死线程，不给线程喘息的机会，如果线程持有 ReentrantLock 锁，被 stop() 的线程并不会自动调用 ReentrantLock 的 unlock() 去释放锁，那其他线程就再也没机会获得 ReentrantLock 锁，这实在是太危险了。所以该方法就不建议使用了，类似的方法还有 suspend() 和 resume() 方法，这两个方法同样也都不建议使用了，所以这里也就不多介绍了。</p>

<p>而 interrupt() 方法就温柔多了，interrupt() 方法仅仅是通知线程，线程有机会执行一些后续操作，同时也可以无视这个通知。被 interrupt 的线程，是怎么收到通知的呢？一种是异常，另一种是主动检测。</p>

<h3 id="toc_2">总结</h3>

<p>理解 Java 线程的各种状态以及生命周期对于诊断多线程 Bug 非常有帮助，多线程程序很难调试，出了 Bug 基本上都是靠日志，靠线程 dump 来跟踪问题，分析线程 dump 的一个基本功就是分析线程状态，大部分的死锁、饥饿、活锁问题都需要跟踪分析线程的状态。</p>

<p>你可以通过 jstack 命令或者Java VisualVM这个可视化工具将 JVM 所有的线程栈信息导出来，完整的线程栈信息不仅包括线程的当前状态、调用栈，还包括了锁的信息。</p>

<h3 id="toc_3">课后思考</h3>

<p><strong>下面代码的本意是当前线程被中断之后，退出while(true)，你觉得这段代码是否正确呢？</strong></p>

<pre><code class="language-text">Thread th = Thread.currentThread();
while(true) {
  if(th.isInterrupted()) {
    break;
  }
  // 省略业务代码无数
  try {
    Thread.sleep(100);
  }catch (InterruptedException e){
    e.printStackTrace();
  }
}
</code></pre>

<blockquote>
<p>答：可能出现无限循环，线程在sleep期间被打断了，抛出一个InterruptedException异常，try catch捕捉此异常，应该重置一下中断标示，因为抛出异常后，中断标示会自动清除掉！</p>
</blockquote>

<pre><code class="language-text">Thread th = Thread.currentThread();
while(true) {
  if(th.isInterrupted()) {
    break;
  }
  // 省略业务代码无数
  try {
    Thread.sleep(100);
  }catch (InterruptedException e)｛
    Thread.currentThread().interrupt();
    e.printStackTrace();
  }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755332247193.html">
                
                  <h1>10 | Java线程（中）：创建多少线程才是合适的？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>为什么要使用多线程？</li>
<li>多线程的应用场景</li>
<li>创建多少线程合适？</li>
</ul>

<p>要解决这个问题，首先要分析以下两个问题：</p>

<ol>
<li>为什么要使用多线程？</li>
<li>多线程的应用场景有哪些？</li>
</ol>

<h3 id="toc_0">为什么要使用多线程？</h3>

<p>使用多线程，本质上就是提升程序性能。</p>

<p>在提升性能之前，首要问题是：<strong>如何度量性能</strong>。</p>

<p>度量性能的指标有很多，但是有两个指标是最核心的，它们就是<strong>延迟和吞吐量</strong>。</p>

<ul>
<li>延迟指的是发出请求到收到响应这个过程的时间；延迟越短，意味着程序执行得越快，性能也就越好。</li>
<li>吞吐量指的是在单位时间内能处理请求的数量；吞吐量越大，意味着程序能处理的请求越多，性能也就越好。</li>
</ul>

<p>这两个指标内部有一定的联系（同等条件下，延迟越短，吞吐量越大），但是由于它们隶属不同的维度（一个是时间维度，一个是空间维度），并不能互相转换。</p>

<p>我们所谓提升性能，从度量的角度，主要是<strong>降低延迟，提高吞吐量</strong>。</p>

<h3 id="toc_1">多线程的应用场景</h3>

<p>要想“降低延迟，提高吞吐量”，对应的方法呢，基本上有两个方向，一个方向是<strong>优化算法</strong>，另一个方向是<strong>将硬件的性能发挥到极致</strong>。前者属于<mark>算法范畴</mark>，后者则是和<mark>并发</mark>编程息息相关了。那计算机主要有哪些硬件呢？主要是两类：一个是 I/O，一个是 CPU。简言之，<strong>在并发编程领域，提升性能本质上就是提升硬件的利用率</strong>，再具体点来说，就是<strong>提升 I/O 的利用率和 CPU 的利用率</strong>。</p>

<p>操作系统解决硬件利用率问题的对象往往是单一的硬件设备，而我们的并发程序，往往需要 CPU 和 I/O 设备相互配合工作，也就是说，<strong>我们需要解决 CPU 和 I/O 设备<mark>综合利用率</mark>的问题</strong>。关于这个综合利用率的问题，操作系统虽然没有办法完美解决，但是却给我们提供了方案，那就是：多线程。</p>

<p>如下图所示，如果只有一个线程，执行 CPU 计算的时候，I/O 设备空闲；执行 I/O 操作的时候，CPU 空闲，所以 CPU 的利用率和 I/O 设备的利用率都是 50%。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332247193/15759606513614.jpg" alt=""/></p>

<p>如果有两个线程，如下图所示，当线程 A 执行 CPU 计算的时候，线程 B 执行 I/O 操作；当线程 A 执行 I/O 操作的时候，线程 B 执行 CPU 计算，这样 CPU 的利用率和 I/O 设备的利用率就都达到了 100%。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332247193/15759606613109.jpg" alt=""/></p>

<p>我们将 CPU 的利用率和 I/O 设备的利用率都提升到了 100%，会对性能产生了哪些影响呢？通过上面的图示，很容易看出：单位时间处理的请求数量翻了一番，也就是说吞吐量提高了 1 倍。此时可以逆向思维一下，<strong>如果 CPU 和 I/O 设备的利用率都很低，那么可以尝试通过增加线程来提高吞吐量</strong>。</p>

<p>在单核时代，多线程主要就是用来平衡 CPU 和 I/O 设备的。如果程序只有 CPU 计算，而没有 I/O 操作的话，多线程不但不会提升性能，还会使性能变得更差，原因是增加了线程切换的成本。但是在多核时代，这种纯计算型的程序也可以利用多线程来提升性能。为什么呢？因为利用多核可以降低响应时间。</p>

<p>为便于你理解，这里我举个简单的例子说明一下：计算 1+2+… … +100 亿的值，如果在 4 核的 CPU 上利用 4 个线程执行，线程 A 计算 [1，25 亿)，线程 B 计算 [25 亿，50 亿)，线程 C 计算 [50，75 亿)，线程 D 计算 [75 亿，100 亿]，之后汇总，那么理论上应该比一个线程计算 [1，100 亿] 快将近 4 倍，响应时间能够降到 25%。一个线程，对于 4 核的 CPU，CPU 的利用率只有 25%，而 4 个线程，则能够将 CPU 的利用率提高到 100%。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332247193/15759607051910.jpg" alt=""/></p>

<h3 id="toc_2">创建多少线程合适？</h3>

<p>创建多少线程合适，要看多线程具体的应用场景。我们的程序一般都是 CPU 计算和 I/O 操作交叉执行的，由于 I/O 设备的速度相对于 CPU 来说都很慢，所以大部分情况下，I/O 操作执行的时间相对于 CPU 计算来说都非常长，这种场景我们一般都称为 <mark>I/O 密集型计算</mark>；和 I/O 密集型计算相对的就是 <mark>CPU 密集型</mark>计算了，CPU 密集型计算大部分场景下都是纯 CPU 计算。I/O 密集型程序和 CPU 密集型程序，计算最佳线程数的方法是不同的。</p>

<p>对于 CPU 密集型计算，多线程本质上是提升多核 CPU 的利用率，所以对于一个 4 核的 CPU，每个核一个线程，理论上创建 4 个线程就可以了，再多创建线程也只是增加线程切换的成本。所以，<strong>对于 CPU 密集型的计算场景，理论上“线程的数量 =CPU 核数”就是最合适的。</strong>不过在工程上，<strong>线程的数量一般会设置为“CPU 核数 +1”</strong>，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证 CPU 的利用率。</p>

<p>对于 I/O 密集型的计算场景，比如前面我们的例子中，如果 CPU 计算和 I/O 操作的耗时是 1:1，那么 2 个线程是最合适的。如果 CPU 计算和 I/O 操作的耗时是 1:2，那多少个线程合适呢？是 3 个线程，如下图所示：CPU 在 A、B、C 三个线程之间切换，对于线程 A，当 CPU 从 B、C 切换回来时，线程 A 正好执行完 I/O 操作。这样 CPU 和 I/O 设备的利用率都达到了 100%。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332247193/15759608373987.jpg" alt=""/></p>

<p>通过上面这个例子，我们会发现，对于 I/O 密集型计算场景，最佳的线程数是与程序中 CPU 计算和 I/O 操作的耗时比相关的，我们可以总结出这样一个公式：</p>

<blockquote>
<p>最佳线程数 =1 +（I/O 耗时 / CPU 耗时）</p>
</blockquote>

<p>我们令 R=I/O 耗时 / CPU 耗时，综合上图，可以这样理解：当线程 A 执行 IO 操作时，另外 R 个线程正好执行完各自的 CPU 计算。这样 CPU 的利用率就达到了 100%。</p>

<p>不过上面这个公式是针对单核 CPU 的，至于多核 CPU，也很简单，只需要等比扩大就可以了，计算公式如下：</p>

<blockquote>
<p>最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]</p>
</blockquote>

<h3 id="toc_3">总结</h3>

<p>很多人都知道线程数不是越多越好，但是设置多少是合适的，却又拿不定主意。其实只要把握住一条原则就可以了，这条原则就是<strong>将硬件的性能发挥到极致</strong>。上面我们针对 CPU 密集型和 I/O 密集型计算场景都给出了理论上的最佳公式，这些公式背后的目标其实就是将硬件的性能发挥到极致。</p>

<p>对于 I/O 密集型计算场景，I/O 耗时和 CPU 耗时的比值是一个关键参数，不幸的是这个参数是未知的，而且是动态变化的，所以工程上，我们要估算这个参数，然后做各种不同场景下的压测来验证我们的估计。不过工程上，原则还是将硬件的性能发挥到极致，所以压测时，我们需要重点关注 CPU、I/O 设备的利用率和性能指标（响应时间、吞吐量）之间的关系。</p>

<h3 id="toc_4">课后思考</h3>

<p><strong>有些同学对于最佳线程数的设置积累了一些经验值，认为对于 I/O 密集型应用，最佳线程数应该为：2 * CPU 的核数 + 1，你觉得这个经验值合理吗？</strong></p>

<blockquote>
<p>不合理，应该根据是IO密集型或者是CPU密集型，具体问题具体分析。<br/>
老师：我们曾讲到最佳线程数最终还是靠压测来确定的，实际工作中大家面临的系统，“I/O 耗时 / CPU 耗时”往往都大于 1，所以基本上都是在这个<strong>初始值的基础上增加</strong>。增加的过程中，应关注线程数是如何影响吞吐量和延迟的。一般来讲，随着线程数的增加，吞吐量会增加，延迟也会缓慢增加；但是当线程数增加到一定程度，吞吐量就会开始下降，延迟会迅速增加。这个时候基本上就是线程能够设置的最大值了。</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755332290388.html">
                
                  <h1>11 | Java线程（下）：为什么局部变量是线程安全的？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>方法是如何被执行的</li>
<li>局部变量存哪里？</li>
<li>调用栈与线程</li>
<li>线程封闭</li>
</ul>

<h3 id="toc_0">方法是如何被执行的</h3>

<pre><code class="language-text">int a = 7；
int[] b = fibonacci(a);
int[] c = b;
</code></pre>

<p>当调用 fibonacci(a) 的时候，CPU 要先找到方法 fibonacci() 的地址，然后跳转到这个地址去执行代码，最后 CPU 执行完方法 fibonacci() 之后，要能够返回。首先找到调用方法的下一条语句的地址：也就是int[] c=b;的地址，再跳转到这个地址去执行。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332290388/15763012738176.jpg" alt=""/></p>

<p><strong>“CPU 去哪里找到调用方法的参数和返回地址？”</strong></p>

<p><strong>通过 CPU 的堆栈寄存器</strong>。CPU 支持一种栈结构，先入后出。因为这个栈是和方法调用相关的，因此经常被称为调用栈。</p>

<p>例如，有三个方法 A、B、C，他们的调用关系是 A-&gt;B-&gt;C（A 调用 B，B 调用 C），在运行时，会构建出下面这样的调用栈。每个方法在调用栈里都有自己的独立空间，称为栈帧，每个栈帧里都有对应方法需要的参数和返回地址。当调用方法时，会创建新的栈帧，并压入调用栈；当方法返回时，对应的栈帧就会被自动弹出。也就是说，<strong>栈帧和方法是同生共死的</strong>。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332290388/15763013784499.jpg" alt=""/></p>

<h3 id="toc_1">局部变量存哪里？</h3>

<p>局部变量的作用域是方法内部，也就是说当方法执行完，局部变量就没用了，局部变量应该和方法同生共死。此时你应该会想到调用栈的栈帧，调用栈的栈帧就是和方法同生共死的，所以局部变量放到调用栈里那儿是相当的合理。事实上，的确是这样的，<strong>局部变量就是放到了调用栈里。</strong></p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332290388/15763014843732.jpg" alt=""/></p>

<p>Java中new 出来的对象是在堆里，局部变量是在栈里。局部变量是和方法同生共死的，一个变量如果想跨越方法的边界，就必须创建在堆里。</p>

<h3 id="toc_2">调用栈与线程</h3>

<p>两个线程可以同时用不同的参数调用相同的方法，那调用栈和线程之间是什么关系呢？答案是：<strong>每个线程都有自己独立的调用栈</strong>。因为如果不是这样，那两个线程就互相干扰了。如下面这幅图所示，线程 A、B、C 每个线程都有自己独立的调用栈。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332290388/15763015944398.jpg" alt=""/></p>

<p>现在，让我们回过头来再看篇首的问题：Java 方法里面的局部变量是否存在并发问题？现在你应该很清楚了，一点问题都没有。因为每个线程都有自己的调用栈，局部变量保存在线程各自的调用栈里面，不会共享，所以自然也就没有并发问题。</p>

<h3 id="toc_3">线程封闭</h3>

<p>方法里的局部变量，因为不会和其他线程共享，所以没有并发问题，这个思路很好，已经成为解决并发问题的一个重要技术，同时还有个响当当的名字叫做<strong>线程封闭</strong>，比较官方的解释是：<strong>仅在单线程内访问数据</strong>。</p>

<p>采用线程封闭技术的案例非常多，例如从数据库连接池里获取的连接 Connection，在 JDBC 规范里并没有要求这个 Connection 必须是线程安全的。数据库连接池通过线程封闭技术，保证一个 Connection 一旦被一个线程获取之后，在这个线程关闭 Connection 之前的这段时间里，不会再分配给其他线程，从而保证了 Connection 不会有并发问题。</p>

<h3 id="toc_4">课后思考</h3>

<p><strong>常听人说，递归调用太深，可能导致栈溢出。你思考一下原因是什么？有哪些解决方案呢？</strong></p>

<blockquote>
<p>答：<br/>
<strong>栈溢出原因：</strong><br/>
因为每调用一个方法就会在栈上创建一个栈帧，方法调用结束后就会弹出该栈帧，而栈的大小不是无限的，所以递归调用次数过多的话就会导致栈溢出。而递归调用的特点是每递归一次，就要创建一个新的栈帧，而且还要保留之前的环境（栈帧），直到遇到结束条件。所以递归调用一定要明确好结束条件，不要出现死循环，而且要避免栈太深。<br/>
<strong>解决方法：</strong></p>

<ol>
<li>简单粗暴，不要使用递归，使用循环替代。缺点：代码逻辑不够清晰；</li>
<li>限制递归次数；</li>
<li>使用尾递归，尾递归是指在方法返回时只调用自己本身，且不能包含表达式。编译器或解释器会把尾递归做优化，使递归方法不论调用多少次，都只占用一个栈帧，所以不会出现栈溢出。然鹅，Java没有尾递归优化。</li>
</ol>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755332325700.html">
                
                  <h1>12 | 如何用面向对象思想写好并发程序？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>一、封装共享变量</li>
<li>二、识别共享变量间的约束条件</li>
<li>三、制定并发访问策略</li>
</ul>

<h3 id="toc_0">一、封装共享变量</h3>

<p>面向对象思想里面有一个很重要的特性是<strong>封装</strong>，封装的通俗解释就是<strong>将属性和实现细节封装在对象内部</strong>，外界对象<strong>只能通过</strong>目标对象提供的<strong>公共方法来间接访问</strong>这些内部属性。</p>

<p>利用面向对象思想写并发程序的思路：<strong>将共享变量作为对象属性封装在内部，对所有公共方法制定并发访问策略</strong>。</p>

<p>实际工作中，经常要面临的情况往往是有很多的共享变量，对于一些不会发生变化的共享变量，建议你用 final 关键字来修饰。这样既能避免并发问题，也能很明了地表明你的设计意图。</p>

<h3 id="toc_1">二、识别共享变量间的约束条件</h3>

<p>识别共享变量间的约束条件非常重要。因为这些<strong>约束条件，决定了并发访问策略</strong>。</p>

<p>例如，库存管理里面有个合理库存的概念，库存量不能太高，也不能太低，它有一个上限和一个下限。但是容易忽视了一个约束条件，就是<strong>库存下限要小于库存上限</strong>。</p>

<pre><code class="language-text">public class SafeWM {
  // 库存上限
  private final AtomicLong upper =
        new AtomicLong(0);
  // 库存下限
  private final AtomicLong lower =
        new AtomicLong(0);
  // 设置库存上限
  void setUpper(long v){
    // 检查参数合法性
    if (v &lt; lower.get()) {
      throw new IllegalArgumentException();
    }
    upper.set(v);
  }
  // 设置库存下限
  void setLower(long v){
    // 检查参数合法性
    if (v &gt; upper.get()) {
      throw new IllegalArgumentException();
    }
    lower.set(v);
  }
  // 省略其他业务代码
}
</code></pre>

<p>当你看到代码里出现 if 语句的时候，就应该立刻意识到可能存在竞态条件，导致并发问题。<br/>
在设计阶段，<strong>我们一定要识别出所有共享变量之间的约束条件，如果约束条件识别不足，很可能导致制定的并发访问策略南辕北辙</strong>。</p>

<h3 id="toc_2">三、制定并发访问策略</h3>

<p>制定并发访问策略，是一个非常复杂的事情。应该说整个专栏都是在尝试搞定它。不过从方案上来看，无外乎就是以下“三件事”。</p>

<ol>
<li>避免共享：避免共享的技术主要是利于线程本地存储以及为每个任务分配独立的线程。</li>
<li>不变模式：这个在 Java 领域应用的很少，但在其他领域却有着广泛的应用，例如 Actor 模式、CSP 模式以及函数式编程的基础都是不变模式。</li>
<li>管程及其他同步工具：Java 领域万能的解决方案是管程，但是对于很多特定场景，使用 Java 并发包提供的读写锁、并发容器等同步工具会更好。</li>
</ol>

<p>除了这些方案之外，还有一些宏观的原则需要你了解。这些宏观原则，有助于你写出“健壮”的并发程序。这些原则主要有以下三条。</p>

<ol>
<li>优先使用成熟的工具类：Java SDK 并发包里提供了丰富的工具类，基本上能满足你日常的需要，建议你熟悉它们，用好它们，而不是自己再“发明轮子”，毕竟并发工具类不是随随便便就能发明成功的。</li>
<li>迫不得已时才使用低级的同步原语：低级的同步原语主要指的是 synchronized、Lock、Semaphore 等，这些虽然感觉简单，但实际上并没那么简单，一定要小心使用。</li>
<li>避免过早优化：安全第一，并发程序首先要保证安全，出现性能瓶颈后再优化。在设计期和开发期，很多人经常会情不自禁地预估性能的瓶颈，并对此实施优化，但残酷的现实却是：性能瓶颈不是你想预估就能预估的。</li>
</ol>

<h3 id="toc_3">课后思考</h3>

<p><strong>本期示例代码中，类 SafeWM 不满足库存下限要小于库存上限这个约束条件，那你来试试修改一下，让它能够在并发条件下满足库存下限要小于库存上限这个约束条件。</strong></p>

<p>答：</p>

<ol>
<li>setUpper() 跟 setLower() 都加上 &quot;synchronized&quot; 关键字。不要太在意性能，老师都说了，避免过早优化。</li>
<li><p>如果性能有问题，可以把 lower 跟 upper 两个变量封装到一个类中，例如</p>
<pre><code class="language-text">public class Boundary {
private final lower;<br/>
private final upper;<br/>
public Boundary(long lower, long upper) {<br/>
    if(lower &gt;= upper) {<br/>
        // throw exception<br/>
    }<br/>
    this.lower = lower;<br/>
    this.upper = upper;<br/>
}<br/>
}
</code></pre>
<p>移除 SafeVM 的 setUpper() 跟 setLower() 方法，并增入 setBoundary(Boundary boundary) 方法。</p></li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755332354058.html">
                
                  <h1>13 | 理论基础模块热点问题答疑</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>起源是一个硬件的核心矛盾：CPU 与内存、I/O 的速度差异，系统软件（操作系统、编译器）在解决这个核心矛盾的同时，引入了可见性、原子性和有序性问题，这三个问题就是很多并发程序的 Bug 之源。这，就是<a href="15755331524883.html">01 | 可见性、原子性和有序性问题：并发编程Bug的源头</a>的内容。</p>

<p>那如何解决这三个问题呢？Java 语言自然有招儿，它提供了 Java 内存模型和互斥锁方案。所以，在<a href="15755331803780.html">02 | Java内存模型：看Java如何解决可见性和有序性问题</a>我们介绍了 Java 内存模型，以应对可见性和有序性问题；那另一个原子性问题该如何解决？多方考量用好互斥锁才是关键，这就是<a href="15755331950338.html">03 | 互斥锁（上）：解决原子性问题</a>和<a href="15755331997391.html">04 | 互斥锁（下）：如何用一把锁保护多个资源？</a>的内容。</p>

<p>虽说互斥锁是解决并发问题的核心工具，但它也可能会带来死锁问题，所以<a href="15755332037088.html">05 | 一不小心就死锁了，怎么办？</a>就介绍了死锁的产生原因以及解决方案；同时还引出一个线程间协作的问题，这也就引出了<a href="15755332090020.html">06 | 用“等待-通知”机制优化循环等待</a>这篇文章的内容，介绍线程间的协作机制：等待 - 通知。</p>

<p>你应该也看出来了，前六篇文章，我们更多地是站在微观的角度看待并发问题。而<a href="15755332130103.html">07 | 安全性、活跃性以及性能问题</a>则是换一个角度，站在宏观的角度重新审视并发编程相关的概念和理论，同时也是对前六篇文章的查漏补缺。</p>

<p><a href="15755332165533.html">08 | 管程：并发编程的万能钥匙</a>介绍的管程，是 Java 并发编程技术的基础，是解决并发问题的万能钥匙。并发编程里两大核心问题——互斥和同步，都是可以由管程来解决的。所以，学好管程，就相当于掌握了一把并发编程的万能钥匙。</p>

<p>至此，并发编程相关的问题，理论上你都应该能找到问题所在，并能给出理论上的解决方案了。</p>

<p>而后在<a href="15755332204025.html">09 | Java线程（上）：Java线程的生命周期</a>、<a href="15755332247193.html">10 | Java线程（中）：创建多少线程才是合适的？</a>和<a href="15755332290388.html">11 | Java线程（下）：为什么局部变量是线程安全的？</a>我们又介绍了线程相关的知识，毕竟 Java 并发编程是要靠多线程来实现的，所以有针对性地学习这部分知识也是很有必要的，包括线程的生命周期、如何计算合适的线程数以及线程内部是如何执行的。</p>

<p>最后，在<a href="15755332325700.html">12 | 如何用面向对象思想写好并发程序？</a>我们还介绍了如何用面向对象思想写好并发程序，因为在 Java 语言里，面向对象思想能够让并发编程变得更简单。</p>

<p><img src="https://wz2img.oss-cn-beijing.aliyuncs.com/mweb/media/15755332354058/15763052938153.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333099520.html">
                
                  <h1>14 | Lock和Condition（上）：隐藏在并发包中的管程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>再造管程的理由</li>
<li>如何保证可见性</li>
<li>什么是可重入锁</li>
<li>公平锁与非公平锁</li>
<li>用锁的最佳实践</li>
</ul>

<p>在并发编程领域，有两大核心问题：</p>

<ol>
<li>一个是<strong>互斥</strong>，即同一时刻只允许一个线程访问共享资源；</li>
<li>另一个是<strong>同步</strong>，即线程之间如何通信、协作。</li>
</ol>

<p>这两大问题，管程都是能够解决的。Java SDK 并发包通过 Lock 和 Condition 两个接口来实现管程，其中<strong>Lock 用于解决互斥问题</strong>，<strong>Condition 用于解决同步问题</strong>。</p>

<h3 id="toc_0">再造管程的理由</h3>

<p>我们前面在介绍<a href="15755332037088.html">05 | 一不小心就死锁了，怎么办？</a>的时候，提出了一个<strong>破坏不可抢占条件</strong>方案，但是这个方案 synchronized 没有办法解决。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，也释放不了线程已经占有的资源。</p>

<p>如果我们重新设计一把互斥锁去解决这个问题，那该怎么设计呢？我觉得有三种方案。</p>

<ol>
<li><strong>能够响应中断</strong>。synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。这样就破坏了不可抢占条件了。</li>
<li><strong>支持超时</strong>。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</li>
<li><strong>非阻塞地获取锁</strong>。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</li>
</ol>

<p>体现在 API 上，就是 Lock 接口的三个方法：</p>

<pre><code class="language-text">// 支持中断的API
void lockInterruptibly() 
  throws InterruptedException;
// 支持超时的API
boolean tryLock(long time, TimeUnit unit) 
  throws InterruptedException;
// 支持非阻塞获取锁的API
boolean tryLock();
</code></pre>

<h3 id="toc_1">如何保证可见性</h3>

<p>那 Java SDK 里面 Lock 靠什么保证可见性呢？例如在下面的代码中，线程 T1 对 value 进行了 +=1 操作，那后续的线程 T2 能够看到 value 的正确结果吗？</p>

<pre><code class="language-text">class X {
  private final Lock rtl =
  new ReentrantLock();
  int value;
  public void addOne() {
    // 获取锁
    rtl.lock();  
    try {
      value+=1;
    } finally {
      // 保证锁能释放
      rtl.unlock();
    }
  }
}
</code></pre>

<p><strong>Java SDK 里面锁，是利用了 volatile 相关的 Happens-Before 规则。</strong>Java SDK 里面的 ReentrantLock，内部持有一个 volatile 的成员变量 state，获取锁的时候，会读写 state 的值；解锁的时候，也会读写 state 的值。根据相关的 Happens-Before 规则：</p>

<ol>
<li><strong>顺序性规则</strong>：对于线程 T1，value+=1 Happens-Before 释放锁的操作 unlock()；</li>
<li><strong>volatile 变量规则</strong>：由于 state = 1 会先读取 state，所以线程 T1 的 unlock() 操作 Happens-Before 线程 T2 的 lock() 操作；</li>
<li><strong>传递性规则</strong>：线程 T1 的 value+=1 Happens-Before 线程 T2 的 lock() 操作。</li>
</ol>

<p>所以说，后续线程 T2 能够看到 value 的正确结果。<a href="15755331803780.html">02 | Java内存模型：看Java如何解决可见性和有序性问题</a></p>

<h3 id="toc_2">什么是可重入锁</h3>

<p><strong>ReentrantLock，可重入锁，指的是线程可以重复获取同一把锁。</strong>如果锁是可重入的，那么线程 可以再次加锁成功；如果锁是不可重入的，那么线程会被阻塞。</p>

<p><strong>可重入函数，指的是多个线程可以同时调用该函数，</strong>每个线程都能得到正确结果；同时在一个线程内支持线程切换，无论被切换多少次，结果都是正确的。即线程安全。</p>

<h3 id="toc_3">公平锁与非公平锁</h3>

<p>ReentrantLock 这个类有两个构造函数，一个是无参构造函数，一个是传入 fair 参数的构造函数。fair 参数代表的是锁的公平策略，如果传入 true 就表示需要构造一个公平锁，反之则表示要构造一个非公平锁。</p>

<pre><code class="language-text">//无参构造函数：默认非公平锁
public ReentrantLock() {
    sync = new NonfairSync();
}
//根据公平策略参数创建锁
public ReentrantLock(boolean fair){
    sync = fair ? new FairSync() 
                : new NonfairSync();
}
</code></pre>

<p>在前面<a href="15755332165533.html">08 | 管程：并发编程的万能钥匙</a>中，我们介绍过入口等待队列，锁都对应着一个等待队列，如果一个线程没有获得锁，就会进入等待队列，当有线程释放锁的时候，就需要从等待队列中唤醒一个等待的线程。如果是公平锁，唤醒的策略就是<mark>谁等待的时间长</mark>，就<mark>唤醒谁</mark>，很公平；如果是非公平锁，则不提供这个公平保证，<mark>有可能等待时间短的线程反而先被唤醒</mark>。</p>

<h3 id="toc_4">用锁的最佳实践</h3>

<p>《Java 并发编程：设计原则与模式》一书中，推荐的三个用锁的最佳实践，它们分别是：</p>

<ol>
<li>永远只在更新对象的成员变量时加锁</li>
<li>永远只在访问可变的成员变量时加锁</li>
<li>永远不在调用其他对象的方法时加锁</li>
</ol>

<h3 id="toc_5">总结</h3>

<p>Java SDK 并发包里的 Lock 接口里面的每个方法，你可以感受到，都是经过深思熟虑的。除了支持类似 synchronized 隐式加锁的 lock() 方法外，还支持超时、非阻塞、可中断的方式获取锁，这三种方式为我们编写更加安全、健壮的并发程序提供了很大的便利。希望你以后在使用锁的时候，一定要仔细斟酌。</p>

<p>除了并发大师 Doug Lea 推荐的三个最佳实践外，你也可以参考一些诸如：减少锁的持有时间、减小锁的粒度等业界广为人知的规则，其实本质上它们都是相通的，不过是在该加锁的地方加锁而已。你可以自己体会，自己总结，最终总结出自己的一套最佳实践来。</p>

<h3 id="toc_6">课后思考</h3>

<p><strong>你已经知道 tryLock() 支持非阻塞方式获取锁，下面这段关于转账的程序就使用到了 tryLock()，你来看看，它是否存在死锁问题呢？</strong></p>

<pre><code class="language-text">class Account {
  private int balance;
  private final Lock lock
          = new ReentrantLock();
  // 转账
  void transfer(Account tar, int amt){
    while (true) {
      if(this.lock.tryLock()) {
        try {
          if (tar.lock.tryLock()) {
            try {
              this.balance -= amt;
              tar.balance += amt;
            } finally {
              tar.lock.unlock();
            }
          }//if
        } finally {
          this.lock.unlock();
        }
      }//if
    }//while
  }//transfer
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333158925.html">
                
                  <h1>15 | Lock和Condition（下）：Dubbo如何用管程实现异步转同步？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>同步与异步</li>
<li>Dubbo 源码分析</li>
</ul>

<p><strong>Condition 实现了管程模型里面的条件变量。</strong></p>

<p>Java 语言内置的管程里只有一个条件变量，而 Lock&amp;Condition 实现的管程是支持多个条件变量的。</p>

<p><strong>那如何利用两个条件变量快速实现阻塞队列呢？</strong></p>

<p>一个阻塞队列，需要两个条件变量，一个是队列不空（空队列不允许出队），另一个是队列不满（队列已满不允许入队），这个例子我们前面在介绍管程的时候详细说过。</p>

<p>Lock 和 Condition 实现的管程，线程等待和通知需要调用 <strong>await()、signal()、signalAll()</strong>，它们的语义和 wait()、notify()、notifyAll() 是相同的。</p>

<pre><code class="language-text">public class BlockedQueue&lt;T&gt;{
  final Lock lock =
    new ReentrantLock();
  // 条件变量：队列不满  
  final Condition notFull =
    lock.newCondition();
  // 条件变量：队列不空  
  final Condition notEmpty =
    lock.newCondition();

  // 入队
  void enq(T x) {
    lock.lock();
    try {
      while (队列已满){
        // 等待队列不满
        notFull.await();
      }  
      // 省略入队操作...
      //入队后,通知可出队
      notEmpty.signal();
    }finally {
      lock.unlock();
    }
  }
  // 出队
  void deq(){
    lock.lock();
    try {
      while (队列已空){
        // 等待队列不空
        notEmpty.await();
      }  
      // 省略出队操作...
      //出队后，通知可入队
      notFull.signal();
    }finally {
      lock.unlock();
    }  
  }
}
</code></pre>

<h3 id="toc_0">同步与异步</h3>

<p><strong>同步与异步的区别？</strong><br/>
调用方是否需要等待结果，如果需要等待结果，就是同步；如果不需要等待结果，就是异步。</p>

<p>同步，是 Java 代码默认的处理方式。如果你想让你的程序支持异步，可以通过下面两种方式来实现：</p>

<ol>
<li>调用方创建一个子线程，在子线程中执行方法调用，这种调用我们称为异步调用；</li>
<li>方法实现的时候，创建一个新的线程执行主要逻辑，主线程直接 return，这种方法我们一般称为异步方法。</li>
</ol>

<h3 id="toc_1">Dubbo 源码分析</h3>

<p>在 TCP 协议层面，发送完 RPC 请求后，线程是不会等待 RPC 的响应结果的。其实很简单，一定是有人帮你做了异步转同步的事情。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333189660.html">
                
                  <h1>16 | Semaphore：如何快速实现一个限流器？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333216073.html">
                
                  <h1>17 | ReadWriteLock：如何快速实现一个完备的缓存？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333260102.html">
                
                  <h1>18 | StampedLock：有没有比读写锁更快的锁？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333302163.html">
                
                  <h1>19 | CountDownLatch和CyclicBarrier：如何让多线程步调一致？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333333673.html">
                
                  <h1>20 | 并发容器：都有哪些“坑”需要我们填？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333374815.html">
                
                  <h1>21 | 原子类：无锁工具类的典范</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333399864.html">
                
                  <h1>22 | Executor与线程池：如何创建正确的线程池？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333433310.html">
                
                  <h1>23 | Future：如何用多线程实现最优的“烧水泡茶”程序？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333466848.html">
                
                  <h1>24 | CompletableFuture：异步编程没那么难</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333499308.html">
                
                  <h1>25 | CompletionService：如何批量执行异步任务？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333526903.html">
                
                  <h1>26 | Fork/Join：单机版的MapReduce</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333581715.html">
                
                  <h1>27 | 并发工具类模块热点问题答疑</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333846070.html">
                
                  <h1>28 | Immutability模式：如何利用不变性解决并发问题？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333902715.html">
                
                  <h1>29 | Copy-on-Write模式：不是延时策略的COW</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333930563.html">
                
                  <h1>30 | 线程本地存储模式：没有共享，就没有伤害</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333956376.html">
                
                  <h1>31 | Guarded Suspension模式：等待唤醒机制的规范实现</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755333985679.html">
                
                  <h1>32 | Balking模式：再谈线程安全的单例模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755334012491.html">
                
                  <h1>33 | Thread-Per-Message模式：最简单实用的分工方法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755334041078.html">
                
                  <h1>34 | Worker Thread模式：如何避免重复创建线程？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755334067669.html">
                
                  <h1>35 | 两阶段终止模式：如何优雅地终止线程？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755334100033.html">
                
                  <h1>36 | 生产者-消费者模式：用流水线思想提高效率</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755334129909.html">
                
                  <h1>37 | 设计模式模块热点问题答疑</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html'>极客-Java并发实战</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html"><strong>Android开发艺术探索</strong></a>
        
            <a href="Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html"><strong>Android进阶之光</strong></a>
        
            <a href="Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html"><strong>Android进阶解密</strong></a>
        
            <a href="Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html"><strong>Java核心技术</strong></a>
        
            <a href="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA.html"><strong>深入理解虚拟机</strong></a>
        
            <a href="%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html"><strong>极客-Java并发实战</strong></a>
        
            <a href="%E6%9E%81%E5%AE%A2-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html"><strong>极客-深入拆解Java虚拟机</strong></a>
        
            <a href="%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html"><strong>极客-数据结构与算法之美</strong></a>
        
            <a href="%E8%8F%9C%E9%B8%9F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>菜鸟-设计模式</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15789721660565.html">0 Android开发艺术探索-目录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15789731325545.html">0 Android进阶之光-目录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15789733843338.html">0 Android进阶解密-目录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15790568493890.html">0 Java核心技术-目录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15749250659113.html">0 深入理解Java虚拟机-目录</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
