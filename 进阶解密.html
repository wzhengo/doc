<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  进阶解密 - 
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html">开发艺术探索</a></li>
        
            <li><a href="%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html">进阶之光</a></li>
        
            <li><a href="%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html">进阶解密</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15789733843338.html">
                
                  <h1>0 Android进阶解密-目录</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>01 Android系统架构<br/>
<a href="15537009005767.html">02 Android系统启动</a><br/>
<a href="15537009111256.html">03 应用程序进程启动过程</a><br/>
<a href="15537009244450.html">04 四大组件的工作过程</a><br/>
<a href="15537009340660.html">05 理解上下文Context</a><br/>
<a href="15537009469734.html">06 理解ActivityManagerService</a><br/>
<a href="15537009631998.html">07 理解WindowManager</a><br/>
<a href="15537009745315.html">08 理解WindowManagerService</a><br/>
09 JNI原理<br/>
<a href="15537010008552.html">10 Java虚拟机</a><br/>
<a href="15537010053206.html">11 Dalvik和ART</a><br/>
<a href="15537010145803.html">12 理解ClassLoader</a><br/>
<a href="15537010271155.html">13 热修复原理</a><br/>
<a href="15537010310819.html">14 Hook技术</a><br/>
<a href="15537010351262.html">15 插件化技术</a><br/>
<a href="15537010402151.html">16 绘制优化</a><br/>
<a href="15537010506228.html">17 内存优化</a></p>

<p><a href="media/15789733843338/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.xmind">Android进阶解密.xmind</a></p>

<p><img src="media/15789733843338/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.png" alt="Android进阶解密"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537008898716.html">
                
                  <h1>01 Android系统架构</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">1.1 Android系统架构</h2>

<h2 id="toc_1">1.2 Android系统源码目录</h2>

<h3 id="toc_2">1.2.1 整体结构</h3>

<h3 id="toc_3">1.2.2 应用层部分</h3>

<h3 id="toc_4">1.2.3 应用框架层部分</h3>

<h3 id="toc_5">1.2.4 C/C++程序库部分</h3>

<h2 id="toc_6">1.3 源码阅读</h2>

<h3 id="toc_7">1.3.1 在线阅读</h3>

<h3 id="toc_8">1.3.2 使用Source Insight</h3>

<h2 id="toc_9">1.4 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009005767.html">
                
                  <h1>02 Android系统启动</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">2.1 init进程启动过程</h2>

<h3 id="toc_1">2.1.1 引入init进程</h3>

<p>Android系统启动流程的前几步：</p>

<ol>
<li>启动电源以及系统启动</li>
<li>引导程序Bootloader</li>
<li>linux内核启动</li>
<li>init进程启动</li>
</ol>

<h3 id="toc_2">2.1.2 init进程的入口函数</h3>

<h3 id="toc_3">2.1.3 解析init.rc</h3>

<h3 id="toc_4">2.1.4 解析Service类型语句</h3>

<h3 id="toc_5">2.1.5 init启动Zygote</h3>

<h3 id="toc_6">2.1.6 属性服务</h3>

<h3 id="toc_7">2.1.7 init进程启动总结</h3>

<p>init进程主要做了三件事：</p>

<ol>
<li>创建一些文件夹并挂载设备</li>
<li>初始化和启动属性服务</li>
<li>解析init.rc配置文件并启动zygote进程</li>
</ol>

<h2 id="toc_8">2.2 Zygote进程启动过程</h2>

<h3 id="toc_9">2.2.1 Zygote概述</h3>

<p>在Android系统中，DVM(Dalvik虚拟机)、应用程序进程以及运行系统的关键服务的SystemServer进程都是由Zygote进程来创建的，我们也将它称为孵化器。它通过fock(复制进程)的形式来创建应用程序进程和SystemServer进程，由于Zygote进程在启动时会创建DVM，因此通过fock而创建的应用程序进程和SystemServer进程可以在内部获取一个DVM的实例拷贝。</p>

<h3 id="toc_10">2.2.2 Zygote启动脚本</h3>

<h3 id="toc_11">2.2.3 Zygote进程启动过程介绍</h3>

<p><img src="media/15537009005767/15766612281852.jpg" alt="" style="width:660px;"/></p>

<h3 id="toc_12">2.2.4 Zygote进程启动总结</h3>

<p>Zygote进程共做了如下几件事：</p>

<ol>
<li>创建AppRuntime并调用其start方法，启动Zygote进程。</li>
<li>创建JVM并为JVM注册JNI方法。</li>
<li>通过JNI调用ZygoteInit的main函数进入Zygote的Java框架层。</li>
<li>通过registerZygoteSocket函数创建服务端Socket，并通过runSelectLoop函数等待ActivityManagerService的请求来创建新的应用程序进程。</li>
<li>启动SystemServer进程。</li>
</ol>

<h2 id="toc_13">2.3 SystemServer处理过程</h2>

<h3 id="toc_14">2.3.1 Zygote处理SystemServer进程</h3>

<p><img src="media/15537009005767/15766611480971.jpg" alt="" style="width:785px;"/></p>

<h3 id="toc_15">2.3.2 解析SystemServer进程</h3>

<h3 id="toc_16">2.3.3 SystemServer进程总结</h3>

<p>SystemServer进程被创建后，主要做了如下工作:</p>

<ol>
<li>启动Binder线程池，这样就可以与其他进程进行通信。</li>
<li>创建SystemServiceManager,其用于对系统的服务进行创建、启动和生命周期管理。</li>
<li>启动各种系统服务。</li>
</ol>

<h2 id="toc_17">2.4 Launcher启动过程</h2>

<h3 id="toc_18">2.4.1 Launcher概述</h3>

<p>系统启动的最后一步是启动一个应用程序用来显示系统中已经安装的应用程序，这个应用程序就叫作Launcher。Launcher在启动过程中会请求PackageManagerService返回系统中已经安装的应用程序的信息，并将这些信息封装成一一个快捷图标列表显示在系统屏幕上，这样用户可以通过点击这些快捷图标来启动相应的应用程序。<br/>
通俗来讲Launcher就是Android系统的桌面，它的作用主要有以下两点:</p>

<ol>
<li>作为Android系统的启动器，用于启动应用程序。</li>
<li>作为Android系统的桌面，用于显示和管理应用程序的快捷图标或者其他桌面组件。</li>
</ol>

<h3 id="toc_19">2.4.2 Launcher启动过程介绍</h3>

<p><img src="media/15537009005767/15766631518684.jpg" alt="" style="width:813px;"/></p>

<h3 id="toc_20">2.4.3 Launcher中应用图标显示过程</h3>

<h2 id="toc_21">2.5 Android系统启动流程</h2>

<ol>
<li>启动电源以及系统启动<br/>
当电源按下时引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序Bootloader到RAM，然后执行。</li>
<li>引导程序BootLoader<br/>
引导程序BootLoader是在Android操作系统开始运行前的一个小程序，它的主要作用是把系统OS拉起来并运行。</li>
<li>Linux内核启动<br/>
内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当内核完成系统设置，它首先在系统文件中寻找init.rc文件，并启动init进程。</li>
<li>init进程启动<br/>
初始化和启动属性服务，并且启动Zygote进程。</li>
<li>Zygote进程启动<br/>
创建JavaVM并为JavaVM注册JNI，创建服务端Socket，启动SystemServer进程。</li>
<li>SystemServer进程启动<br/>
启动Binder线程池和SystemServiceManager，并且启动各种系统服务。</li>
<li>Launcher启动</li>
</ol>

<p><img src="media/15537009005767/15766641511208.jpg" alt="" style="width:480px;"/></p>

<h2 id="toc_22">2.6 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009111256.html">
                
                  <h1>03 应用程序进程启动过程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">3.1 应用程序进程简介</h2>

<p>要想启动一个应用程序，首先要保证这个应用程序所需要的应用程序进程已经启动。AMS在启动应用程序时会检查这个应用程序需要的应用程序进程是否存在，不存在就会请求Zygote进程启动需要的应用程序进程。在2.2节中，我们知道在Zygote的Java框架层中会创建一个Server端的Socket,这个Socket用来等待AMS请求Zygote来创建新的应用程序进程。Zygote进程通过fock自身创建应用程序进程，这样应用程序进程就会获得Zygote进程在启动时创建的虚拟机实例。当然，在应用程序进程创建过程中除了获取虚拟机实例外，还创建了Binder 线程池和消息循环，这样运行在应用进程中的应用程序就可以方便地使用Binder进行进程间通信以及处理消息了。</p>

<h2 id="toc_1">3.2 应用程序<mark>进程</mark>启动过程介绍</h2>

<h3 id="toc_2">3.2.1 AMS发送启动应用程序进程请求</h3>

<p><img src="media/15537009111256/15768257270184.jpg" alt="" style="width:750px;"/></p>

<h3 id="toc_3">3.2.2 Zygote接收请求并创建应用程序进程</h3>

<p><img src="media/15537009111256/15768260299978.jpg" alt="" style="width:791px;"/></p>

<h2 id="toc_4">3.3 Binder线程池启动过程</h2>

<h2 id="toc_5">3.4 消息循环创建过程</h2>

<h2 id="toc_6">3.5 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009244450.html">
                
                  <h1>04 四大组件的工作过程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">4.1 根Activity的启动过程</h2>

<ol>
<li>Launcher请求AMS过程</li>
<li>AMS到ApplicationThread的调用过程</li>
<li>ActivityThread启动Activity的过程</li>
</ol>

<h3 id="toc_1">4.1.1 Launcher请求AMS过程</h3>

<p><img src="media/15537009244450/15768281426977.jpg" alt="" style="width:889px;"/></p>

<h3 id="toc_2">4.1.2 AMS到ApplicationThread的调用过程</h3>

<p><img src="media/15537009244450/15768281976932.jpg" alt="" style="width:849px;"/></p>

<h3 id="toc_3">4.1.3 ActivityThread启动Activity的过程</h3>

<p><img src="media/15537009244450/15768288851079.jpg" alt="" style="width:920px;"/></p>

<h3 id="toc_4">4.1.4 根Activity启动过程中涉及的进程</h3>

<p><img src="media/15537009244450/15768289325581.jpg" alt="" style="width:598px;"/></p>

<p><img src="media/15537009244450/15768289840295.jpg" alt="" style="width:787px;"/></p>

<h2 id="toc_5">4.2 Service的启动过程</h2>

<ol>
<li>ContextImpl到AMS的调用过程</li>
<li>ActivityThread启动Service</li>
</ol>

<h3 id="toc_6">4.2.1 ContextImpl到AMS的调用过程</h3>

<p><img src="media/15537009244450/15768290386139.jpg" alt="" style="width:801px;"/></p>

<h3 id="toc_7">4.2.2 ActivityThread启动Service</h3>

<p><img src="media/15537009244450/15768291077812.jpg" alt="" style="width:933px;"/></p>

<h2 id="toc_8">4.3 Service的绑定过程</h2>

<ol>
<li>ContextImpl到AMS的调用过程</li>
<li>Service的绑定过程</li>
</ol>

<h3 id="toc_9">4.3.1 ContextImpl到AMS的调用过程</h3>

<p><img src="media/15537009244450/15768291875167.jpg" alt="" style="width:783px;"/></p>

<h3 id="toc_10">4.3.2 Service的绑定过程</h3>

<p><img src="media/15537009244450/15768292334460.jpg" alt="" style="width:810px;"/></p>

<p><img src="media/15537009244450/15768292543038.jpg" alt="" style="width:938px;"/></p>

<h2 id="toc_11">4.4 广播的注册、发送和接收过程</h2>

<h3 id="toc_12">4.4.1 广播的注册过程</h3>

<p><img src="media/15537009244450/15768292786702.jpg" alt="" style="width:806px;"/></p>

<h3 id="toc_13">4.4.2 广播的发送和接收过程</h3>

<ol>
<li>ContextImpl到AMS的调用过程</li>
<li>AMS到BroadcastReceiver的调用过程。</li>
</ol>

<p><img src="media/15537009244450/15768293074798.jpg" alt="" style="width:831px;"/></p>

<p><img src="media/15537009244450/15768294354518.jpg" alt="" style="width:967px;"/></p>

<h2 id="toc_14">4.5 Content Provider的启动过程</h2>

<ol>
<li>query方法到AMS的调用过程</li>
<li>AMS启动Content Provider的过程</li>
</ol>

<h3 id="toc_15">4.5.1 query方法到AMS的调用过程</h3>

<p><img src="media/15537009244450/15768294724962.jpg" alt="" style="width:817px;"/></p>

<h3 id="toc_16">4.5.2 AMS启动Content Provider的过程</h3>

<p><img src="media/15537009244450/15768295158004.jpg" alt="" style="width:911px;"/></p>

<h2 id="toc_17">4.6 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009340660.html">
                
                  <h1>05 理解上下文Context</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">5.1 Context的关联类</h2>

<p><img src="media/15537009340660/15768297234805.jpg" alt="" style="width:646px;"/></p>

<p>从图中我们可以看出，ContextImpl和ContextWrapper继承自Context，ContextWrapper内部包含有Context类型的mBase对象，mBase具体指向的是ContextImpl。ContextImpl提供了很多功能，但是外界需要使用并拓展ContextImpl的功能，因此设计上使用了装饰模式，ContextWrapper是装饰类，它对ContextImpl进行包装，ContextWrapper主要是起了方法传递作用，ContextWrapper中几乎所有的方法实现都是调用ContextImpl的相应方法来实现的。ContextThemeWrapper、Service和Application都继承自ContextWrapper，这样他们都可以通过mBase来使用Context的方法，同时它们也是装饰类，在ContextWrapper的基础上又添加了不同的功能。ContextThemeWrapper中包含和主题相关的方法（比如： getTheme方法），因此，需要主题的Activity继承ContextThemeWrapper，而不需要主题的Service则继承ContextWrapper。</p>

<p>Context的关联类采用了装饰模式，主要有以下的优点:</p>

<ul>
<li>使用者(比如Service) 能够更方便地使用Context。</li>
<li>如果ContextImpl发生了变化，它的装饰类ContextWrapper不需要做任何修改。</li>
<li>ContextImpl 的实现不会暴露给使用者，使用者也不必关心ContextImpl的实现。●通过组合而非继承的方式，拓展ContextImpl的功能，在运行时选择不同的装饰类，实现不同的功能。</li>
</ul>

<h3 id="toc_1">5.2 Application Context的创建过程</h3>

<p><img src="media/15537009340660/15768303177957.jpg" alt="" style="width:854px;"/></p>

<h3 id="toc_2">5.3 Application Context的获取过程</h3>

<h3 id="toc_3">5.4 Activity的Context创建过程</h3>

<p><img src="media/15537009340660/15768306549478.jpg" alt="" style="width:959px;"/></p>

<h3 id="toc_4">5.5 Service的Context创建过程</h3>

<h2 id="toc_5">5.6 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009469734.html">
                
                  <h1>06 理解ActivityManagerService</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">6.1 AMS家族</h2>

<h3 id="toc_1">6.1.1 Android 7.0的AMS家族</h3>

<p><img src="media/15537009469734/15768310861282.jpg" alt="" style="width:788px;"/></p>

<p><img src="media/15537009469734/15768311034814.jpg" alt="" style="width:790px;"/></p>

<h3 id="toc_2">6.1.2 Android 8.0的AMS家族</h3>

<p><img src="media/15537009469734/15768311293526.jpg" alt="" style="width:730px;"/></p>

<h2 id="toc_3">6.2 AMS的启动过程</h2>

<h2 id="toc_4">6.3 AMS与应用程序进程</h2>

<p>AMS与应用程序进程的关系主要有以下两点:</p>

<ul>
<li>启动应用程序时AMS会检查这个应用程序需要的应用程序进程是否存在。</li>
<li>如果需要的应用程序进程不存在，AMS就会请求Zygote进程创建需要的应用程序进程。</li>
</ul>

<h2 id="toc_5">6.4 AMS重要的数据结构</h2>

<h3 id="toc_6">6.4.1 解析ActivityRecord</h3>

<p>ActivityRecord内部记录了Activity 的所有信息，因此它用来描述一个Activity， 它是在启动Activity 时被创建的，具体是在ActivityStarter 的startActivity方法中被创建的，具体可以查看4.1.2节。ActivityRecord 的部分重要成员变量如表6一1所示。</p>

<p><img src="media/15537009469734/15768331492510.jpg" alt="" style="width:883px;"/></p>

<p>从表中可以看出ActivityRecord的作用，其内部存储了Activity 的所有信息，包括AMS的引用、AndroidManifest 节点信息、Activity 状态、Activity 资源信息和Activity 进程相关信息等，需要注意的是其中含有该ActivityRecord 所在的TaskRecord， 这就将ActivityRecord和TaskRecord关联在一起，它们是Activity 任务栈模型的重要成员，我们接着来查看TaskRecord。</p>

<h3 id="toc_7">6.4.2 解析TaskRecord</h3>

<p>从表中可以发现TaskRecord的作用，其内部存储了任务栈的所有信息，包括任务栈的唯一标识符、任务栈的倾向性、任务栈中的Activity记录和AMS的引用等，需要注意的是其中含有ActivityStack,也就是当前Activity 任务栈所归属的ActivityStack,我们接着来查看ActivityStack。</p>

<p><img src="media/15537009469734/15768333354799.jpg" alt="" style="width:876px;"/><br/>
<img src="media/15537009469734/15768333476066.jpg" alt="" style="width:859px;"/></p>

<h3 id="toc_8">6.4.3 解析ActivityStack</h3>

<p>ActivityStack是一个管理类，用来管理系统所有Activity的各种状态，其内部维护了TaskRecord的列表，因此从Activity任务栈这一角度来说，ActivityStack也可以理解为Activity堆栈。它由ActivityStackSupervisor来进行管理的，而ActivityStackSupervisor在AMS中的构造方法中被创建。</p>

<p><strong>ActivityStack的实例类型</strong></p>

<pre><code class="language-text">```
public final class ActivityStackSupervisor implements DisplayListener {
   ...
    //用来存储Launcher App的所有Activity
    ActivityStack mHomeStack;

    //表示当前正在接收输入或启动下一个Activity的所有Activity
    ActivityStack mFocusedStack; 

    //表示此前接收输入的所有Activity。
    private ActivityStack mLastFocusedStack;
    ...
}
```
</code></pre>

<p><strong>ActivityState</strong></p>

<ul>
<li><p>ActivityStack中通过枚举存储了Activity的所有的状态：</p>
<pre><code class="language-text">enum ActivityState {
       INITIALIZING,<br/>
       RESUMED,<br/>
       PAUSING,<br/>
       PAUSED,<br/>
       STOPPING,<br/>
       STOPPED,<br/>
       FINISHING,<br/>
       DESTROYING,<br/>
       DESTROYED<br/>
}
</code></pre></li>
</ul>

<p><strong>特殊状态的Activity</strong></p>

<ul>
<li><p>这些特殊的状态都是ActivityRecord类型的，ActivityRecord用来记录一个Activity的所有信息。</p>
<pre><code class="language-text">ActivityRecord mPausingActivity = null;//正在暂停的Activity
ActivityRecord mLastPausedActivity = null;//上一个已经暂停的Activity<br/>
ActivityRecord mLastNoHistoryActivity = null;//最近一次没有历史记录的Activity<br/>
ActivityRecord mResumedActivity = null;//已经Resume的Activity<br/>
ActivityRecord mLastStartedActivity = null;//最近一次启动的Activity<br/>
ActivityRecord mTranslucentActivityWaiting = null;//传递给convertToTranslucent方法的最上层的Activity
</code></pre></li>
</ul>

<p><strong>维护的ArrayList</strong></p>

<ul>
<li>ActivityStack中维护了很多ArrayList，这些ArrayList中的元素类型主要有ActivityRecord和TaskRecord，其中TaskRecord用来记录Activity的Task。</li>
</ul>

<p><img src="media/15537009469734/15768324062971.jpg" alt="" style="width:716px;"/></p>

<h2 id="toc_9">6.5 Activity栈管理</h2>

<p>Activity栈：存储和管理Activity。</p>

<h3 id="toc_10">6.5.1 Activity任务栈模型</h3>

<p><img src="media/15537009469734/15770729871003.jpg" alt="" style="width:335px;"/></p>

<ul>
<li>ActivityRecord用来记录一个Activity 的所有信息</li>
<li>TaskRecord 中包含了一个或多个ActivityRecord, TaskRecord 用来表示Activity 的任务栈，用来管理栈中的ActivityRecord</li>
<li>ActivityStack又包含了一个或多个TaskRecord,它是TaskRecord的管理者。Activity 栈管理就是建立在Activity 任务栈模型之上的</li>
</ul>

<p>有了栈管理，我们可以对应用程序进行操作，应用可以复用自身应用中以及其他应用的Activity, 节省了资源。</p>

<h3 id="toc_11">6.5.2 Launch Mode</h3>

<ul>
<li>standerd：默认模式，每次启动Activity都会创建一个新的Activity实例。</li>
<li>singleTop：如果要启动的Activity已经在栈顶，则不会重新创建Activity，同时该Activity的onNewIntent方法会被调用。如果要启动的Activity不在栈顶，则会重新创建该Activity的实例。</li>
<li>singleTask：如果要启动的Activity已经存在于它想要归属的栈中，那么不会创建该Activity实例，将栈中位于该Activity上的所有的Activity出栈，同时该Activity的onNewIntent方法会被调用。如果要启动的Activity不存在于它想要归属的栈中，并且该栈存在，则会重新创建该Activity的实例。如果要启动的Activity想要归属的栈不存在，则首先要创建一个新栈，然后创建该Activity实例并压入到新栈中。</li>
<li>singleInstance：和singleTask基本类似，不同的是启动Activity时，首先要创建在一个新栈，然后创建该Activity实例并压入新栈中，新栈中只会存在这一个Activity实例。</li>
</ul>

<h3 id="toc_12">6.5.3 Intent的FLAG</h3>

<ul>
<li>FLAG_ACTIVITY_NO_HISTORY：Activity一旦退出，就不会存在于栈中。同样的，也可以在AndroidManifest.xml中设置“android:noHistory”。</li>
<li>FLAG_ACTIVITY_MULTIPLE_TASK：需要和FLAG_ACTIVITY_NEW_TASK一同使用才有效果，系统会启动一个新的栈来容纳新启动的Activity.</li>
<li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：Activity不会被放入到“最近启动的Activity”列表中。</li>
<li>FLAG_ACTIVITY_BROUGHT_TO_FRONT：这个标志位通常不是由应用程序中的代码设置的，而是Launch Mode为singleTask时，由系统自动加上的。</li>
<li>FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY：这个标志位通常不是由应用程序中的代码设置的，而是从历史记录中启动的（长按Home键调出）。</li>
<li>FLAG_ACTIVITY_CLEAR_TASK：需要和FLAG_ACTIVITY_NEW_TASK一同使用才有效果，用于清除与启动的Activity相关栈的所有其他Activity。</li>
</ul>

<h3 id="toc_13">6.5.4 taskAffinity</h3>

<p>我们可以在AndroidManifest.xml设置android:taskAffinity，用来指定Activity希望归属的栈， 默认情况下，同一个应用程序的所有的Activity都有着相同的taskAffinity。taskAffinity在下面两种情况时会产生效果：</p>

<ul>
<li>askAffinity与FLAG_ACTIVITY_NEW_TASK或者singleTask配合。如果新启动Activity的taskAffinity和栈的taskAffinity相同（栈的taskAffinity取决于根Activity的taskAffinity）则加入到该栈中。如果不同，就会创建新栈。</li>
<li>taskAffinity与allowTaskReparenting配合。如果allowTaskReparenting为true，说明Activity具有转移的能力。</li>
</ul>

<p><img src="media/15537009469734/15770737826060.jpg" alt="" style="width:567px;"/></p>

<h2 id="toc_14">6.6 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009631998.html">
                
                  <h1>07 理解WindowManager</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">7.1 Window、WindowManager和WMS</h2>

<ul>
<li>Window是一个抽象类，具体的实现类为PhoneWindow,它对View进行管理。</li>
<li>WindowManager 是一个接口类，继承自接口ViewManager，它是用来管理Window的，它的实现类为WindowManagerImpl。如果我们]想要对Window (View)进行添加、更新和删除操作就可以使用WindowManager,。</li>
<li>WindowManager 会将具体的工作交由WMS来处理，WindowManager 和WMS通过Binder来进行跨进程通信，WMS作为系统服务有很多API是不会暴露给WindowManager的，这一点与ActivityManager和AMS的关系有些类似。</li>
</ul>

<p><img src="media/15537009631998/15770744667327.jpg" alt="" style="width:494px;"/></p>

<p>Window包含了View并对View进行管理，Window用虚线来表示是因为Window是一个抽象概念，用来描述一个窗口，并不是真实存在的，Window 的实体其实也是View。WindowManager用来管理Window,而WindowManager所提供的功能最终会由WMS进行处理。</p>

<h2 id="toc_1">7.2 WindowManager的关联类</h2>

<p><img src="media/15537009631998/15770829130238.jpg" alt="" style="width:874px;"/></p>

<h2 id="toc_2">7.3 Window的属性</h2>

<h3 id="toc_3">7.3.1 Window的类型和显示次序</h3>

<p>Window的类型总体来说分为三大类：</p>

<ul>
<li>Application Window（应用程序窗口）</li>
<li>Sub Window（子窗口）</li>
<li>System Window（系统窗口）</li>
</ul>

<p><strong>应用程序窗口</strong></p>

<pre><code class="language-text">public static final int FIRST_APPLICATION_WINDOW = 1;//1
public static final int TYPE_BASE_APPLICATION   = 1;//窗口的基础值，其他的窗口值要大于这个值
public static final int TYPE_APPLICATION        = 2;//普通的应用程序窗口类型
public static final int TYPE_APPLICATION_STARTING = 3;//应用程序启动窗口类型，用于系统在应用程序窗口启动前显示的窗口。
public static final int TYPE_DRAWN_APPLICATION = 4;
public static final int LAST_APPLICATION_WINDOW = 99;//2
</code></pre>

<p>应用程序窗口的Type值范围为1到99。</p>

<p><strong>子窗口</strong></p>

<p>子窗口，不能独立的存在，需要附着在其他窗口才可以，PopupWindow就属于子窗口。子窗口的Type值范围为1000到1999。</p>

<p><strong>系统窗口</strong><br/>
Toast、输入法窗口、系统音量条窗口、系统错误窗口都属于系统窗口。系统窗口的类型定义如下所示：系统窗口的类型值有接近40个，这里只列出了一小部分， 系统窗口的Type值范围为2000到2999。</p>

<p><strong>窗口显示次序</strong></p>

<p>当一个进程向WMS申请一个窗口时，WMS会为窗口确定显示次序。为了方便窗口显示次序的管理，手机屏幕可以虚拟的用X、Y、Z轴来表示，其中Z轴垂直于屏幕，从屏幕内指向屏幕外，这样确定窗口显示次序也就是确定窗口在Z轴上的次序，这个次序称为Z-Oder。Type值是Z-Oder排序的依据，我们知道应用程序窗口的Type值范围为1到99，子窗口1000到1999 ，系统窗口 2000到2999，，一般情况下，Type值越大则Z-Oder排序越靠前，就越靠近用户。</p>

<h3 id="toc_4">7.3.2 Window的标志</h3>

<p>Window的标志也就是Flag，用于控制Window的显示，同样被定义在WindowManager的内部类LayoutParams中。</p>

<p><img src="media/15537009631998/15770840899344.jpg" alt="" style="width:823px;"/></p>

<p>设置Window的Flag有三种方法：</p>

<ul>
<li>第一种是通过Window的addFlags方法；</li>
<li>第二种通过Window的setFlags方法；</li>
<li>第三种则是给LayoutParams设置Flag，并通过WindowManager的addView方法进行添加。</li>
</ul>

<h3 id="toc_5">7.3.3 软键盘相关模式</h3>

<p>为了使得软键盘窗口能够按照期望来显示，WindowManager的静态内部类LayoutParams中定义了软键盘相关模式：<br/>
<img src="media/15537009631998/15770845654108.jpg" alt="" style="width:879px;"/></p>

<p>设置SoftInputMode：</p>

<ul>
<li>AndroidManifest中Activity的属性android:windowSoftInputMode；</li>
<li>Java代码<code>getWindow().setSoftInputMode</code>。</li>
</ul>

<h2 id="toc_6">7.4 Window的操作</h2>

<p>对于Window的操作，最终都是交由WMS来进行处理。窗口的操作分为两大部分，一部分是WindowManager处理部分，另一部分是WMS处理部分。</p>

<p><img src="media/15537009631998/15771763898405.jpg" alt="" style="width:392px;"/></p>

<h3 id="toc_7">7.4.1 系统窗口的添加过程</h3>

<p><img src="media/15537009631998/15771764592662.jpg" alt="" style="width:869px;"/></p>

<h3 id="toc_8">7.4.2 Activity的添加过程</h3>

<ol>
<li>Activity 在启动过程中，如果Activity所在的进程不存在则会创建新的进程，创建新的进程之后就会运行代表主线程的实例ActivityThread；</li>
<li>当界面要与用户进行交互时，会调用ActivityThread 的handleResumeActivity方法；</li>
<li>performResumeActivity方法最终会调用Activity 的onResume方法；</li>
<li>得到ViewManager类型的对象后，调用了ViewManager 的addView方法，而addView方法则是在WindowManagerImpl中实现的，addView方法的第一个参数为DecorView。</li>
</ol>

<h3 id="toc_9">7.4.3 Window的更新过程</h3>

<p>Window的更新过程和Window的添加过程是类似的。</p>

<ol>
<li>调用ViewManager的updateViewLayout方法，updateViewLayout 方法在WindowManagerImpl 中实现，WindowManagerImpl的updateViewLayout方法会调用WindowManagerGlobal的updateViewI ayout方法</li>
<li>更新的参数设置到View中，得到要更新的窗口在View列表中的索引在ViewRootImpl列表中根据索引得到窗口的ViewRootlmpl，更新布局参数列表，调用ViewRootImpl的setLayoutParams方法将更新的参数设置到ViewRootImpl 中，ViewRootImpl的setLayoutParams 方法在最后会调用ViewRootImpl的scheduleTraversals方法。</li>
<li>在TraversalRunnable的run方法中调用了doTraversal方法，在doTraversal方法中又调用了performTraversals 方法，performTraversals 方法使得ViewTree开始View的工作流程：
<ol>
<li>relayoutWindow方法内部会调用IWindowSession 的relayout方法来更新Window视图，最终会调用WMS的relayoutWindow方法。</li>
<li>performTraversals 方法分别调用performMeasure、performLayout和performDraw方法,它们的内部又会调用View的measure、layout和draw方法，这样就完成了View 的工作流程。</li>
</ol></li>
<li>在performTraversals方法中更新了Window视图，又执行Window中的View的工作流程，这样就完成了Window 的更新。</li>
</ol>

<h2 id="toc_10">7.5 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009745315.html">
                
                  <h1>08 理解WindowManagerService</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">8.1 WMS的职责</h2>

<p><strong>窗口管理</strong><br/>
<strong>窗口动画</strong><br/>
<strong>输入系统的中转站</strong><br/>
<strong>Surface管理</strong></p>

<p><img src="media/15537009745315/15771805499610.jpg" alt="" style="width:846px;"/></p>

<h2 id="toc_1">8.2 WMS的创建过程</h2>

<p><img src="media/15537009745315/15771806852964.jpg" alt="" style="width:550px;"/></p>

<h2 id="toc_2">8.3 WMS的重要成员</h2>

<h2 id="toc_3">8.4 Window的添加过程（WMS处理部分）</h2>

<p>addWindow方法分了3个部分来进行讲解，主要就是做了下面4件事：</p>

<ol>
<li>对所要添加的窗口进行检查，如果窗口不满足一些条件，就不会再执行下面的代码逻辑。</li>
<li>WindowToken相关的处理，比如有的窗口类型需要提供WindowToken，没有提供的话就不会执行下面的代码逻辑，有的窗口类型则需要由WMS隐式创建WindowToken。</li>
<li>WindowState的创建和相关处理，将WindowToken和WindowState相关联。</li>
<li>创建和配置DisplayContent，完成窗口添加到系统前的准备工作。</li>
</ol>

<h2 id="toc_4">8.5 Window的删除过程</h2>

<p>Window的删除过程：</p>

<ol>
<li>检查删除线程的正确性，如果不正确就抛出异常。</li>
<li>从ViewRootImpl列表、布局参数列表和View列表中删除与V对应的元素。</li>
<li>判断是否可以直接执行删除操作，如果不能就推迟删除操作。</li>
<li>执行删除操作，清理和释放与V相关的一切资源。</li>
</ol>

<h2 id="toc_5">8.6 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009893410.html">
                
                  <h1>09 JNI原理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010008552.html">
                
                  <h1>10 Java虚拟机</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">10.1 概述</h3>

<h4 id="toc_1">10.1.1 Java虚拟机家族</h4>

<ol>
<li>HotSpot VM</li>
<li>J9 VM</li>
<li>Zing VM</li>
</ol>

<h4 id="toc_2">10.1.2 Java虚拟机执行流程</h4>

<p><img src="media/15537010008552/15748433740583.jpg" alt="" style="width:524px;"/><br/>
<img src="media/15537010008552/15748433876904.jpg" alt="" style="width:426px;"/></p>

<h3 id="toc_3">10.2 Java虚拟机结构</h3>

<p><img src="media/15537010008552/15748434308127.jpg" alt="" style="width:453px;"/></p>

<h4 id="toc_4">10.2.1 Class文件格式</h4>

<p><img src="media/15537010008552/15748435663601.jpg" alt="" style="width:654px;"/></p>

<h4 id="toc_5">10.2.2 类的生命周期</h4>

<p><strong>类的生命周期：</strong><br/>
一个Java文件，从<code>被加载到Java虚拟机内存中</code>到<code>从内存中卸载</code>的过程。</p>

<ol>
<li>加载：查找并加载Class文件。</li>
<li>链接
<ol>
<li>验证：确保被导入类型的正确性。</li>
<li>准备：为类的静态字段分配字段，并用默认值初始化这些字段。</li>
<li>解析：虚拟机将常量池内的符号引用替换为直接引用。</li>
</ol></li>
<li>初始化：将类变量初始化为正确的初始值。</li>
<li>使用</li>
<li>卸载</li>
</ol>

<p><img src="media/15537010008552/15748439274778.jpg" alt="" style="width:386px;"/></p>

<h4 id="toc_6">10.2.3 类加载子系统</h4>

<p>类加载子系统通过多种类加载器来查找和加载Class文件到Java虚拟机中。Java虚拟机有两种你那个类加载器：系统加载器和自定义加载器。</p>

<p><strong>系统加载器：</strong></p>

<ol>
<li>Bootstrap ClassLoader（引导类加载器）</li>
<li>Extensions ClassLoader（拓展类加载器）</li>
<li>Application ClassLoader（应用程序类加载器）</li>
</ol>

<h4 id="toc_7">10.2.4 运行时数据区域</h4>

<ol>
<li>程序计数器 </li>
<li>Java虚拟机栈</li>
<li>本地方法栈</li>
<li>Java堆</li>
<li>方法区</li>
<li>运行时常量池</li>
<li>直接内存</li>
</ol>

<h3 id="toc_8">10.3 对象的创建</h3>

<ol>
<li>判断对象对应的类是否加载、链接和初始化</li>
<li>为对象分配内存
<ol>
<li>指针碰撞</li>
<li>空闲列表</li>
</ol></li>
<li>处理并发安全问题
<ol>
<li>分配内存进行同步处理</li>
<li>本地线程分配缓冲</li>
</ol></li>
<li>初始化分配到的内存空间</li>
<li>设置对象的对象头</li>
<li>执行init方法进行初始化</li>
</ol>

<h3 id="toc_9">10.4 对象的堆内存布局</h3>

<p>以HotSpot虚拟机为例，对象在堆内存的布局分为三个区域，分别是对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。</p>

<p><img src="media/15537010008552/15748470536456.jpg" alt="" style="width:191px;"/></p>

<h3 id="toc_10">10.5 oop-klass模型</h3>

<p>oop-klass模型模型是用来描述Java对象实例的一种模型，它分为两个部分，OOP（Ordinary  Object Pointer）指普通对象指针，用来表示对象的实例信息。klass用来描述元数据。</p>

<p><img src="media/15537010008552/15748473947755.jpg" alt="" style="width:426px;"/></p>

<h3 id="toc_11">10.6 垃圾标记算法</h3>

<h4 id="toc_12">10.6.1 Java中的引用</h4>

<ol>
<li>强引用：新建对象时引用，不会回收。</li>
<li>软引用：SoftReference，内存不足时回收。</li>
<li>弱引用：WeakReference，GC时回收。</li>
<li>虚引用：PhantomReference，和对象生命周期没有关系；被回收时会收到一个系统通知。</li>
</ol>

<h4 id="toc_13">10.6.2 引用计数算法</h4>

<p>基本思想：背个对象都有一个引用计数器，当对象在某处类引用的时候，它的引用计数器加1，引用失效时减1。当引用计数器中的值为0，则该对象就不能被使用，变成了垃圾。</p>

<p>目前主流Java虚拟机并没有选择使用引用计数算法，因为它没有解决对象之间互相循环引用的问题。</p>

<h4 id="toc_14">10.6.3 根搜索算法</h4>

<p>思想：选定一些对象作为GC Roots，并组成根对象集合，然后以这些GC Roots的对象作为起始点，向下搜索，如果目标对象到GC Roots是连接着的，我们则称为该对象是可达的，如果不可达则说说明目标对象是可以被回收的对象。如图：</p>

<p><img src="media/15537010008552/15748489005643.jpg" alt="" style="width:490px;"/></p>

<p>在Java中，可以作为GC Roots的对象主要有以下几种：</p>

<ul>
<li>Java栈中引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
<li>方法区中运行时常量池引用的对象。</li>
<li>方法区中静态属性引用的对象。</li>
<li>运行中的线程。</li>
<li>由引导类加载器加载的对象。</li>
<li>GC控制的对象。</li>
</ul>

<h3 id="toc_15">10.7 Java对象在虚拟机中的生命周期</h3>

<ol>
<li>创建阶段（Created）
<ol>
<li>为对象分配存储空间</li>
<li>构造对象</li>
<li>从超类到子类对static成员进行初始化</li>
<li>递归调用超类的构造方法</li>
<li>调用子类的构造方法</li>
</ol></li>
<li>应用阶段（In Use）</li>
<li>不可见阶段（Invisible）</li>
<li>不可达阶段（Unreachable）</li>
<li>收集阶段（Collected）</li>
<li>终结阶段（Finalized）</li>
<li>对象空间重新分配阶段（Deallocated）</li>
</ol>

<h3 id="toc_16">10.8 垃圾收集算法</h3>

<h4 id="toc_17">10.8.1 标记—清除算法</h4>

<ul>
<li>标记阶段：标记处可以回收的对象</li>
<li>清除阶段：回收被标记的对象所占的空间。</li>
</ul>

<p><img src="media/15537010008552/15749105545929.jpg" alt="" style="width:435px;"/></p>

<p><strong>缺点：</strong></p>

<ul>
<li>标记和清除的效率不高。</li>
<li>容易产生大量不连续的内存碎片，碎片太多可能导致没有足够的连续内存分配给较大对象，从而触发新的一次垃圾收集动作。</li>
</ul>

<h4 id="toc_18">10.8.2 复制算法</h4>

<p>为了解决标记—清除算法效率不高的问题。</p>

<ol>
<li>它把内存空间划分为两个相等的区域，每次只使用其中一个区域；</li>
<li>在垃圾收集时，遍历当前使用的区域，把存活的对象复制到另一个区域中，最后将当前使用的区域的可回收对象进行回收。</li>
</ol>

<p><img src="media/15537010008552/15749108305016.jpg" alt="" style="width:400px;"/></p>

<ul>
<li>这种算法每次对整个半区进行内存回收，不需要考虑内存碎片问题，代价就是使用内存为原来的一般。</li>
<li>复制算法的效率与存活对象数目有很大关系，如果存活对象很少，复制算法的效率就会很高。所以复制算法广泛应用于新生代中。</li>
</ul>

<h4 id="toc_19">10.8.3 标记-压缩算法</h4>

<p>老年代不适用复制算法，因为老年代对象存活率高，会有很多复制操作，导致效率变低。</p>

<p>标记-压缩算法在标记可回收的对象后，将所有存活的对象压缩到内存的另一端，使他们紧凑地排列在一起，然后对边界以外的内存进行回收。</p>

<p><img src="media/15537010008552/15749117879560.jpg" alt="" style="width:394px;"/></p>

<h4 id="toc_20">10.8.4 分代收集算法</h4>

<p>对不同生命周期的对象采取不同的收集算法，这就是分代的概念。</p>

<ul>
<li>新生代
<ul>
<li>Eden空间</li>
<li>From Survivor空间</li>
<li>To Survivor空间</li>
</ul></li>
<li>老年代</li>
</ul>

<p>Eden空间中大多数对象生命周期很短，Eden空间和两个Survivor空间所占比例为8:1。</p>

<p>根据Java堆区的空间划分，垃圾收集的类型分为两种：</p>

<ul>
<li>Minor Collection：新生代垃圾收集</li>
<li>Full Collection ：老年代收集。又称Major Collection。</li>
</ul>

<p>Full Collection通常情况下伴随至少一次的Minor Collection，收集频率较低，耗时较长。</p>

<p><img src="media/15537010008552/15749127215885.jpg" alt="" style="width:426px;"/></p>

<h3 id="toc_21">10.9 本章小结</h3>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010053206.html">
                
                  <h1>11 Dalvik和ART</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">11.1 Dalvik虚拟机</h2>

<p>Dalvik虚拟机(Dalvik Virtual Machine )，简称Dalvik VM或者DVM。DVM是Google专门为Android平台开发的虚拟机，它运行在Android运行时库中。需要注意的是DVM并不是一个Java 虚拟机(以下简称JVM)。</p>

<h3 id="toc_1">11.1.1 DVM与JVM的区别</h3>

<p>DVM之所以不是一个 JVM,主要原因是DVM并没有遵循JVM规范来实现， DVM与JVM主要有以下区别。</p>

<ol>
<li><p>基于的架构不同<br/>
JVM基于栈则意味着需要去栈中读写数据，所需的指令会更多,这样会导致速度变慢，对于性能有限的移动设备，显然不是很适合的。DVM是基于寄存器的，它没有基于栈的虚拟机在复制数据时而使用的大量的出入栈指令，同时指令更紧凑、更简洁。但是由于显式指定了操作数,所以基于寄存器的指令会比基于栈的指令要大，但是由于指令数量的减少，总的代码数不会增加多少。</p></li>
<li><p>执行的字节码不同<br/>
在Java SE程序中，Java类被编译成一个或多个.class文件，并打包成jar文件，而后JVM会通过相应的.class文件和jar文件获取相应的字节码。执行顺序为.java文件→.class 文件→.jar文件。<br/>
而DVM会用dx工具将所有的.class文件转换为一个.dex文件，然后DVM会从该dex文件读取指令和数据。执行顺序为.java文件→.class文件一→.dex文件。</p>
<p>jar 文件里面包含多个.class文件，每个.class文件里面包含了该类的常量池、类信息、属性等。当JVM加载该jar文件的时候，会加载里面的所有的.class文件，JVM的这种加载方式很慢，对于内存有限的移动设备并不合适。而在.apk文件中只包含了一个.dex文件，这个.dex文件将所有的.class里面所包含的信息全部整合在一起了，这样再加载就加快了速度。.class 文件存在很多的冗余信息，dex 工具会去除冗余信息，并把所有的.class文件整合到.dex文件中，减少了IO操作，加快了类的查找速度。<br/>
<img src="media/15537010053206/15776932722358.jpg" alt="" style="width:590px;"/>   </p></li>
<li><p>DVM允许在有限的内存中同时运行多个进程<br/>
DVM经过优化,允许在有限的内存中同时运行多个进程。在Android中的每一个应用都运行在一个DVM实例中，每一个DVM实例都运行在一个独立的进程空间中，独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。</p></li>
<li><p>DVM由Zygote创建和初始化<br/>
我们在第2章学习过Zygote，它是一个DVM进程，同时也用来创建和初始化DVM实例。每当系统需要创建一个应用程序时 ，Zygote 就会fock 自身，快速地创建和初始化一个DVM实例，用于应用程序的运行。对于一些只读的系统库，所有的DVM实例都会和Zygote共享一块内存区域，节省了内存开销。</p></li>
<li><p>DVM有共享机制.<br/>
DVM拥有预加载一共 享的机制，不同应用之间在运行时可以共享相同的类，拥有更  高的效率。而JVM机制不存在这种共享机制，不同的程序,打包以后的程序都是彼此独立的,即便它们在包里使用了同样的类，运行时也都是单独加载和运行的，无法进行共享。</p></li>
<li><p>DVM早期没有使用JIT编译器<br/>
JVM使用了JIT编译器(Just In Time Compiler,即时编译器)，而DVM早期没有使用JIT编译器。早期的DVM每次执行代码，都需要通过解释器将dex代码编译成机器码，然后交给系统处理，效率不是很高。为了解决这一问题，从Android 2.2版本开始DVM使用了JIT 编译器，它会对多次运行的代码(热点代码)进行编译，生成相当精简的本地机器码(Native Code)，这样在下次执行到相同逻辑的时候，直接使用编译之后的本地机器码，而不是每次都需要编译。需要注意的是，应用程序每一次重新运行的时候，都要重做这个编译工作，因此每次重新打开应用程序，都需要JIT编译。</p></li>
</ol>

<h3 id="toc_2">11.1.2 DVM架构</h3>

<p><img src="media/15537010053206/15776935576868.jpg" alt="" style="width:328px;"/></p>

<p>首先Java编译器编译的.class文件经过DX工具转换为.dex文件，.dex文件由类加载器处理，接着解释器根据指令集对Dalvik字节码进行解释、执行，最后交于Linux处理。</p>

<h3 id="toc_3">11.1.3 DVM的运行时堆</h3>

<p>DVM的运行时堆使用标记一清除(Mark一Sweep) 算法进行GC，它由两个Space以及多个辅助数据结构组成，两个Space分别是Zygote Space (Zygote Heap)和Allocation Space(Active Heap)。Zygote Space用来管理Zygote进程在启动过程中预加载和创建的各种对象，Zygote Space中不会触发GC,在Zygote进程和应用程序进程之间会共享Zygote Space。在Zygote进程fork第一个子进程之前，会把Zygote Space分为两个部分，原来的已经被使用的那部分堆仍旧叫Zygote Space， 而未使用的那部分堆就叫Allocation Space， 以后的对象都会在Allocation Space上进行分配和释放。Allocation Space不是进程间共享的，在每个进程中都独立拥有一份。除了这两个Space，还包含以下数据结构。</p>

<ul>
<li>Card Table: 用于DVM Concurrent GC，当第一次进行垃圾标记后，记录垃圾信息。</li>
<li> Heap Bitmap: 有两个Heap Bitmap， 一个用来记录上次GC存活的对象，另一个用来记录这次GC存活的对象。</li>
<li>Mark Stack: DVM的运行时堆使用标记一清除(Mark一 Sweep)算法进行GC，MarkStack就是在GC的标记阶段使用的，它用来遍历存活的对象。</li>
</ul>

<h3 id="toc_4">11.1.4 DVM的GC日志</h3>

<p>在10.6.2节中提到了Java虚拟机的GC日志。DVM和ART的GC日志与Java虚拟机的日志有较大的区别。在DVM中每次垃圾收集都会将GC日志打印到logcat中，具体的格式为:</p>

<pre><code class="language-text">D/dalvikvm: &lt;GC Reason&gt; &lt;Amount freed&gt;， &lt;Heap stats&gt;，&lt;External memory stats&gt;,&lt;Pause t ime&gt;
</code></pre>

<p>可以看到DVM的日志共有5个信息，其中GCReason有很多种，这里将它单独拿出来进行介绍。</p>

<p><strong>1.引起GC的原因</strong><br/>
GC Reason就是引起GC的原因，有以下几种。</p>

<ul>
<li>GC_CONCURRENT: 当堆开始填充时，并发GC可以释放内存。</li>
<li>GC_FOR_MALLOC:当堆内存已满时，App尝试分配内存而引起的GC，系统必须停止App并回收内存。</li>
<li>GC_HPROF_DUMP_HEAP:当你请求创建HPROF文件来分析堆内存时出现的GC。</li>
<li>GC_EXPLICIT: 显式的GC，例如调用System.gc() (应该避免调用显式的GC,信任GC会在需要时运行)。</li>
<li>GC_EXTERNAL_ALLOC: 仅适用于API级别小于等于10， 且用于外部分配内存的GC。</li>
</ul>

<p><strong>2.其他的信息</strong><br/>
除了引起GC的原因，其他的信息如下。</p>

<ul>
<li>Amount freed: 本次GC释放内存的大小。</li>
<li>Heap_stats: 堆的空闲内存百分比(已用内存) / (堆的总内存)。</li>
<li>External_memory_stats: API小于等于级别10的内存分配(已分配的内存) / (引起GC的阈值)。</li>
<li>Pausetime:暂停时间，更大的堆会有更长的暂停时间。并发暂停时间会显示两个暂停时间，即一个出现在垃圾收集开始时，另一个出现在垃圾收集快要完成时。</li>
</ul>

<p><strong>3.实例分析</strong></p>

<pre><code class="language-text">D/dalvikvm: GC CONCURRENT freed 2012K, 63号 free 3213K/9291K, external 4501K/5161K,paused 2ms+2ms
</code></pre>

<p>这个GC日志的含义为:引起GC的原因是GC_CONCURRENT;本次GC释放的内存为2012KB; 堆的空闲内存百分比为63%， 已用内存为3213KB，堆的总内存为9291KB;暂停的总时长为4ms。</p>

<h2 id="toc_5">11.2 ART虚拟机</h2>

<p>ART (Android Runtime)虚拟机是Android 4.4发布的,用来替换Dalvik虚拟机，Android4.4默认采用的还是DVM,系统会提供一 个选项来开启ART。在Android 5.0版本中默认采用了ART, DVM从此退出历史舞台。</p>

<h3 id="toc_6">11.2.1 ART与DVM的区别</h3>

<ol>
<li>从11.1节我们知道，DVM中的应用每次运行时,字节码都需要通过JIT编译器编译为机器码，这会使得应用程序的运行效率降低。而在ART中，系统在安装应用程序时会进行一次AOT (ahead of time compilation, 预编译)，将字节码预先编译成机器码并存储在本地，这样应用程序每次运行时就不需要执行编译了，运行效率会大大提升，设备的耗电量也会降低。这就好比我们在线阅读漫画，DVM是我们阅读到哪就加载哪，ART则是直接加载一章的漫画,虽然一开始加载速度有些慢,但是后续的阅读体验会很流畅。采用AOT也会有缺点，主要有两个:第一个是AOT会使得应用程序的安装时间变长，尤其是一些复杂的应用;第二个是字节码预先编译成机器码，机器码需要的存储空间会多一些。为了解决上面的缺点，Android 7.0版本中的ART加入了即时编译器JIT，作为AOT的一个补充，在应用程序安装时并不会将字节码全部编译成机器码，而是在运行中将热点代码编译成机器码，从而缩短应用程序的安装时间并节省了存储空间。</li>
<li>DVM是为32位CPU设计的，而ART支持64位并兼容32位CPU,这也是DVM被淘汰的主要原因之一。</li>
<li>ART对垃圾回收机制进行了改进，比如更频繁地执行并行垃圾收集，将GC暂停由2次减少为1次等。</li>
<li>ART的运行时堆空间划分和DVM不同。</li>
</ol>

<h3 id="toc_7">11.2.2 ART的运行时堆</h3>

<p>与DVM的GC不同的是，ART采用了多种垃圾收集方案，每个方案会运行不同的垃圾收集器,默认是采用了CMS(Concurrent Mark一Sweep)方案,该方案主要使用了sticky一CMS和partial一CMS。根据不同的CMS方案，ART的运行时堆的空间也会有不同的划分，默认是由4个Space和多个辅助数据结构组成的，4个Space分别是Zygote Space、AllocationSpace、Image Space和Large Object Space。Zygote Space、Allocation Space和DVM中的作用是一样的，Image Space用来存放一些预加载类, Large Object Space用来分配一些大对象(默认大小为12KB)，其中Zygote Space和Image Space是进程间共享的。采用标记一清除算法的运行时堆空间划分如图11一3所示。</p>

<p><img src="media/15537010053206/15776955652187.jpg" alt="" style="width:775px;"/></p>

<p>除了这四个Space，ART的Java堆中还包括两个Mod Union Table, 一个Card Table,两个Heap Bitmap,两个Object Map，以及三个Object Stack。</p>

<h3 id="toc_8">11.2.3 ART的GC日志</h3>

<p>ART的GC日志与DVM不同，ART会为那些主动请求的垃圾收集事件或者认为GC速度慢时才会打印GC日志。GC速度慢指的是GC暂停超过5ms或者GC持续时间超过100ms。如果App未处于可察觉的暂停进程状态，那么它的GC不会被认为是慢速的。<br/>
ART的GC日志具体的格式为:</p>

<pre><code class="language-text">I/art: &lt;GC_Reason&gt; &lt;GC_Name&gt; &lt;0bjects_freed&gt; (&lt;Size_freed&gt;) AllocSpace Objects,&lt;Large_objects_freed&gt; (&lt;Large_object_size_freed&gt;) &lt;Heap_stats&gt; LOS objects,
&lt;Pause time(s)&gt;
</code></pre>

<p><strong>1.引起GC原因</strong><br/>
ART的引起GC原因(GC_Reason) 要比DVM多一些，有以下几种。</p>

<ul>
<li>Concurrent: 并发GC,不会使App的线程暂停，该GC是在后台线程运行的，并不会阻止内存分配。</li>
<li>Alloc: 当堆内存已满时，App尝试分配内存而引起的GC，这个GC会发生在正在.分配内存的线程中。</li>
<li>Explicit: App 显示的请求垃圾收集，例如调用System.gc()。与DVM一样，最佳做法是应该信任GC并避免显式地请求GC,显式地请求GC会阻止分配线程并不必要地浪费CPU周期。如果显式地请求GC导致其他线程被抢占,那么有可能会导致jank(App同一帧画了多次)。</li>
<li>NativeAlloc: Native 内存分配时，比如为Bitmaps或者RenderScript分配对象，这会导致Native内存压力，从而触发GC。</li>
<li>CollectorTransition: 由堆转换引起的回收，这是运行时切换GC而引起的。收集器转换包括将所有对象从空闲列表空间复制到碰撞指针空间(反之亦然)。 当前，收集器转换仅在以下情况下出现:在内存较小的设备.上，App将进程状态从可察觉的暂停状态变更为可察觉的非暂停状态(反之亦然)。</li>
<li>HomogeneousSpaceCompact: 齐性空间压缩是指空闲列表到压缩的空闲列表空间，通常发生在当App已经移动到可察觉的暂停进程状态时。这样做的主要原因是减少了内存使用并对堆内存进行碎片整理。</li>
<li>DisableMovingGc: 不是真正触发GC的原因，发生并发堆压缩时，由于使用了GetPrimitiveArrayCritical，收集会被阻塞。在一般情况下，强烈建议不要使用GetPrimitiveArrayCritical，因为它在移动收集器方面具有限制。</li>
<li>HeapTrim: 不是触发GC的原因，但是请注意，收集会一直被阻塞，直到堆内存整理完毕。</li>
</ul>

<p><strong>2.垃圾收集器名称</strong><br/>
GC_Name指的是垃圾收集器名称，有以下几种。</p>

<ul>
<li>Concurrent Mark Sweep (CMS)：CMS 收集器是一种以获取最短收集暂停时间为目标的收集器，采用了标记一清除算法实现。它是完整的堆垃圾收集器，能释放除了Image Space外的所有的空间。</li>
<li>Concurrent Partial Mark Sweep：部分完整的堆垃圾收集器，能释放除了Image Space和Zygote Space外的所有空间。</li>
<li>Concurrent Sticky Mark Sweep：粘性收集器，基于分代的垃圾收集思想，它只能释放自.上次GC以来分配的对象。这个垃圾收集器比一个完整的或部分完整的垃圾收集器扫描得更频繁，因为它更快并且有更短的暂停时间。</li>
<li>Marksweep + Semispace：非并发的GC,复制GC用于堆转换以及齐性空间压缩(堆碎片整理)。</li>
</ul>

<p><strong>3.其他信息</strong></p>

<ul>
<li>Objects freed：本次GC从非Large Object Space中回收的对象的数量。</li>
<li>Size_ freed： 本次GC从非Large Object Space中回收的字节数。</li>
<li>Large objects freed：本次GC从Large Object Space中回收的对象的数量。</li>
<li>Large object size freed：本次GC从Large Object Space中回收的字节数。</li>
<li>Heap stats：堆的空闲内存百分比，即(已用内存) / (堆的总内存)。<br/>
Pause times： 暂停时间， 暂停时间与在GC运行时修改的对象引用的数量成比例。目前，ART的CMS收集器仅有一次暂停，它出现在GC的结尾附近。移动的垃圾收集器暂停时间会很长，会在大部分垃圾回收期间持续出现。</li>
</ul>

<p><strong>4.实例分析</strong></p>

<pre><code class="language-text">I/art : Explicit concurrent mark sweep GC freed 104710 (7MB) AllocSpace objects,21 (416KB) LOS objects， 33号free, 25MB/ 38MB, paused 1.230ms total 67.21 6ms
</code></pre>

<p>这个GC日志的含义为引起GC原因是Explicit; 垃圾收集器为CMS收集器;释放对象的数量为104710个，释放字节数为7MB;释放大对象的数量为21个，释放大对象字节数为416KB;堆的空闲内存百分比为33%，已用内存为25MB,堆的总内存为38MB; GC暂停时长为1.230ms， GC总时长为67.216ms。</p>

<h2 id="toc_9">11.3 DVM和ART的诞生</h2>

<h2 id="toc_10">11.4 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010145803.html">
                
                  <h1>12 理解ClassLoader</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">12.1 Java中的ClassLoader</h2>

<p>类加载子系统，主要作用就是通过多种类加载器（ClassLoader）来查找和加载Class文件到Java虚拟机中。</p>

<h3 id="toc_1">12.1.1 ClassLoader的类型</h3>

<ul>
<li>系统类加载器
<ul>
<li>Bootstrap ClassLoader</li>
<li>Extensions ClassLoader</li>
<li>Application ClassLoader</li>
</ul></li>
<li>自定义类加载器</li>
</ul>

<p><strong>Bootstrap ClassLoader 引导类加载器</strong><br/>
C/C++代码实现的加载器，用于加载指定的JDK核心类库，比如<code>java.lang.</code>、<code>java.util.</code>等系统类。它用来加载以下目录中的类库 :</p>

<ul>
<li>$JAVA HOME/jre/lib 目录。</li>
<li>-Xbootclasspath 参数指定的目录 。<br/>
Java 虚拟机的启动就是通过 Bootstrap ClassLoader 创建一个初始类来完成的。</li>
</ul>

<p><strong>Extensions ClassLoader</strong><br/>
Java 中的实现类为 ExtClassLoader，因此可以简称为ExtClassLoader，它用于加载 Java的拓展类，提供除了系统类之外的额外功能。 ExtClassLoader用来加载以下目录中的类库:</p>

<ul>
<li>加载$JAVA_HOME/jre/lib/ext 目录。</li>
<li>系统属性 java.ext.dir所指定的目录。</li>
</ul>

<p><strong>Application ClassLoader</strong><br/>
简称为APPClassLoader，又称为System ClassLoader（系统类加载器），它用来加载以下目录的类库：</p>

<ul>
<li>当前程序的Classpath目录。</li>
<li>系统属性java.class.path指定的目录。</li>
</ul>

<h3 id="toc_2">12.1.2 ClassLoader的继承关系</h3>

<p><img src="media/15537010145803/15753436684706.jpg" alt="" style="width:383px;"/></p>

<h3 id="toc_3">12.1.3 双亲委托模式</h3>

<p>双亲委托模型：</p>

<ol>
<li>首先判断该Class是否已经加载，如果没有则委托父加载器进行查找</li>
<li>依次进行递归，直到委托到最顶层的Bootstrap ClassLoader</li>
<li>如果Bootstrap ClassLoader找到了该Class，直接返回；如果没有找到，则继续依次向下查找，如果还没找到最后交由自身去查找。
<img src="media/15537010145803/15753458406302.jpg" alt="" style="width:465px;"/></li>
</ol>

<p>双亲委托模型的好处：</p>

<ul>
<li>避免重复加载。</li>
<li>更加安全。比如无法通过自定义String类替代系统的String类。</li>
</ul>

<h3 id="toc_4">12.1.4 自定义ClassLoader</h3>

<p>系统提供的类加载器只能够加载指定目录下的 jar 包和 Class 文件，如果想要加载网络上的或者 D 盘某一文件中的 jar 包和 Class 文件则需要自定义 ClassLoader。实现自定义ClassLoader 需要如下两个步骤:</p>

<ol>
<li>定义一个自定义 ClassLoade 并继承抽象类 ClassLoader。</li>
<li>复写 findClass 方法，并在 findClass 方提中调用 defineClass 方法。</li>
</ol>

<h2 id="toc_5">12.2 Android中的ClassLoader</h2>

<h3 id="toc_6">12.2.1 ClassLoader的类型</h3>

<h3 id="toc_7">12.2.2 ClassLoader的继承关系</h3>

<h3 id="toc_8">12.2.3 ClassLoader的加载过程</h3>

<h3 id="toc_9">12.2.4 BootClassLoader的创建</h3>

<h3 id="toc_10">12.2.5 PathClassLoader的创建</h3>

<h2 id="toc_11">12.3 本章小结 311</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010271155.html">
                
                  <h1>13 热修复原理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">13.1 热修复的产生</h2>

<h2 id="toc_1">13.2 热修复框架的种类和对比</h2>

<h2 id="toc_2">13.3 资源修复</h2>

<h3 id="toc_3">13.3.1 Instant Run概述</h3>

<p>Instant Run是Android Studio 2.0以后新增的一个运行机制， 能够显著减少开发人员第二次及以后的构建和部署时间。在没有使用Instant Run前，我们编译部署应用程序的流程如图所示。</p>

<p><img src="media/15537010271155/15777597312743.jpg" alt="" style="width:608px;"/></p>

<p>从图13一1可以看出,传统的编译部署需要重新安装App和重启App,这显然会很耗时,Instant Run会避免这一情况， 如图所示。</p>

<p><img src="media/15537010271155/15777597727284.jpg" alt="" style="width:879px;"/></p>

<p>从上图可以看出InstantRun的构建和部署都是基于更改的部分的。InstantRun部署有三种方式，Instant Run会根据代码的情况来决定采用哪种部署方式，无论哪种方式都不需要重新安装App,这一点就已经提高了不少的效率。</p>

<ul>
<li>Hotswap:从名称也可以看出HotSwap是效率最高的部署方式，代码的增量改变不需要重启App,甚至不需要重启当前的Activity。 修改一个现有方法中的代码时会采用Hot Swap。</li>
<li>Warm Swap: App不需重启，但是Activity 需要重启。修改或删除一个现有的资源文件时会采用WarmSwap。</li>
<li>Cold Swap: App 需要重启，但是不需要重新安装。采用Cold Swap的情况很多，比如添加、删除或修改一个字段和方法、添加一个类等。</li>
</ul>

<h3 id="toc_4">13.3.2 Instant Run的资源修复</h3>

<p>Instant Run中的资源热修复可以简单地总结为两个步骤:</p>

<ol>
<li>创建新的AssetManager, 通过反射调用addAssetPath方法加载外部的资源，这样新创建的AssetManager就含有了外部资源。</li>
<li>将AssetManager类型的mAssets字段的引用全部替换为新创建的AssetManager。</li>
</ol>

<h2 id="toc_5">13.4 代码修复</h2>

<p>代码修复主要有3个方案，分别是底层替换方案、类加载方案和Instant Run方案。</p>

<h3 id="toc_6">13.4.1 类加载方案</h3>

<p>类加载方案基于Dex分包方案，什么是Dex分包方案呢?这个得先从65536限制和LinearAlloc限制说起。</p>

<p><strong>1. 65536限制</strong></p>

<p>随着应用功能越来越复杂，代码量不断地增大，引入的库也越来越多，可能会在编译时提示如下异常:</p>

<pre><code class="language-text">com. android. dex. DexIndexOverflowException: method ID not in [0， 0xffff] : 65536
</code></pre>

<p>这说明应用中引用的方法数超过了最大数65536个。产生这一问题的原因就是系统的65536限制，65536 限制的主要原因是DVM Bytecode的限制，DVM指令集的方法调用指令invoke-kind索引为16bits, 最多能引用65535个方法。</p>

<p><strong>2. LinearAlloc 限制</strong></p>

<p>在安装应用时可能会提示INSTALL_FAILED_DEXOPT,产生的原因就是LinearAlloc限制，DVM中的LinearAlloc是一个固定的缓存区，当方法数超出了缓存区的大小时会报错。</p>

<p>为了解决65536限制和LinearAlloc限制，从而产生了Dex分包方案。Dex 分包方案主要做的是在打包时将应用代码分成多个Dex,将应用启动时必须用到的类和这些类的直接引用类放到主Dex中，其他代码放到次Dex中。当应用启动时先加载主Dex，等到应用启动后再动态地加载次Dex，从而缓解了主Dex的65536限制和LinearAlloc限制。</p>

<p>Dex分包方案主要有两种，分别是Google官方方案、Dex自动拆包和动态加载方案。</p>

<p>在12.2.3节中学习了ClassLoader的加载过程，其中一个环节就是调用DexPathList 的findClass的方法，如下所示:</p>

<pre><code class="language-text"> public Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) {
        for (Element element : dexElements) {//1
            Class&lt;?&gt; clazz = element.findClass(name, definingContext, suppressed);//2
            if (clazz != null) {
                return clazz;
            }
        }
        if (dexElementsSuppressedExceptions != null) {
            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
        }
        return null;
    }
</code></pre>

<p>Element内部封装了DexFile，DexFile用于加载dex文件，因此每个dex文件对应一个Element。</p>

<p>多个Element组成了有序的Element数组dexElements。当要查找类时，会在注释1处遍历Element数组dexElements（相当于遍历dex文件数组），注释2处调用Element的findClass方法，其方法内部会调用DexFile的loadClassBinaryName方法查找类。如果在Element中（dex文件）找到了该类就返回，如果没有找到就接着在下一个Element中进行查找。<br/>
根据上面的查找流程，我们将有bug的类Key.class进行修改，再将Key.class打包成包含dex的补丁包Patch.jar，放在Element数组dexElements的第一个元素，这样会首先找到Patch.dex中的Key.class去替换之前存在bug的Key.class，排在数组后面的dex文件中的存在bug的Key.class根据ClassLoader的双亲委托模式就不会被加载，这就是类加载方案，如下图所示。</p>

<p><img src="media/15537010271155/15777610942927.jpg" alt="" style="width:641px;"/></p>

<p>类加载方案需要重启App后让ClassLoader重新加载新的类，为什么需要重启呢？这是因为类是无法被卸载的，因此要想重新加载新的类就需要重启App，因此采用类加载方案的热修复框架是不能即时生效的。<br/>
虽然很多热修复框架采用了类加载方案，但具体的实现细节和步骤还是有一些区别的：</p>

<ul>
<li>QQ空间的超级补丁和Nuwa是按照上面说得将补丁包放在Element数组的第一个元素得到优先加载。</li>
<li>微信Tinker将新旧apk做了diff，得到patch.dex，然后将patch.dex与手机中apk的classes.dex做合并，生成新的classes.dex，然后在运行时通过反射将classes.dex放在Element数组的第一个元素。</li>
<li>饿了么的Amigo则是将补丁包中每个dex 对应的Element取出来，之后组成新的Element数组，在运行时通过反射用新的Element数组替换掉现有的Element 数组。</li>
</ul>

<p>采用类加载方案的主要是以腾讯系为主，包括微信的Tinker、QQ空间的超级补丁、手机QQ的QFix、饿了么的Amigo和Nuwa等等。</p>

<h3 id="toc_7">13.4.2 底层替换方案</h3>

<p>与类加载方案不同的是，底层替换方案不会再次加载新类，而是直接在Native层修改原有类，由于是在原有类进行修改限制会比较多，不能够增减原有类的方法和字段，如果我们增加了方法数，那么方法索引数也会增加，这样访问方法时会无法通过索引找到正确的方法，同样的字段也是类似的情况。</p>

<p>底层替换方案和反射的原理有些关联，就拿方法替换来说，</p>

<ol>
<li>方法反射我们可以调用java.lang.Class.getDeclaredMethod.invoke()</li>
<li>invoke方法是个native方法，对应Jni层的代码为：<code>art/runtime/native/java_lang_reflect_Method.cc</code></li>
<li>Method_invoke函数中又调用了InvokeMethod函数：<code>art/runtime/reflection.cc</code></li>
<li>然后可以获取传入的javaMethod（Key的show方法）在ART虚拟机中对应的一个ArtMethod指针，ArtMethod结构体中包含了Java方法的所有信息，包括执行入口、访问权限、所属类和代码执行地址等等</li>
<li>ArtMethod结构中比较重要的字段是dex_cache_resolved_methods_和的entry_point_from_quick_compiled_code_，它们是方法的执行入口，当我们调用某一个方法时（比如Key的show方法），就会取得show方法的执行入口，通过执行入口就可以跳过去执行show方法。替换ArtMethod结构体中的字段或者替换整个ArtMethod结构体，这就是底层替换方案。</li>
</ol>

<p>AndFix采用的是替换ArtMethod结构体中的字段，这样会有兼容问题，因为厂商可能会修改ArtMethod结构体，导致方法替换失败。Sophix采用的是替换整个ArtMethod结构体，这样不会存在兼容问题。</p>

<p>底层替换方案直接替换了方法，可以立即生效不需要重启。采用底层替换方案主要是阿里系为主，包括AndFix、Dexposed、阿里百川、Sophix。</p>

<h3 id="toc_8">13.4.3 Instant Run方案</h3>

<p>除了资源修复，代码修复同样也可以借鉴Instant Run的原理， 可以说Instant Run的出现推动了热修复框架的发展。<br/>
Instant Run在第一次构建apk时，使用ASM在每一个方法中注入了类似如下的代码：</p>

<pre><code class="language-text">IncrementalChange localIncrementalChange = $change;//1
        if (localIncrementalChange != null) {//2
            localIncrementalChange.access$dispatch(
                    &quot;onCreate.(Landroid/os/Bundle;)V&quot;, new Object[] { this,
                            paramBundle });
            return;
        }
</code></pre>

<ol>
<li>其中注释1处是一个成员变量localIncrementalChange ，它的值为\(change，\)change实现了IncrementalChange这个抽象接口。</li>
<li>当我们点击InstantRun时，如果方法没有变化则$change为null，就调用return，不做任何处理。</li>
<li>如果方法有变化，就生成替换类，
<ol>
<li>这里我们假设MainActivity的onCreate方法做了修改，就会生成替换类MainActivity$override，这个类实现了IncrementalChange接口，同时也会生成一个AppPatchesLoaderImpl类，</li>
<li>这个类的getPatchedClasses方法会返回被修改的类的列表（里面包含了MainActivity），</li>
<li>根据列表会将MainActivity的$change设置为MainActivity$override，因此满足了注释2的条件，会执行MainActivity$override的access$dispatch方法，</li>
<li>accessdispatch方法中会根据参数&#39;onCreate.(Landroid/os/Bundle;)V;&#39;，执行&#39;MainActivityoverride&#39;的onCreate方法，从而实现了onCreate方法的修改。</li>
</ol></li>
</ol>

<p>借鉴Instant Run的原理的热修复框架有Robust和Aceso。</p>

<h2 id="toc_9">13.5 动态链接库的修复</h2>

<p>Android平台的动态链接库主要指的是so库，为了更好地理解，本章动态链接库简称为so。热修复框架的so的修复的主要是更新so，换句话说就是重新加载so，因此so的修复的基础原理就是加载。</p>

<h3 id="toc_10">13.5.1 System的load和loadLibarary方法</h3>

<p>加载so主要用到了System类的load和loadLibarary方法。</p>

<ul>
<li>System的load方法传入的参数是so在磁盘的完整路径,用于加载指定路径的so。</li>
<li>System的loadLibrary方法传入的参数是so的名称，用于加载App安装后自动从apk包中复制到/data/data/ packagename/lib下的so。</li>
</ul>

<p><strong>1. System的load方法</strong></p>

<ol>
<li>Runtime.getRuntime()会得到当前Java应用程序的运行环境Runtime</li>
<li>调用了doLoad方法，并将加载该类的类加载器作为参数传入进去:</li>
<li>doLoad方法会调用native方法nativeLoad</li>
</ol>

<p><strong>2. System的loadLibrary方法</strong></p>

<ol>
<li>先调用Runtime的loadLibrary0方法，loadLibrary0方法分为两个部分，一个是传入的ClassLoader不为null的部分，另一个是ClassLoader为null的部分</li>
<li>我们先来看ClassLoader 为null的部分。先遍历getLibPaths方法，这个方法会返回java.library.path选项配置的路径数组，然后拼接出so路径作为参数调用doLoad方法中。</li>
<li>当ClassLoader不为null时，先通过ClassLoader的findLibrary方法来得到fileName，然后调用doLoad 方法。</li>
<li><strong>findLibrary</strong>：ClassLoader的findLibrary方法在实现类BaseDexClassLoader中实现，然后会调用DexPathList的findLibrary方法，这和13.3.1 节讲到的DexPathList的findClass方法类似，
<ol>
<li>在NativeLibraryElement数组中的每一个NativeLibraryElement对应一个so库，</li>
<li>然后调用NativeLibraryElement的findNativeLibrary方法就可以返回so的路径。结合的类加载方案，就可以得到so的修复的一种方案，就是：</li>
<li>将so补丁插入到NativeLibraryElement数组的前部，让so补丁的路径先被返回，并调用Runtime的doLoad方法进行加载，</li>
<li>在doLoad方法中会调用native 方法nativeLoad。</li>
</ol></li>
</ol>

<h3 id="toc_11">13.5.2 nativeLoad方法分析</h3>

<p>LoadNativeLibrary函数的行数很多，这里来做一个总结，LoadNativeLibrary 函数主要做了如下3方面工作：</p>

<ol>
<li>判断so是否被加载过，两次ClassLoader是否是同一个，避免so重复加载。</li>
<li>打开so并得到so句柄，如果so句柄获取失败,就返回false。创建新的SharedLibrary,如果传入path对应的library 为空指针，就将新创建的SharedIibrary赋值给library, 并将library存储到libraries_中。</li>
<li>查找JNI_OnLoad 的函数指针，根据不同情况设置was_successful 的值，最终返回该was_successful。</li>
</ol>

<p><img src="media/15537010271155/15777663637419.jpg" alt=""/></p>

<p>讲到这里总结一下so修复主要有两个方案:</p>

<ol>
<li>将so补丁插入到NativeLibraryElement数组的前部，让so补丁的路径先被返回和加载。</li>
<li>调用System的load方法来接管so的加载入口。</li>
</ol>

<h2 id="toc_12">13.6 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010310819.html">
                
                  <h1>14 Hook技术</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>说到Hook技术得先提到逆向工程，逆向工程源于商业及军事领域中的硬件分析，其主要目的是在不能轻易获得必要的生产信息的情况下，直接从成品分析，推导出产品的设计原理。</p>

<p>逆向分析分为静态分析和动态分析，其中静态分析指的是一种在不执行程序的情况下对程序行为进行分析的技术;动态分析是指在程序运行时对程序进行调试的技术。</p>

<p>Hook技术就属于动态分析，它不仅在Android平台中被应用，早在Windows平台中就已经被应用了。</p>

<h2 id="toc_0">14.1 Hook技术概述</h2>

<p>我们知道应用程序进程之间是彼此独立的，应用程序进程和系统进程之间也是如此，想要在应用程序进程更改系统进程的某些行为很难直接实现，有了Hook 技术，我们就可以在进程间进行行为更改，如图所示。</p>

<p><img src="media/15537010310819/15777731979912.jpg" alt="" style="width:730px;"/></p>

<p>可以看到Hook可以将自己融入到它所要劫持的对象(对象B)所在的进程中，成为系统进程的一部分，这样我们就可以通过Hook来更改对象B的行为。被劫持的对象(对象B)，称作Hook点，为了保证Hook的稳定性，Hook点一般选择容易找到并且不易变化的对象，静态变量和单例就符合这一条件。</p>

<h2 id="toc_1">14.2 Hook技术分类</h2>

<p>Hook技术知识点比较多，因此Hook技术根据不同的角度会有很多种分类，这里介绍其中的三种分类。</p>

<ul>
<li>根据Hook的API语言划分，分为Hook Java和Hook Native。
<ul>
<li>Hook Java主要通过反射和代理来实现，应用于在SDK开发环境中修改Java代码。</li>
<li>HookNative则应用于在NDK开发环境和系统开发中修改Native代码。</li>
</ul></li>
<li>根据Hook的进程划分，分为应用程序进程Hook和全局Hook。
<ul>
<li>应用程序进程Hook只能Hook当前所在的应用程序进程。</li>
<li>应用程序进程是Zygote进程fock出来的，如果对Zygote进行Hook, 就可以实现Hook系统所有的应用程序进程，这就是全局Hook。</li>
</ul></li>
<li>根据Hook的实现方式划分，分为如下两种。
<ul>
<li>通过反射和代理实现，只能Hook当前的应用程序进程。</li>
<li>通过Hook框架来实现，比如Xposed， 可以实现全局Hook, 但是需要root。</li>
</ul></li>
</ul>

<p>Hook Native、全局Hook和通过Hook框架实现这些分类和插件化技术关联不大，本章主要需要学习的是Hook Java,想要更好地学习Hook Java,首先要了解代理模式。</p>

<h2 id="toc_2">14.3 代理模式</h2>

<p>代理模式也叫委托模式，是结构型设计模式的一一种。在现实生活中我们用到类似代理模式的场景有很多，比如代购、代理上网、打官司等。</p>

<p>定义：为其他对象提供一种代理以控制对这个对象的访问称为代理模式。</p>

<p>在代理模式中有如下角色。</p>

<ul>
<li>Subject: 抽象主题类，声明真实主题与代理的共同接口方法。</li>
<li>RealSubject: 真实主题类，定义了代理所表示的集体对象，客户端通过代理类间接调用真实主题类的方法。</li>
<li>Proxy: 代理类，持有对真实主题类的引用，在其所实现的接口方法中调用真实主题类中相应的接口方法执行。</li>
<li>Client: 客户端类。</li>
</ul>

<p><img src="media/15537010310819/15777735922722.jpg" alt="" style="width:639px;"/></p>

<h3 id="toc_3">14.3.1 代理模式简单实现</h3>

<h3 id="toc_4">14.3.2 动态代理的简单实现</h3>

<p>从编码的角度来说，代理模式分为静态代理和动态代理。</p>

<ul>
<li>静态代理，在代码运行前就已经存在了代理类的class编译文件</li>
<li><p>动态代理则是在代码运行时通过反射来动态地生成代理类的对象，并确定到底来代理谁。Java 提供了动态的代理接口InvocationHandler,实现该接口需要重写invoke方法。</p></li>
</ul>

<ol>
<li>创建代理类，实现InvocationHandler接口</li>
<li><p>客户端类代码：</p>
<pre><code class="language-text">public class Client {
    public static void main(String[] args) {<br/>
        //创建LiuWangShu<br/>
        IShop liuwangshu = new LiuWangShu() ;<br/>
        //创建动态代理<br/>
        DynamicPurchasing mDynamicPurchasing = new DynamicPurchasing(liuwangshu) ; <br/>
        //创建LiuWangShu的ClassLoader<br/>
        ClassLoader loader = liuwangshu.getClass().getClassLoader() ;<br/>
        //动态创建代理类<br/>
        IShop purchasing = (IShop)Proxy.newProxyInstance(loader, new Class[] {IShop.class}, mDynamicPurchasing) ;<br/>
        purchasing.buy() ;<br/>
    }<br/>
}
</code></pre></li>
</ol>

<h2 id="toc_5">14.4 Hook startActivity方法</h2>

<p>我们知道Hook可以用来劫持对象，被劫持的对象叫作Hook点，用代理对象来替代Hook点，这样我们就可以在代理上实现自己想做的操作。这里以Hook常用的startActivity方法来举例，startActivity 方法分为两个，如下所示:</p>

<ul>
<li>startActivity (intent) ;</li>
<li>getApplicationContext () . startActivity (intent) ;</li>
</ul>

<p>第一个是Actvity的startActivity方法，第二个是Context的startActivity 方法。</p>

<h3 id="toc_6">14.4.1 Hook Activity的startActivity方法</h3>

<h3 id="toc_7">14.4.2 Hook Context的startActivity方法</h3>

<h3 id="toc_8">14.4.3 Hook startActivity总结</h3>

<h2 id="toc_9">14.5 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010351262.html">
                
                  <h1>15 插件化技术</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>插件化技术和热修复技术都属于动态加载技术。</p>

<h2 id="toc_0">15.1 动态加载技术</h2>

<p>在Android传统开发中，一旦应用的代码被打包成APK并被上传到各个渠道市场，我们就不能修改应用的源码了，只能通过服务器来控制应用中预留的分支代码。但是很多时候我们无法提前预知需求和突然发生的情况，也就不能提前在应用代码中预留分支代码，这时就需要采用动态加载技术。</p>

<p>在应用程序运行时，动态加载一些程序中原本不存在的可执行文件并运行这些文件里的代码逻辑。可执行文件总的来说分为两种，一种是动态链接库so，另一种是dex相关文件(dex 以及包含dex的jar/apk文件)。</p>

<p>随着应用开发技术和业务的逐步发展，动态加载技术派生出两个技术，分别是热修复技术和插件化技术，其中热修复技术主要用来修复Bug, 插件化技术则主要用于解决应用越来越庞大以及功能模块的解耦。</p>

<h2 id="toc_1">15.2 插件化的产生</h2>

<h3 id="toc_2">15.2.1 应用开发的痛点和瓶颈</h3>

<ol>
<li>业务复杂，模块耦合</li>
<li>应用间的接入</li>
<li>65536限制，内存占用大</li>
</ol>

<h3 id="toc_3">15.2.2 插件化思想</h3>

<h3 id="toc_4">15.2.3 插件化定义</h3>

<p>插件化的客户端由宿主和插件两个部分组成。宿主就是指先被安装到手机中的APK,就是平常我们加载的普通APK。插件一般是指经过处理的APK.so和dex等文件，插件可以被宿主进行加载，有的插件也可以作为APK独立运行。</p>

<p>讲到这里就可以引出插件化的定义：将一个应用按照插件的方式进行改造的过程就叫作插件化。</p>

<p>在协作方面，插件可以由一个人或者一个小组来进行开发，这样各个插件之间，以及插件和宿主之间的耦合度会降低。应用间的接入和维护也变得便捷，每个应用团队只需要负责自己的那一部分就可以了。应用以及主dex的体积也会相应变小，间接地避免了65536限制。第一次加载到内存的只有淘宝主客户端，当使用到其他插件时才会加载相应插件到内存，这样就减少了内存的占用。</p>

<h2 id="toc_5">15.3 插件化框架对比</h2>

<h2 id="toc_6">15.4 Activity插件化</h2>

<p>四大组件的插件化是插件化技术的核心知识点，而Activity 插件化更是重中之重，Activity插件化主要有3种实现方式，分别是反射实现、接口实现和Hook技术实现。反射实现会对性能有所影响，主流的插件化框架没有采用此方式，关于接口实现可以阅读dynamic-load-apk的源码，目前Hook技术实现是主流，因此本章主要介绍Hook技术实现。</p>

<p>Hook技术实现主要有两种解决方案，一种是通过Hook IActivityManager来实现，另一种是Hook Instrumentation实现。在讲到这两个解决方案前,我们需要从整体上了解Activity的启动流程。</p>

<h3 id="toc_7">15.4.1 Activity的启动过程回顾</h3>

<p><img src="media/15537010351262/15777798479991.jpg" alt="" style="width:611px;"/></p>

<p>首先Launcher进程向AMS请求创建根Activity, AMS会判断根Activity所需的应用程序进程是否存在并启动，如果不存在就会请求Zygote进程创建应用程序进程。应用程序进程启动后, AMS会请求应用程序进程创建并启动根Activity。</p>

<p>普通Activity和根Activity的启动过程大同小异，不涉及应用程序进程的创建，与Launcher也没关系：</p>

<p><img src="media/15537010351262/15777799240155.jpg" alt="" style="width:676px;"/></p>

<p>在应用程序进程中的Activity 向AMS请求创建普通Activity (步骤1)，AMS会对这个Activity的生命周期和栈进行管理，校验Activity等。如果Activity 满足AMS的校验，AMS就会请求应用程序进程中的ActivityThread去创建并启动普通Activity (步骤2)。</p>

<h3 id="toc_8">15.4.2 Hook IActivityManager方案实现</h3>

<p>AMS存在于SystemServer 进程中,我们无法直接修改,只能在应用程序进程中做文章。可以采用预先占坑的方式来解决没有在AndroidManifest.xml 中显式声明的问题，具体做法就是先使用一个在AndroidManifest.xml中注册的Activity来进行占坑，用来通过AMS的校验。接着用插件Activity替换占坑的Activity。</p>

<ol>
<li>注册Activity进行占坑</li>
<li>使用占坑Activity通过AMS验证</li>
<li>还原插件Activity</li>
<li>插件Activity的生命周期</li>
</ol>

<p><img src="media/15537010351262/15779367744180.jpg" alt="" style="width:697px;"/></p>

<h3 id="toc_9">15.4.3 Hook Instrumentation方案实现</h3>

<p>Hook Instrumentation 实现同样也需要用到占坑Activity,与Hook IActivityManager实现不同的是，用占坑Activity替换插件Activity以及还原插件Activity 的地方不同。</p>

<p><img src="media/15537010351262/15779368438324.jpg" alt="" style="width:682px;"/></p>

<h3 id="toc_10">15.4.4 总结</h3>

<h2 id="toc_11">15.5 Service插件化</h2>

<h3 id="toc_12">15.5.1 插件化方面Service与Activity的不同</h3>

<p><img src="media/15537010351262/15779370174333.jpg" alt="" style="width:693px;"/></p>

<p><img src="media/15537010351262/15779370330965.jpg" alt="" style="width:795px;"/></p>

<p>我们需要了解在插件化方面Activity和Service有何不同：</p>

<ul>
<li>Activity是基于栈管理的，一个栈中的Activity的数量不会太多，因此插件化框架处理的插件Activity 数量是有限的，可以声明有限的占坑Activity 来实现。除去硬件和系统限制，插件化框架处理的插件Service的数量可以是近乎无限的，无法用有限的占坑Service来实现。</li>
<li>在Standard模式下多次启动同一个占坑Activity 可以创建多个Activity 实例，但是多次启动占坑Service并不会创建多个Service实例。</li>
<li>用户和界面的交互会影响到Activity 的生命周期，因此插件Activity 的生命周期需要交由系统来管理，Hook IActivityManager方案中还原插件Activity 就是为了这一点。Service的生命周期不受用户影响，可以由开发者管理生命周期，没有必要还原插件。</li>
</ul>

<h3 id="toc_13">15.5.2 代理分发实现</h3>

<p>Activity插件化的重点在于要保证它的生命周期，而Service插件化的重点是保证它的优先级，这就需要用一个真正的Service 来实现，而不是像占坑Activity那样起一个占坑的作用。当启动插件Service时，就会先启动代理Service,当这个代理Service 运行起来之后，在它的onStartCommand等方法里面进行分发，执行插件TargetService 的onCreate等方法,这一方案就叫作代理分发。</p>

<ol>
<li>启动代理Service</li>
<li>代理分发</li>
</ol>

<h2 id="toc_14">15.6 ContentProvider插件化</h2>

<h3 id="toc_15">15.6.1 ContentProvider的启动过程回顾</h3>

<p><img src="media/15537010351262/15779372880299.jpg" alt="" style="width:765px;"/></p>

<h3 id="toc_16">15.6.2 VirtualApk的实现</h3>

<ol>
<li>VirtualApk 初始化</li>
<li>启动代理ContentProvider</li>
<li>代理分发</li>
</ol>

<h2 id="toc_17">15.7 BroadcastReceiver的插件化</h2>

<h3 id="toc_18">15.7.1 广播插件化思路</h3>

<p>IntentFilter的，讲到这里我们得到了一个新思路，那就是将静态注册的BroadcastReceiver全部转换为动态注册来处理，虽然静态和动态的BroadcastReceiver 的生命周期不同，但是为了实现插件化，这个缺点显然不是关键问题。</p>

<h3 id="toc_19">15.7.2 VirtualApk的实现</h3>

<h2 id="toc_20">15.8 资源的插件化</h2>

<h3 id="toc_21">15.8.1 系统资源加载</h3>

<h3 id="toc_22">15.8.2 VirtualApk实现</h3>

<p>资源的插件化方案主要有两种:一种是合并资源方案，将插件的资源全部添加到宿主的Resources中，这种方案插件可以访问宿主的资源。另一 种是构建插件资源方案，每个插件都构造出独立的Resources，这种方案插件不可以访问宿主资源。VirtualApk 采用了以上两种方案。</p>

<h2 id="toc_23">15.9 so的插件化</h2>

<p>so热修复主要有两种方案:</p>

<ul>
<li>将so补丁插入到NativeLibraryElement数组的前部，让so补丁的路径先被返回和加载。</li>
<li>调用System的load方法来接管so的加载入口。</li>
</ul>

<p>so的插件化的方案和so热修复第一种方案类似，简单来说就是将so插件插入到NativeLibraryElement数组中，并且将存储so插件的文件添加到nativeLibraryDirectories 集合中就可以了。</p>

<h2 id="toc_24">15.10 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010402151.html">
                
                  <h1>16 绘制优化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">16.1 绘制性能分析</h2>

<p>Android应用需要将自己的界面展示给用户，用户会和界面进行交互,界面的流畅度至关重要，这一节我们就来学习绘制性能分析，首先讲解绘制原理，接着介绍绘制性能分析的工具: Profile GPU Rendering、Systrace 和Traceview。</p>

<h3 id="toc_1">16.1.1 绘制原理</h3>

<p>View的绘制流程有3个步骤，分别是measure、layout 和draw，它们主要运行在系统的应用框架层,而真正将数据渲染到屏幕上的则是系统Native层的SurfaceFlinger 服务来完成的。</p>

<p>绘制过程主要由CPU来进行Measure、Layout.、Record、Execute的数据计算工作, GPU负责栅格化、渲染。CPU和GPU是通过图形驱动层来进行连接的，图形驱动层维护了一个队列，CPU将displaylist添加到该队列中，这样GPU就可以从这个队列中取出数据进行绘制。</p>

<p>说到绘制性能就需要提到帧数这个概念。帧数就是在1秒时间里传输的图片的量，也可以理解为图形处理器每秒钟能够刷新几次，通常用FPS (Frames Per Second)表示。每一帧其实就是静止的图像，通过快速连续地显示帧便形成了运动的假象。如果画面在60fps则不会感觉到卡顿，如果低于60fps，比如50fps则会感觉到卡顿。要想画面保持在60fps，需要屏幕在1秒内刷新60次，也就是每16.6667ms 刷新一次(绘制时长在16ms以内)。</p>

<p>Android系统每隔16ms 发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps, 那什么是VSYNC呢? VSYNC是VerticalSynchronization (垂直同步)的缩写，是一种定时中断，一旦收到VSYNC信号，CPU就开始处理各帧数据。如果某个操作要花费24ms,这样系统在得到VSYNC信号时无法进行正常的渲染，会发生丢帧，用户会在32ms中看到同一帧的画面。</p>

<p>产生卡顿原因有很多，主要有以下几点:</p>

<ul>
<li>布局Layout过于复杂，无法在16ms内完成渲染。</li>
<li>同一时间动画执行的次数过多，导致CPU或GPU负载过重。</li>
<li>View过度绘制，导致某些像素在同一帧时间内被绘制多次。</li>
<li>在UI线程中做了稍微耗时的操作。</li>
<li>GC回收时暂停时间过长或者频繁的GC产生大量的暂停时间。</li>
</ul>

<h3 id="toc_2">16.1.2 Profile GPU Rendering</h3>

<h3 id="toc_3">16.1.3 Systrace</h3>

<h3 id="toc_4">16.1.4 Traceview</h3>

<h2 id="toc_5">16.2 布局优化</h2>

<h3 id="toc_6">16.2.1 布局优化工具</h3>

<h3 id="toc_7">16.2.2 布局优化方法</h3>

<h3 id="toc_8">16.2.3 避免GPU过度绘制</h3>

<h2 id="toc_9">16.3 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010506228.html">
                
                  <h1>17 内存优化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">17.1 避免可控的内存泄漏</h2>

<h3 id="toc_1">17.1.1 什么是内存泄漏</h3>

<p>每个应用程序都需要内存来完成工作，为了确保Android系统的每个应用都有足够的内存，Android系统需要有效地管理内存分配。当内存不足时,Android运行时就会触发GC,GC采用的垃圾标记算法为根搜索算法。</p>

<p>内存泄漏就是指没有用的对象到GC Roots 是可达的(对象被引用)，导致GC无法回收该对象。</p>

<h3 id="toc_2">17.1.2 内存泄漏的场景</h3>

<ol>
<li>非静态内部类的静态实例
<ol>
<li>非静态内部类会持有外部类实例的引用，如果非静态内部类的实例是静态的，就会间接地长期维持着外部类的引用，阻止被系统回收。</li>
</ol></li>
<li>多线程相关的匿名内部类/非静态内部类</li>
<li>Handler内存泄漏</li>
<li>未正确使用Context</li>
<li>静态View</li>
<li>WebView</li>
<li>资源对象未关闭</li>
<li>集合中对象没清理</li>
<li>Bitmap对象</li>
<li>监听器未关闭</li>
</ol>

<h2 id="toc_3">17.2 Memory Monitor</h2>

<h3 id="toc_4">17.2.1 使用Memory Monitor</h3>

<h3 id="toc_5">17.2.2 大内存申请与GC</h3>

<h3 id="toc_6">17.2.3 内存抖动</h3>

<p>内存抖动一般指在很短的时间内发生了多次内存分配和释放，严重的内存抖动还会导致应用程序卡顿。内存抖动出现的原因主要是短时间频繁地创建对象(可能在循环中创建对象)，内存为了应对这种情况，也会频繁地进行GC。非并行GC在进行时，其他线程都会被挂起，等待GC操作完成后恢复工作。如果是频繁的GC就会产生大量的暂停时间，这会导致界面绘制时间减少，从而使得多次绘制一帧的时长超过了16ms， 产生的现象就是界面卡顿。综合起来就产生了内存抖动，产生了锯齿状的<br/>
抖动图。</p>

<h2 id="toc_7">17.3 Allocation Tracker</h2>

<h3 id="toc_8">17.3.1 使用Allocation Tracker</h3>

<h3 id="toc_9">17.3.2 alloc文件分析</h3>

<h2 id="toc_10">17.4 Heap Dump</h2>

<h3 id="toc_11">17.4.1 使用Heap Dump</h3>

<h3 id="toc_12">17.4.2 检测内存泄漏</h3>

<h2 id="toc_13">17.5 内存分析工具MAT</h2>

<h3 id="toc_14">17.5.1 生成hprof文件</h3>

<h3 id="toc_15">17.5.2 MAT分析hprof文件</h3>

<h2 id="toc_16">17.6 LeakCanary</h2>

<h3 id="toc_17">17.6.1 使用LeakCanary</h3>

<h3 id="toc_18">17.6.2 LeakCanary应用举例</h3>

<h2 id="toc_19">17.7 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html"><strong>开发艺术探索</strong></a>
        
            <a href="%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html"><strong>进阶之光</strong></a>
        
            <a href="%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html"><strong>进阶解密</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15789721660565.html">0 Android开发艺术探索-目录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15789731325545.html">0 Android进阶之光-目录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15789733843338.html">0 Android进阶解密-目录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15511960673056.html">01 Activity的生命周期和启动模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15536968610805.html">01 Android新特性</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
