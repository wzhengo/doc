<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  极客-数据结构与算法之美 - 
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html">Android开发艺术探索</a></li>
        
            <li><a href="Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html">Android进阶之光</a></li>
        
            <li><a href="Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html">Android进阶解密</a></li>
        
            <li><a href="Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html">Java核心技术</a></li>
        
            <li><a href="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA.html">深入理解虚拟机</a></li>
        
            <li><a href="%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html">极客-Java并发实战</a></li>
        
            <li><a href="%E6%9E%81%E5%AE%A2-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html">极客-深入拆解Java虚拟机</a></li>
        
            <li><a href="%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html">极客-数据结构与算法之美</a></li>
        
            <li><a href="%E8%8F%9C%E9%B8%9F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">菜鸟-设计模式</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15541287191079.html">
                
                  <h1>01 为什么要学习数据结构和算法？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><img src="media/15541287435641/15549789364139.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/04/01</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15541287435641.html">
                
                  <h1>02 如何抓住重点，系统高效地学习数据结构和算法？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">什么是数据结构？什么是算法？</h2>

<p>从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。</p>

<p>从狭义上讲，是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。</p>

<p>我们要讲的这些经典数据结构和算法，都是前人从很多实际操作场景中抽象出来的，可以高效地帮助我们解决很多实际的开发问题。</p>

<p><strong>那数据结构和算法有什么关系呢？</strong></p>

<p>数据结构和算法是相辅相成的。<strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上。</strong><br/>
比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。</p>

<h2 id="toc_1">学习的重点在什么地方？</h2>

<p>想要学习数据结构与算法，<strong>首先要掌握一个数据结构与算法中最重要的概念——复杂度分析。</strong></p>

<p>数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。</p>

<p>搞定复杂度分析，下面就要进入<strong>数据结构与算法的正文内容</strong>了。</p>

<p>其中包括20个最常用的、最基础数据结构与算法：</p>

<ul>
<li>数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；</li>
<li>算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</li>
</ul>

<p>在学习数据结构和算法的过程中，要注意学习它的<strong>“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”</strong>。</p>

<p>多辩证地思考，多问为什么。</p>

<h2 id="toc_2">学习技巧</h2>

<ol>
<li>边学边练，适度刷题</li>
<li>多问、多思考、多互动</li>
<li>给自己设立一个切实可行的目标</li>
<li>知识需要沉淀，不要想试图一下子掌握所有</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/04/01</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15541287799283.html">
                
                  <h1>03 复杂度分析上：如何分析、统计算法的还行效率和资源消耗？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">为什么需要复杂度分析？</h2>

<p>事后统计法的局限性：</p>

<ol>
<li>测试结果非常依赖测试环境</li>
<li>测试结果受数据规模的影响很大</li>
</ol>

<p>我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。这就是我们今天要讲的时间、空间复杂度分析方法。</p>

<h2 id="toc_1">大 O 复杂度表示法</h2>

<p>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。</p>

<p>大 O 时间复杂度表示法，表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，也叫作渐进时间复杂度，简称时间复杂度。</p>

<h2 id="toc_2">时间复杂度分析</h2>

<ol>
<li>只关注循环执行次数最多的一段代码</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ol>

<h2 id="toc_3">几种常见时间复杂度实例分析</h2>

<p><img src="media/15541288256392/15552535885967.jpg" alt=""/></p>

<p>粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p>

<p>下面是几种常见的多项式时间复杂度：</p>

<ol>
<li>O(1)
<ol>
<li>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</li>
</ol></li>
<li>O(logn)、O(nlogn)
<ol>
<li>在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。</li>
</ol></li>
<li>O(m+n)、O(m*n)
<ol>
<li>代码的复杂度由两个数据的规模来决定。</li>
</ol></li>
</ol>

<h2 id="toc_4">空间复杂度分析</h2>

<p>空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。</p>

<p>我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/04/01</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15541288256392.html">
                
                  <h1>04 复杂度分析下：浅析最好、最坏、平均、均摊时间复杂度</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>最好情况时间复杂度（best case time complexity）</li>
<li>最坏情况时间复杂度（worst case time complexity）</li>
<li>平均情况时间复杂度（average case time complexity）</li>
<li>均摊时间复杂度（amortized time complexity）</li>
</ul>

<p>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。<br/>
最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。</p>

<p>平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>，这个值是概率论中的<strong>加权平均值</strong>，也叫作<strong>期望值</strong>。</p>

<p>均摊时间复杂度就是一种特殊的平均时间复杂度。</p>

<p>大部分情况下，我们并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。 </p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/04/01</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15541288875308.html">
                
                  <h1>05 数组：为什么很多编程语言中数组都从0开始编号？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">如何实现随机访问？</h2>

<p>什么是数组？<strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p>

<p><strong>线性表</strong></p>

<p><strong>线性表</strong>（Linear List），顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p>

<p><img src="media/15541288875308/15554983702123.jpg" alt=""/></p>

<p>而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p>

<p><img src="media/15541288875308/15554984373245.jpg" alt=""/></p>

<p><strong>连续的内存空间和相同类型的数据</strong></p>

<p>数组支持<strong>随机访问</strong>，<strong>根据下标</strong>随机访问的时间复杂度为 O(1)。</p>

<p><img src="media/15541288875308/15555032746157.jpg" alt=""/></p>

<h2 id="toc_1">低效的“插入”和“删除”</h2>

<p><strong>插入操作：</strong></p>

<p>数组有序：</p>

<ul>
<li>如果在数组的<em>末尾</em>插入元素，需要移动数据，时间复杂度为 O(1)。</li>
<li>如果在数组的<em>开头</em>插入元素，所有的数据都需要依次往后移动一位，最坏时间复杂度是 O(n)。</li>
</ul>

<p>数组无序：</p>

<ul>
<li>直接将第k位的数据搬移到数组元素的最后；</li>
<li>把新的元素直接放入第k个位置。</li>
</ul>

<p><img src="media/15541288875308/15555036600604.jpg" alt=""/></p>

<p><strong>删除操作：</strong></p>

<p>跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据。</p>

<ul>
<li>如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；</li>
<li>如果删除开头的数据，则最坏情况时间复杂度为 O(n)；</li>
<li>平均情况时间复杂度也为 O(n)。</li>
</ul>

<p>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们<strong>将多次删除操作集中在一起执行</strong>，删除的效率是不是会提高很多呢？</p>

<p>我们继续来看例子。数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p>

<p><img src="media/15541288875308/15555043030984.jpg" alt=""/></p>

<p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p>

<p>如果你了解 JVM，你会发现，这不就是 <strong>JVM 标记清除垃圾回收算法</strong>的核心思想吗？没错，数据结构和算法的魅力就在于此，<strong>很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。</strong></p>

<h2 id="toc_2">警惕数组的访问越界问题</h2>

<p>在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。</p>

<p>访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。这种情况下，一般都会出现莫名其妙的逻辑错误。</p>

<p>Java会做越界检查，抛出 java.lang.ArrayIndexOutOfBoundsException。</p>

<h2 id="toc_3">容器能否完全替代数组？</h2>

<p>ArrayList的优势：</p>

<ol>
<li>就是<strong>可以将很多数组操作的细节封装起来</strong>，如数组插入、删除数据时的数据搬移操作。</li>
<li><strong>支持动态扩容</strong>
<ol>
<li>存储空间不够的时候，空间自动扩容为 1.5 倍大小。</li>
<li>扩容操作涉及内存申请和数据搬移，比较耗时，如果能事先确定数据大小，最好创建时指定。</li>
</ol></li>
</ol>

<p>以下情况用数组会更合适些：</p>

<ol>
<li>存储基本类型。比如 int、long，需要封装为 Integer、Long 类；而拆箱、装箱有一定的性能消耗，所以如果特别关注性能，就可以选用数组。</li>
<li>数据大小事先已知，数据操作非常简单，用不到ArrayList提供的大部分方法，也可以直接使用数组。</li>
<li>多维数组。</li>
</ol>

<p>总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p>

<h2 id="toc_4">解答开篇</h2>

<p>为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？</p>

<p>答：</p>

<ol>
<li><p>减少内存寻址运算。</p>
<ol>
<li>“下标”最确切的定义应该是“偏移”</li>
<li><p>如果下标为0，a[k]的内存地址计算公式为：</p>
<p><code>a[k]_address = base_address + k * type_size</code></p></li>
<li><p>如果下标为1，a[k]的内存地址计算公式为：</p>
<p><code>a[k]_address = base_address +(k-1)*type_size</code></p></li>
<li><p>如果从1开始编号，每次随机访问数组元素都多了一次减法运算。</p></li>
</ol></li>
<li><p>历史原因。</p>
<ol>
<li>C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言。</li>
<li>在一定程度上减少 C 语言程序员学习 Java 的学习成本。</li>
</ol></li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/04/01</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15541289308027.html">
                
                  <h1>06 链表上：如何实现LRU缓存淘汰算法？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>数组和链表的区别</strong></p>

<p>从底层的<strong>存储结构</strong>上看一下<code>数组</code>和<code>链表</code>的区别：</p>

<p>数组需要一块<strong>连续的内存空间</strong>来存储，对内存的要求比较高。<br/>
链表并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用。</p>

<p><img src="media/15541289308027/15556695598204.jpg" alt=""/></p>

<p>常见的链表结构：<code>单链表</code>、<code>双向链表</code>和<code>循环链表</code>。</p>

<p><strong>单链表</strong></p>

<p>链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“<strong>结点</strong>”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作<strong>后继指针next</strong>。</p>

<p>我们习惯性地把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。其中，头结点用来记录链表的基地址，尾结点指针指向一个<strong>空地址NULL</strong>。</p>

<p>链表的插入和删除操作，只需要考虑相邻结点的指针改变，所以对应的时间复杂度是O(1)。</p>

<p><img src="media/15541289308027/15558555696445.jpg" alt=""/></p>

<p>链表要想随机访问第k个元素，需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点，需要O(n)的时间复杂度。</p>

<p><strong>循环链表</strong></p>

<p>循环链表是一种特殊的单链表，它的<strong>尾结点指针是指向链表的头结点</strong>。</p>

<p><img src="media/15541289308027/15558560653047.jpg" alt=""/></p>

<p>和单链表相比，循环链表的优点是<strong>从链尾到链头</strong>比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。</p>

<p><strong>双向链表</strong></p>

<p>双向链表，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。</p>

<p><img src="media/15541289308027/15558562543394.jpg" alt=""/></p>

<p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。</p>

<p>双向链表适合解决哪种问题呢？</p>

<ul>
<li>从结构上来看，双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</li>
</ul>

<p>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p>

<ul>
<li>删除结点中“值等于某个给定值”的结点；</li>
<li>删除给定指针指向的结点。</li>
</ul>

<p>对于第一种情况，不管是单链表还是双向链表，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过指针操作将其删除。删除操作时间复杂度是O(1)，但遍历查找的时间复杂度为O(n)，所以总时间复杂度为O(n)。</p>

<p>对于第二种情况，因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要O(n)的时间复杂度，而双向链表只需要在O(1)的时间复杂度内！</p>

<p>插入同理。双向链表的按值查询的效率也要比单链表高一些。</p>

<p>LinkedHashMap其中就用到了双向链表。</p>

<p><strong>链表VS数组性能大比拼</strong></p>

<p><img src="media/15541289308027/15558570301462.jpg" alt=""/></p>

<p>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。</p>

<p>链表与数组最大的区别：</p>

<ul>
<li>数组的缺点是大小固定</li>
<li>链表本身没有大小的限制，天然地支持动态扩容。</li>
</ul>

<p><strong>解答开篇</strong><br/>
如何基于链表实现LRU缓存淘汰算法？</p>

<p>思路：<br/>
维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p>

<ol>
<li>如果此数据已经被缓存在链表中，遍历、删除这个数据对应的结点，然后再插入到链表头部。</li>
<li>如果此数据没有在缓存链表中，又可以分为两种情况：
<ol>
<li>缓存未满，插入到链表头部；</li>
<li>缓存已满，删除链表尾结点，将新数据结点插入链表头部。</li>
</ol></li>
</ol>

<p>因为需要遍历链表，所以时间复杂度为O(n)。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/04/01</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15541289575584.html">
                
                  <h1>07 链表下：如何轻松写出正确的链表代码？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>几个写链表代码技巧：</p>

<ol>
<li>技巧一：理解指针或引用的含义</li>
<li>技巧二：警惕指针丢失和内存泄漏</li>
<li>技巧三：利用哨兵简化实现难度</li>
<li>技巧四：重点留意边界条件处理</li>
<li>技巧五：举例画图，辅助思考</li>
<li>技巧六：多写多练，没有捷径</li>
</ol>

<p><strong>技巧一：理解指针或引用的含义</strong></p>

<p>指针：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p>

<p><strong>技巧二：警惕指针丢失和内存泄漏</strong></p>

<p>C语言中，插入结点时，一定要注意操作的顺序；删除链表结点时，一定要记得手动释放内存空间。</p>

<p><strong>技巧三：利用哨兵简化实现难度</strong></p>

<p>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。</p>

<p><strong>技巧四：重点留意边界条件处理</strong></p>

<p>常用来检查链表代码是否正确的边界条件有这样几个：</p>

<ul>
<li>如果链表为空时，代码是否能正常工作？</li>
<li>如果链表只包含一个结点时，代码是否能正常工作？</li>
<li>如果链表只包含两个结点时，代码是否能正常工作？</li>
<li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li>
</ul>

<p><strong>技巧五：举例画图，辅助思考</strong></p>

<p><strong>技巧六：多写多练，没有捷径</strong></p>

<p>常见的链表操作：</p>

<ul>
<li>单链表反转</li>
<li>链表中环的检测</li>
<li>两个有序的链表合并</li>
<li>删除链表倒数第n个结点</li>
<li>求链表的中间结点</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/04/01</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15541289870216.html">
                
                  <h1>08 栈：如何实现浏览器的前进和后退功能？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>如何理解“栈”？</strong></p>

<ul>
<li>后进者先出，先进者后出，这就是典型的“栈”结构。</li>
<li>从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。</li>
</ul>

<p>为什么还要用这个“操作受限”的“栈”呢？</p>

<ul>
<li>特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</li>
</ul>

<p><strong>如何实现一个“栈”？</strong></p>

<p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p>

<p>顺序栈和链式栈，时间、空间复杂度都是 O(1)。</p>

<p><strong>支持动态扩容的顺序栈</strong></p>

<ol>
<li>底层依赖一个支持动态扩容的数组</li>
<li>当栈满了之后，申请一个更大的数组，将原来的数据搬移到新数组中。</li>
</ol>

<p><img src="media/15541289870216/15565401658387.jpg" alt=""/></p>

<ul>
<li><code>出栈</code>的时间复杂度仍然是 O(1)。</li>
<li><code>入栈</code>操作：当栈中有空闲空间，入栈操作的时间复杂度为 O(1)；空间不够时，需要重新申请内存和数据搬移，时间复杂度为O(n)。</li>
<li>平均情况下的耗时接近O(1)</li>
</ul>

<p><strong>栈在函数调用中的应用</strong></p>

<p><code>函数调用栈</code>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>

<p><strong>栈在表达式求值中的应用</strong></p>

<ol>
<li>编译器就是通过两个栈来实现的。其中一个<strong>保存操作数</strong>的栈，另一个是<strong>保存运算符</strong>的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</li>
<li>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</li>
</ol>

<p><img src="media/15541289870216/15565407969721.jpg" alt=""/></p>

<p><strong>栈在括号匹配中的应用</strong></p>

<p>借助栈来检查表达式中的括号是否匹配：</p>

<p>用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p>

<p><strong>解答开篇</strong></p>

<p>如何实现浏览器的前进、后退功能？</p>

<p>我们使用两个栈，X和Y，我们把首次浏览的页面依次压入栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据依次放入栈Y。当我们点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，那就说明没有页面可以继续后退浏览了。当栈Y中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/04/01</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15541290210444.html">
                
                  <h1>09 队列：队列在线程池等优先资源池中的应用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>CPU资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致CPU频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p>

<p>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</p>

<p><strong>如何理解“队列”？</strong></p>

<p>你可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。<strong>先进者先出，这就是典型的“队列”。</strong></p>

<p>栈只支持两个基本操作：入栈push()和出栈pop()。</p>

<p>队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：</p>

<ul>
<li><strong>入队</strong>enqueue()，放一个数据到队列尾部；</li>
<li><strong>出队</strong>dequeue()，从队列头部取一个元素。</li>
</ul>

<p><img src="media/15541290210444/15579173042687.jpg" alt=""/></p>

<p>队列跟栈一样，也是一种<strong>操作受限的线性表数据结构</strong>。</p>

<p>队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。比如高性能队列Disruptor、Linux环形缓存，都用到了循环并发队列；Javaconcurrent并发包利用ArrayBlockingQueue来实现公平锁等。</p>

<p><strong>顺序队列和链式队列</strong></p>

<p>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p>

<p>对于栈来说，我们只需要一个栈顶指针就可以了。但是队列需要两个指针：一个是<strong>head</strong>指针，指向队头；一个是<strong>tail</strong>指针，指向队尾。</p>

<p>a b c d 入队：<br/>
<img src="media/15541290210444/15579192979223.jpg" alt=""/></p>

<p>a b 出队：<br/>
<img src="media/15541290210444/15579193044779.jpg" alt=""/></p>

<p>随着不停地进行入队、出队操作，head和tail都会持续往后移动。当tail移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这个问题该如何解决呢？</p>

<p>答：<strong>数据搬移</strong></p>

<p><img src="media/15541290210444/15579193852852.jpg" alt=""/></p>

<p><strong>基于链表的队列实现方法</strong></p>

<p><img src="media/15541290210444/15579194168528.jpg" alt=""/></p>

<p><strong>循环队列</strong></p>

<p>循环队列的代码实现难度要比前面讲的非循环队列难多了，最关键的是，<strong>确定好队空和队满的判定条件</strong>。</p>

<ul>
<li>队空时：head==tail；</li>
<li>队满时：(tail+1)%n=head。</li>
</ul>

<p>当队列满时，图中的tail指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。</p>

<p><img src="media/15541290210444/15579197398803.jpg" alt=""/></p>

<p><strong>阻塞队列和并发队列</strong></p>

<p>阻塞队列其实就是在队列基础上增加了<strong>阻塞操作</strong>。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>

<p><img src="media/15541290210444/15579198293618.jpg" alt=""/></p>

<p>这种基于阻塞队列实现的“生产者-消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p>

<p>而且不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。</p>

<p><img src="media/15541290210444/15579198615206.jpg" alt=""/></p>

<p>在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢？</p>

<p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在enqueue()、dequeue()方法上<strong>加锁</strong>，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。在实战篇讲Disruptor的时候，我会再详细讲并发队列的应用。</p>

<p><strong>解答开篇</strong></p>

<p>线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</p>

<p>我们一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。</p>

<p><code>那如何存储排队的请求呢？</code></p>

<p>我们希望公平地处理每个排队的请求，先进者先服务，所以<strong>队列</strong>这种数据结构很适合来存储排队请求。</p>

<p>我们前面说过，队列有基于链表和基于数组这两种实现方式。<code>这两种实现方式对于排队请求又有什么区别呢？</code></p>

<p>基于链表的实现方式，可以实现一个<strong>支持无限排队</strong>的无界队列（unboundedqueue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</p>

<p>而基于数组实现的有界队列（boundedqueue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</p>

<p>除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。<strong>实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/04/01</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15541290614714.html">
                
                  <h1>10 递归：如何用三行代码找到“最终推荐人”？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>如何理解递归？</strong></p>

<p>递归是一种应用非常广泛的算法（或者编程技巧），数据结构和算法的编码实现都要用到递归，比如DFS深度优先搜索、前中后序二叉树遍历等等。</p>

<p>递归需要满足的三个条件：</p>

<ol>
<li>一个问题的解可以分解为几个子问题的解</li>
<li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li>
<li>存在递归终止条件</li>
</ol>

<p><em>如何编写递归代码？</em><br/>
<strong>写出递推公式，找到终止条件</strong><br/>
写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</p>

<p><em>理解起来比较吃力？</em><br/>
把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</p>

<p><strong>递归代码要警惕堆栈溢出</strong></p>

<p><em>为什么递归代码容易造成堆栈溢出呢？</em><br/>
函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>

<p><em>如何预防堆栈溢出呢？</em></p>

<ol>
<li>我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如1000）之后，我们就不继续往下再递归了，直接返回报错。</li>
<li>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如10、50，就可以用这种方法，否则这种方法并不是很实用。</li>
</ol>

<p><strong>递归代码要警惕重复计算</strong><br/>
<img src="media/15541290614714/15584350100246.jpg" alt=""/></p>

<p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的f(k)。当递归调用到f(k)时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p>

<p><strong>其他问题</strong><br/>
在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。</p>

<p><strong>可以将递归代码改为迭代循环的非递归写法</strong></p>

<p><em>对于递归代码，你有什么好的调试方法呢？</em></p>

<ol>
<li>打印日志发现，递归值。</li>
<li>结合条件断点进行调试。</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/04/01</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15580895004658.html">
                
                  <h1>11 排序上：为什么插入排序比冒泡排序更受欢迎？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。</p>

<p><img src="media/15580895004658/15722496250641.jpg" alt=""/></p>

<h4 id="toc_0">如何分析一个“排序算法”？</h4>

<ol>
<li>排序算法的执行效率
<ol>
<li>最好情况、最坏情况、平均情况时间复杂度</li>
<li>时间复杂度的系数、常数 、低阶</li>
<li>比较次数和交换（或移动）次数</li>
</ol></li>
<li>排序算法的内存消耗</li>
<li>排序算法的稳定性</li>
</ol>

<p><code>原地排序</code>算法，就是特指空间复杂度是 O(1) 的排序算法。</p>

<p><code>稳定性</code>：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>

<h4 id="toc_1">冒泡排序（Bubble Sort）</h4>

<p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>

<p><img src="media/15580895004658/15722502869685.jpg" alt=""/></p>

<p>经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。</p>

<pre><code class="language-text">// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n &lt;= 1) return;
 
 for (int i = 0; i &lt; n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j &lt; n - i - 1; ++j) {
      if (a[j] &gt; a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
</code></pre>

<p><strong>有序度</strong>：数组中具有有序关系的元素对的个数。<code>满有序度</code>:完全有序。<br/>
<strong>逆序度</strong>：逆序度的定义正好跟有序度相反。<br/>
<strong>逆序度 = 满有序度 - 有序度</strong><br/>
我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。</p>

<p>冒泡排序包含两个操作原子，<code>比较</code>和<code>交换</code>。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是<code>n*(n-1)/2–初始有序度</code>。</p>

<h4 id="toc_2">插入排序</h4>

<p>一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。</p>

<p><em>插入排序具体是如何借助上面的思想来实现排序的呢？</em></p>

<p>我们将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p>

<p><img src="media/15580895004658/15724183953801.jpg" alt=""/></p>

<p>插入排序也包含两种操作，一种是<strong>元素的比较</strong>，一种是<strong>元素的移动</strong>。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。</p>

<p>对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。</p>

<pre><code class="language-text">// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n &lt;= 1) return;

  for (int i = 1; i &lt; n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j &gt;= 0; --j) {
      if (a[j] &gt; value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
</code></pre>

<h4 id="toc_3">选择排序</h4>

<p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>

<p><img src="media/15580895004658/15724256632913.jpg" alt=""/></p>

<h4 id="toc_4">解答开篇</h4>

<blockquote>
<p>问：冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？</p>

<p>答：冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。</p>
</blockquote>

<h4 id="toc_5">总结</h4>

<p><img src="media/15580895004658/15724287421994.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/05/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15580895382477.html">
                
                  <h1>12 排序下：如何用快排思想在O(n)内查找第K大元素？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>归并排序和快速排序都用到了分治思想。</p>

<h4 id="toc_0">归并排序的原理</h4>

<p>如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>

<p><img src="media/15580895382477/15725218517564.jpg" alt=""/></p>

<p>归并排序使用的就是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p>

<p>分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧。</strong></p>

<p>归并排序的递推公式和终止条件：</p>

<pre><code class="language-text">递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

终止条件：
p &gt;= r 不用再继续分解
</code></pre>

<p>伪代码：</p>

<pre><code class="language-text">// 归并排序算法, A是数组，n表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p &gt;= r  then return

  // 取p到r之间的中间位置q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  // 将A[p...q]和A[q+1...r]合并为A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}
</code></pre>

<p>merge()函数过程和伪代码</p>

<p><img src="media/15580895382477/15725262135069.jpg" alt=""/></p>

<pre><code class="language-text">merge(A[p...r], A[p...q], A[q+1...r]) {
  var i := p，j := q+1，k := 0 // 初始化变量i, j, k
  var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组
  while i&lt;=q AND j&lt;=r do {
    if A[i] &lt;= A[j] {
      tmp[k++] = A[i++] // i++等于i:=i+1
    } else {
      tmp[k++] = A[j++]
    }
  }
  
  // 判断哪个子数组中有剩余的数据
  var start := i，end := q
  if j&lt;=r then start := j, end:=r
  
  // 将剩余的数据拷贝到临时数组tmp
  while start &lt;= end do {
    tmp[k++] = A[start++]
  }
  
  // 将tmp中的数组拷贝回A[p...r]
  for i:=0 to r-p do {
    A[p+i] = tmp[i]
  }
}
</code></pre>

<h4 id="toc_1">归并排序的性能分析</h4>

<ul>
<li>归并排序是一个稳定的排序算法</li>
<li>归并排序的时间复杂度是O(nlogn)</li>
<li>归并排序的空间复杂度是O(n)</li>
</ul>

<p>缺点：归并排序不是原地排序算法。</p>

<h4 id="toc_2">快速排序的原理</h4>

<p>如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。</p>

<p>根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。</p>

<p><img src="media/15580895382477/15726007685737.jpg" alt=""/></p>

<p>递推公式和终止条件：</p>

<pre><code class="language-text">递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)

终止条件：
p &gt;= r
</code></pre>

<p>伪代码：</p>

<pre><code class="language-text">// 快速排序，A是数组，n表示数组的大小
quick_sort(A, n) {
  quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r为下标
quick_sort_c(A, p, r) {
  if p &gt;= r then return
  
  q = partition(A, p, r) // 获取分区点
  quick_sort_c(A, p, q-1)
  quick_sort_c(A, q+1, r)
}
</code></pre>

<p>原地分区函数partition()伪代码：</p>

<pre><code class="language-text">partition(A, p, r) {
  pivot := A[r]
  i := p
  for j := p to r-1 do {
    if A[j] &lt; pivot {
      swap A[i] with A[j]
      i := i+1
    }
  }
  swap A[i] with A[r]
  return i
</code></pre>

<p>过程如图：</p>

<p><img src="media/15580895382477/15726017538109.jpg" alt=""/></p>

<h4 id="toc_3">快速排序的性能分析</h4>

<ul>
<li>快排是一种原地、不稳定的排序算法。</li>
<li>时间复杂度最差情况：T(n) = O(n2)；平均情况：T(n) = O(nlogn)。</li>
</ul>

<h4 id="toc_4">归并排序和快速排序的异同：</h4>

<p><img src="media/15580895382477/15728621133857.jpg" alt=""/></p>

<ul>
<li>归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。</li>
<li>而快排正好相反，它的处理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。</li>
<li>归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。</li>
<li>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</li>
</ul>

<h4 id="toc_5">内容小结</h4>

<ul>
<li>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和 merge() 合并函数。同理，理解快排的重点也是理解递推公式，还有 partition() 分区函数。</li>
<li>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此，它也没有快排应用广泛。</li>
<li>快速排序算法虽然最坏情况下的时间复杂度是 O(n2)，但是平均情况下时间复杂度都是 O(nlogn)。不仅如此，快速排序算法时间复杂度退化到 O(n2) 的概率非常小，我们可以通过合理地选择 pivot 来避免这种情况。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/05/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15580898258498.html">
                
                  <h1>13 线性排序：如何根据年龄给100万用户数据排序？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>三种时间复杂度是 O(n)：桶排序、计数排序、基数排序。<br/>
因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作<strong>线性排序</strong>。</p>

<p><strong>今天学习重点的是掌握这些排序算法的适用场景。</strong></p>

<h4 id="toc_0">桶排序（Bucket sort）</h4>

<p>首先，我们来看桶排序。桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>

<p><img src="media/15580898258498/15729470016977.jpg" alt=""/></p>

<p><strong>桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？</strong></p>

<p>答案当然是否定的。桶排序对要排序数据的要求是非常苛刻的。</p>

<ul>
<li>首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</li>
<li>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。</li>
</ul>

<p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>

<h4 id="toc_1">计数排序（Counting sort）</h4>

<p><strong>计数排序其实是桶排序的一种特殊情况。</strong><br/>
当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。<mark>每个桶内的数据值都是相同的</mark>，省掉了桶内排序的时间。</p>

<p><img src="media/15580898258498/15729539018465.gif" alt=""/></p>

<p><strong>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</strong></p>

<h4 id="toc_2">基数排序（Radix sort）</h4>

<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>

<p><img src="media/15580898258498/15729542399654.gif" alt=""/></p>

<p><strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/05/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15580898531467.html">
                
                  <h1>14 排序优化：如何实现一个通用的、高性能的排序函数？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4 id="toc_0">如何选择合适的排序算法？</h4>

<p><img src="media/15580898531467/15730337107427.jpg" alt=""/></p>

<ol>
<li>线性排序算法的时间复杂度比较低，适用场景比较特殊，所以不能选择线性排序算法。</li>
<li>为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。</li>
<li>归并排序并不是原地排序算法，空间复杂度是 O(n)。</li>
<li>所以快速排序比较适合来实现排序函数。</li>
</ol>

<p>但是，快速排序在最坏情况下的时间复杂度是 O(n²)，如何来解决这个“复杂度恶化”的问题呢？</p>

<h4 id="toc_1">如何优化快速排序？</h4>

<p>为什么最坏情况下快速排序的时间复杂度是 O(n²) 呢？<br/>
如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，时间复杂度就会退化为 O(n²)。** O(n²) 时间复杂度出现的主要原因还是因为我们分区点选的不够合理。**</p>

<p><em>如何来选择分区点呢？</em></p>

<p>最理想的分区点是：<strong>被分区点分开的两个分区中，数据的数量差不多。</strong></p>

<p><strong>1. 三数取中法</strong></p>

<p>我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p>

<p><strong>2. 随机法</strong></p>

<p>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选的很差的情况，所以平均情况下，这样选的分区点是比较好的。</p>

<p><em>防止快速排序递归的堆栈溢出：</em></p>

<ol>
<li>第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归。</li>
<li>第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</li>
</ol>

<p>在小规模数据面前，O(n²) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。<br/>
解释：在大 O 复杂度表示法中，我们会省略低阶、系数和常数，也就是说，O(nlogn) 在没有省略低阶、系数、常数之前可能是 O(knlogn + c)，而且 k 和 c 有可能还是一个比较大的数。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/05/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15580898794579.html">
                
                  <h1>15 二分查找上：如何用最省内存的方式实现快速查找功能？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4 id="toc_0">二分思想</h4>

<p>随机写一个 0 到 99 之间的数字，然后你来猜我写的是什么。假设我写的数字是 23，你可以按照下面的步骤来试一试。</p>

<p><img src="media/15580898794579/15731294280646.jpg" alt=""/></p>

<p><strong>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</strong></p>

<p>时间复杂度就是 O(logn)，它是<strong>对数时间复杂度</strong>。</p>

<h4 id="toc_1">二分查找的递归与非递归实现</h4>

<p>最简单的情况就是<strong>有序数组中不存在重复元素</strong>，我们在其中用二分查找值等于给定值的数据。</p>

<pre><code class="language-text">public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;

  while (low &lt;= high) {
    int mid = (low + high) / 2;
    if (a[mid] == value) {
      return mid;
    } else if (a[mid] &lt; value) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }

  return -1;
}
</code></pre>

<p><strong>容易出错的 3 个地方</strong></p>

<ol>
<li>循环退出条件
<ul>
<li>注意是 low&lt;=high，而不是 low&lt;high。 </li>
</ul></li>
<li>mid 的取值
<ol>
<li>mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。</li>
<li>如果要将性能优化到极致的话，可以将除以 2 操作转化成位运算 low+((high-low)&gt;&gt;1)。因为相比除法运算来说，计算机处理位运算要快得多。</li>
</ol></li>
<li>low 和 high 的更新
<ul>
<li>low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3] 不等于 value，就会导致一直循环不退出 </li>
</ul></li>
</ol>

<p>递归实现：</p>

<pre><code class="language-text">// 二分查找的递归实现
public int bsearch(int[] a, int n, int val) {
  return bsearchInternally(a, 0, n - 1, val);
}

private int bsearchInternally(int[] a, int low, int high, int value) {
  if (low &gt; high) return -1;

  int mid =  low + ((high - low) &gt;&gt; 1);
  if (a[mid] == value) {
    return mid;
  } else if (a[mid] &lt; value) {
    return bsearchInternally(a, mid+1, high, value);
  } else {
    return bsearchInternally(a, low, mid-1, value);
  }
}
</code></pre>

<h4 id="toc_2">二分查找应用场景的局限性</h4>

<ul>
<li><strong>首先，二分查找依赖的是顺序表结构，简单点说就是数组。</strong>
<ul>
<li>其他数据结构存储的，无法应用二分查找。</li>
</ul></li>
<li><strong>其次，二分查找针对的是有序数据。</strong>
<ul>
<li>如果有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。维护有序的成本都是很高的。</li>
</ul></li>
<li><strong>再次，数据量太小不适合二分查找。</strong></li>
<li><strong>最后，数据量太大也不适合二分查找。</strong>
<ul>
<li>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。</li>
</ul></li>
</ul>

<h4 id="toc_3">解答开篇</h4>

<p><strong>如何在 1000 万个整数中快速查找某个整数？</strong></p>

<p>我们的内存限制是 100MB，每个数据大小是 8 字节，最简单的办法就是将数据存储在数组中，内存占用差不多是 80MB，符合内存的限制。我们可以先对这 1000 万数据从小到大排序，然后再利用二分查找算法，就可以快速地查找想要的数据了。</p>

<p>注意，虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是，不管是散列表还是二叉树，都会<strong>需要比较多的额外的内存空间</strong>。如果用散列表或者二叉树来存储这 1000 万的数据，用 100MB 的内存肯定是存不下的。而二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式，所以刚好能在限定的内存大小下解决这个问题。</p>

<h4 id="toc_4">内容小结</h4>

<p>今天我们学习了一种针对有序数据的高效查找算法，二分查找，它的时间复杂度是 O(logn)。</p>

<p>二分查找的核心思想理解起来非常简单，有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找的区间缩小为一半，直到找到要查找的元素，或者区间被缩小为 0。但是二分查找的代码实现比较容易写错。你需要着重掌握它的三个容易出错的地方：循环退出条件、mid 的取值，low 和 high 的更新。</p>

<p>二分查找虽然性能比较优秀，但应用场景也比较有限。底层必须依赖数组，并且还要求数据是有序的。对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/05/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15580899097146.html">
                
                  <h1>16 二分查找下：如何快速定位IP对应的省份地址？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>“十个二分九个错”。二分查找虽然原理极其简单，但是想要写出没有 Bug 的二分查找并不容易。</p>

<p><img src="media/15580899097146/15735522642575.jpg" alt=""/></p>

<h4 id="toc_0">变体一：查找第一个值等于给定值的元素</h4>

<p>比如下面这样一个有序数组，其中，a[5]，a[6]，a[7] 的值都等于 8，是重复的数据。我们希望查找第一个等于 8 的数据，也就是下标是 5 的元素。如果我们用上一节课讲的二分查找的代码实现，首先拿 8 与区间的中间值 a[4] 比较，8 比 6 大，于是在下标 5 到 9 之间继续查找。下标 5 和 9 的中间位置是下标 7，a[7] 正好等于 8，所以代码就返回了。</p>

<p><img src="media/15580899097146/15735524562038.jpg" alt=""/></p>

<p>代码实现：</p>

<pre><code class="language-text">public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low &lt;= high) {
    int mid =  low + ((high - low) &gt;&gt; 1);
    if (a[mid] &gt; value) {
      high = mid - 1;
    } else if (a[mid] &lt; value) {
      low = mid + 1;
    } else {
      if ((mid == 0) || (a[mid - 1] != value)) return mid;
      else high = mid - 1;
    }
  }
  return -1;
}
</code></pre>

<p>很多人都觉得变形的二分查找很难写，主要原因是太追求第一种那样完美、简洁的写法。</p>

<h4 id="toc_1">变体二：查找最后一个值等于给定值的元素</h4>

<pre><code class="language-text">public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low &lt;= high) {
    int mid =  low + ((high - low) &gt;&gt; 1);
    if (a[mid] &gt; value) {
      high = mid - 1;
    } else if (a[mid] &lt; value) {
      low = mid + 1;
    } else {
      if ((mid == n - 1) || (a[mid + 1] != value)) return mid;
      else low = mid + 1;
    }
  }
  return -1;
}
</code></pre>

<h4 id="toc_2">变体三：查找第一个大于等于给定值的元素</h4>

<pre><code class="language-text">public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low &lt;= high) {
    int mid =  low + ((high - low) &gt;&gt; 1);
    if (a[mid] &gt;= value) {
      if ((mid == 0) || (a[mid - 1] &lt; value)) return mid;
      else high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return -1;
}
</code></pre>

<h4 id="toc_3">变体四：查找最后一个小于等于给定值的元素</h4>

<pre><code class="language-text">public int bsearch7(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low &lt;= high) {
    int mid =  low + ((high - low) &gt;&gt; 1);
    if (a[mid] &gt; value) {
      high = mid - 1;
    } else {
      if ((mid == n - 1) || (a[mid + 1] &gt; value)) return mid;
      else low = mid + 1;
    }
  }
  return -1;
}
</code></pre>

<h4 id="toc_4">解答开篇</h4>

<p><strong>如何快速定位出一个 IP 地址的归属地？</strong></p>

<ol>
<li>排序。IP 地址可以转化为 32 位的整型数。将起始地址，按照对应的整型值的大小关系，从小到大进行排序。</li>
<li>二分查找，在有序数组中，查找最后一个小于等于某个给定值的元素。</li>
</ol>

<h4 id="toc_5">内容小结</h4>

<p>上一节我说过，凡是用二分查找能解决的，绝大部分我们更倾向于用散列表或者二叉查找树。即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。那二分查找真的没什么用处了吗？</p>

<p>实际上，上一节讲的求“值等于给定值”的二分查找确实不怎么会被用到，二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。比如今天讲的这几种变体问题，用其他数据结构，比如散列表、二叉树，就比较难实现了。</p>

<p>变体的二分查找算法写起来非常烧脑，很容易因为细节处理不好而产生 Bug，这些容易出错的细节有：<strong>终止条件、区间上下界更新方法、返回值选择</strong>。所以今天的内容你最好能用自己实现一遍，对锻炼编码能力、逻辑思维、写出 Bug free 代码，会很有帮助。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/05/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15580899335621.html">
                
                  <h1>17 跳表：为什么Redis一定要用跳表来实现有序集合？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>我们只需要对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫作跳表（Skip list）。</p>

<p>跳表是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树（Red-black tree）。</p>

<h4 id="toc_0">如何理解“跳表”？</h4>

<p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p>

<p><img src="media/15580899335621/15736454641989.jpg" alt=""/></p>

<p>如果像图中那样，对链表建立一级“索引”，查找起来是不是就会更快一些呢？每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引或索引层。</p>

<p><img src="media/15580899335621/15736454728957.jpg" alt=""/></p>

<p>原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。</p>

<p><strong>加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了。</strong></p>

<p>例子2：</p>

<p><img src="media/15580899335621/15736455727076.jpg" alt=""/></p>

<p>原来没有索引的时候，查找 62 需要遍历 62 个结点，现在只需要遍历 11 个结点。</p>

<p><strong>这种链表加多级索引的结构，就是跳表。</strong></p>

<h4 id="toc_1">用跳表查询到底有多快？</h4>

<p>跳表中查询任意数据的时间复杂度就是 O(logn)。这个查找的时间复杂度跟二分查找是一样的。</p>

<h4 id="toc_2">跳表是不是很浪费内存？</h4>

<p>跳表的空间复杂度是 O(n)。</p>

<p>在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。</p>

<h4 id="toc_3">高效的动态插入和删除</h4>

<p>跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。</p>

<h4 id="toc_4">跳表索引动态更新</h4>

<p>当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p>

<p><img src="media/15580899335621/15736463549380.jpg" alt=""/></p>

<p>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p>

<p>跳表是通过随机函数来维护前面提到的“平衡性”。</p>

<p>我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。</p>

<p><img src="media/15580899335621/15736467171093.jpg" alt=""/></p>

<h4 id="toc_5">解答开篇</h4>

<p><strong>为什么 Redis 要用跳表来实现有序集合，而不是红黑树？</strong></p>

<ol>
<li>Redis 中的有序集合是通过跳表来实现的</li>
<li>Redis 中的有序集合支持的核心操作主要有下面这几个：插入一个数据；删除一个数据；查找一个数据；按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；迭代输出有序序列。</li>
<li>按照区间来查找数据这个操作，红黑树的效率没有跳表高。对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。</li>
<li>其他原因，比如，跳表更容易代码实现。跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</li>
</ol>

<h4 id="toc_6">内容小结</h4>

<p>今天我们讲了跳表这种数据结构。跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 O(logn)。</p>

<p>跳表的空间复杂度是 O(n)。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/05/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15580899548602.html">
                
                  <h1>18散列表上：Word文档中的单词拼写检查功能是如何实现的？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4 id="toc_0">散列思想</h4>

<p>散列表的英文叫“HashTable”，我们平时也叫它“哈希表”或者“Hash表”。<br/>
<strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。</strong></p>

<p>参赛选手的编号我们叫作<strong>键</strong>（key）或者<strong>关键字</strong>。我们用它来标识一个选手。我们把参赛编号转化为数组下标的映射方法就叫作<strong>散列函数</strong>（或“Hash函数”“哈希函数”），而散列函数计算得到的值就叫作<strong>散列值</strong>（或“Hash值”“哈希值”）。</p>

<p><img src="media/15580899548602/15738116045089.jpg" alt=""/></p>

<p>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p>

<h4 id="toc_1">散列函数</h4>

<p>散列函数，顾名思义，它是一个函数。我们可以把它定义成<strong>hash(key)</strong>，其中key表示元素的键值，hash(key)的值表示经过散列函数计算得到的散列值。</p>

<p><strong>该如何构造散列函数呢？我总结了三点散列函数设计的基本要求：</strong></p>

<ol>
<li>散列函数计算得到的散列值是一个非负整数；</li>
<li>如果key1=key2，那hash(key1)==hash(key2)；</li>
<li>如果key1≠key2，那hash(key1)≠hash(key2)。</li>
</ol>

<p>第三点说明：这个要求看起来合情合理，但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的<code>MD5</code>、<code>SHA</code>、<code>CRC</code>等哈希算法，也无法完全避免这种<strong>散列冲突</strong>。而且，因为数组的存储空间有限，也会加大散列冲突的概率。</p>

<p>所以我们几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，我们需要通过其他途径来解决。</p>

<h4 id="toc_2">散列冲突</h4>

<p>如何解决散列冲突问题呢？我们常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。</p>

<p><strong>1. 开放寻址法</strong></p>

<p>开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。</p>

<p>那如何重新探测新的位置呢？我先讲一个比较简单的探测方法，<strong>线性探测</strong>（Linear Probing）。<br/>
当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置；如果遍历到尾部都没有找到空闲的位置，就从表头开始找，直到找到为止。</p>

<p>对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。<br/>
在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？<br/>
我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p>

<p>线性探测法的问题：当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。</p>

<p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，<strong>二次探测</strong>（Quadratic probing）和<strong>双重散列</strong>（Double hashing）。</p>

<p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……</p>

<p>所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p>

<p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用<strong>装载因子</strong>（load factor）来表示空位的多少。</p>

<p>装载因子的计算公式是：</p>

<pre><code class="language-text">散列表的装载因子=填入表中的元素个数/散列表的长度
</code></pre>

<p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p>

<p><strong>2. 链表法</strong></p>

<p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>

<p><img src="media/15580899548602/15738797287694.jpg" alt=""/></p>

<p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？</p>

<p>实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。</p>

<h4 id="toc_3">解答开篇</h4>

<p><strong>Word 文档中单词拼写检查功能是如何实现的？</strong></p>

<p>常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。</p>

<p>当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</p>

<h4 id="toc_4">内容小结</h4>

<p>今天我讲了一些比较基础、比较偏理论的散列表知识，包括散列表的由来、散列函数、散列冲突的解决方法。</p>

<p>散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。散列表两个核心问题是<strong>散列函数设计</strong>和<strong>散列冲突解决</strong>。散列冲突有两种常用的解决方法，开放寻址法和链表法。散列函数设计的好坏决定了散列冲突的概率，也就决定散列表的性能。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/05/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15580899931681.html">
                
                  <h1>19 散列表中：如何打造一个工业级水平的散列表？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4 id="toc_0">如何设计散列函数？</h4>

<p>首先，<strong>散列函数的设计不能太复杂</strong>。过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能。其次，<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突。</p>

<p>实际工作中，我们还需要综合考虑各种因素。这些因素有关键字的长度、特点、分布、还有散列表的大小等。散列函数各式各样，我举几个常用的、简单的散列函数的设计方法，让你有个直观的感受。</p>

<p>第一个例子就是我们上一节的学生运动会的例子，我们通过分析参赛编号的特征，把编号中的后两位作为散列值。我们还可以用类似的散列函数处理手机号码，因为手机号码前几位重复的可能性很大，但是后面几位就比较随机，我们可以取手机号的后四位作为散列值。这种散列函数的设计方法，我们一般叫作“数据分析法”。<br/>
第二个例子就是上一节的开篇思考题，如何实现 Word 拼写检查功能。这里面的散列函数，我们就可以这样设计：将单词中每个字母的ASCll 码值“进位”相加，然后再跟散列表的大小求余、取模，作为散列值。<br/>
实际上，散列函数的设计方法还有很多，比如直接寻址法、平方取中法、折叠法、随机数法等。</p>

<h4 id="toc_1">装载因子过大了怎么办？</h4>

<p>针对散列表，当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。</p>

<h4 id="toc_2">如何避免低效地扩容？</h4>

<p>我举一个极端的例子，如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表，听起来就很耗时，是不是？</p>

<p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</p>

<p>当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。</p>

<p>这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。</p>

<h4 id="toc_3">如何选择冲突解决方法？</h4>

<p>开放寻址法和链表法有什么优势和劣势，又各自适用哪些场景？</p>

<ul>
<li><strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。</strong></li>
<li><strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</strong></li>
</ul>

<h4 id="toc_4">工业级散列表举例分析</h4>

<p>举例：Java 中的 HashMap 这样一个工业级的散列表，来具体看下，这些技术是怎么应用的。</p>

<p><strong>1.初始大小HashMap</strong> <br/>
默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。</p>

<p><strong>2.装载因子和动态扩容</strong><br/>
最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p>

<p><strong>3.散列冲突解决方法</strong><br/>
HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。<br/>
于是，在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。</p>

<p><strong>4.散列函数</strong><br/>
散列函数的设计并不复杂，追求的是简单高效、分布均匀。</p>

<h4 id="toc_5">解答开篇</h4>

<p><strong>如何设计的一个工业级的散列函数？</strong></p>

<ol>
<li><strong>何为一个工业级的散列表？工业级的散列表应该具有哪些特性？</strong>
<ul>
<li>支持快速的查询、插入、删除操作；</li>
<li>内存占用合理，不能浪费过多的内存空间；</li>
<li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。 </li>
</ul></li>
<li><strong>如何实现这样一个散列表呢？</strong>
<ul>
<li>设计一个合适的散列函数；</li>
<li>定义装载因子阈值，并且设计动态扩容策略；</li>
<li>选择合适的散列冲突解决方法。</li>
</ul></li>
</ol>

<h4 id="toc_6">内容小结</h4>

<p>上一节的内容比较偏理论，今天的内容侧重实战。我主要讲了如何设计一个工业级的散列表，以及如何应对各种异常情况，防止在极端情况下，散列表的性能退化过于严重。我分了三部分来讲解这些内容，分别是：如何设计散列函数，如何根据装载因子动态扩容，以及如何选择散列冲突解决方法。</p>

<p>关于散列函数的设计，我们要尽可能让散列后的值随机且均匀分布，这样会尽可能地减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响散列表的性能。</p>

<p>关于散列冲突解决方法的选择，我对比了开放寻址法和链表法两种方法的优劣和适应的场景。大部分情况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树，来避免散列表时间复杂度退化成 O(n)，抵御散列碰撞攻击。但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。</p>

<p>对于动态散列表来说，不管我们如何设计散列函数，选择什么样的散列冲突解决方法。随着数据的不断增加，散列表总会出现装载因子过高的情况。这个时候，我们就需要启动动态扩容。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/05/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15580900101811.html">
                
                  <h1>20 散列表下：为什么散列表和链表经常一起使用？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4 id="toc_0">LRU 缓存淘汰算法</h4>

<p>一个缓存（cache）系统主要包含下面这几个操作：</p>

<ul>
<li>往缓存中添加一个数据；</li>
<li>从缓存中删除一个数据；</li>
<li>在缓存中查找一个数据。</li>
</ul>

<p>这三个操作都要涉及“查找”操作，如果单纯地采用链表的话，时间复杂度只能是 O(n)。如果我们将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 O(1)。具体的结构就是下面这个样子：</p>

<p><img src="media/15580900101811/15740687332020.jpg" alt=""/></p>

<p>散列表通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的<strong>双向链表</strong>，另一个链是散列表中的<strong>拉链</strong>。<strong>前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。</strong></p>

<ol>
<li>首先，我们来看<strong>如何查找一个数据</strong>。
<ol>
<li>散列表中查找数据的时间复杂度接近 O(1)，所以通过散列表，我们可以很快地在缓存中找到一个数据。</li>
<li>当找到数据之后，我们还需要将它移动到双向链表的尾部。 </li>
</ol></li>
<li>其次，我们来看<strong>如何删除一个数据</strong>。
<ol>
<li>我们需要找到数据所在的结点，然后将结点删除。借助散列表，我们可以在 O(1) 时间复杂度里找到要删除的结点。</li>
<li>因为我们的链表是双向链表，双向链表可以通过前驱指针 O(1) 时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要 O(1) 的时间复杂度。</li>
</ol></li>
<li>最后，我们来看<strong>如何添加一个数据</strong>。
<ol>
<li>我们需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部。</li>
<li>如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。</li>
</ol></li>
</ol>

<h4 id="toc_1">Redis 有序集合</h4>

<p>在跳表那一节，讲到有序集合的操作时，我稍微做了些简化。实际上，在有序集合中，每个成员对象有两个重要的属性，<strong>key</strong>（键值）和 <strong>score</strong>（分值）。我们不仅会通过 score 来查找数据，还会通过 key 来查找数据。</p>

<p>所以，如果我们细化一下 Redis 有序集合的操作，那就是下面这样：</p>

<ul>
<li>添加一个成员对象；</li>
<li>按照键值来删除一个成员对象；</li>
<li>按照键值来查找一个成员对象；</li>
<li>按照分值区间查找数据，比如查找积分在 [100, 356] 之间的成员对象；</li>
<li>按照分值从小到大排序成员变量；</li>
</ul>

<p>如果我们仅仅按照分值将成员对象组织成跳表的结构，那按照键值来删除、查询成员对象就会很慢，解决方法与 LRU 缓存淘汰算法的解决方法类似。我们可以再按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1)。同时，借助跳表结构，其他操作也非常高效。</p>

<h4 id="toc_2">Java LinkedHashMap</h4>

<p>LinkedHashMap 是通过散列表和链表组合在一起实现的。它不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据。</p>

<pre><code class="language-text">// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序
HashMap&lt;Integer, Integer&gt; m = new LinkedHashMap&lt;&gt;(10, 0.75f, true);
m.put(3, 11);
m.put(1, 12);
m.put(5, 23);
m.put(2, 22);

m.put(3, 26);
m.get(5);

for (Map.Entry e : m.entrySet()) {
  System.out.println(e.getKey());
}
</code></pre>

<p>这段代码打印的结果是 1，2，3，5。</p>

<p><em>分析：</em></p>

<p>在前四个操作完成之后，链表中的数据是下面这样：<br/>
<img src="media/15580900101811/15740709887359.jpg" alt=""/></p>

<p><code>m.put(3, 26);</code>后：</p>

<p><img src="media/15580900101811/15740710583300.jpg" alt=""/></p>

<p><code>m.get(5);</code>后：</p>

<p><img src="media/15580900101811/15740717432246.jpg" alt=""/></p>

<p>按照访问时间排序的 LinkedHashMap 本身就是一个支持 LRU 缓存淘汰策略的缓存系统。<br/>
<strong>LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。</strong></p>

<h4 id="toc_3">解答开篇 &amp; 内容小结</h4>

<p><strong>为什么散列表和链表经常一块使用？</strong></p>

<p>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。</p>

<p>因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/05/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742422050459.html">
                
                  <h1>21 | 哈希算法（上）：如何防止数据库中的用户信息被脱库？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>今天从实战的角度告诉你，<strong>在实际的开发中，我们该如何用哈希算法解决问题。</strong></p>

<h4 id="toc_0">什么是哈希算法？</h4>

<p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是<strong>哈希算法</strong>，而通过原始数据映射之后得到的二进制值串就是<strong>哈希值</strong>。</p>

<p><strong>如何设计一个优秀的哈希算法？</strong></p>

<p>要求：</p>

<ul>
<li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li>
<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li>
</ul>

<p>哈希算法的应用非常非常多，我选了最常见的七个，分别是安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。</p>

<h4 id="toc_1">应用一：安全加密</h4>

<p>最常用于加密的哈希算法是 <strong>MD5</strong>（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和 <strong>SHA</strong>（Secure Hash Algorithm，安全散列算法）。</p>

<p>除了这两个之外，当然还有很多其他加密算法，比如 <strong>DES</strong>（Data Encryption Standard，数据加密标准）、<strong>AES</strong>（Advanced Encryption Standard，高级加密标准）。</p>

<p><strong>为什么哈希算法无法做到零冲突？</strong></p>

<p>哈希算法产生的哈希值的长度是固定且有限的，而我们要哈希的数据是无穷的。</p>

<p>哈希值越长的哈希算法，散列冲突的概率越低。即便哈希算法存在冲突，但是在有限的时间和资源下，哈希算法还是被很难破解的。我们在实际的开发过程中，也需要权衡破解难度和计算时间，来决定究竟使用哪种加密算法。</p>

<h4 id="toc_2">应用二：唯一标识</h4>

<p><strong>如何在海量的图库中，搜索一张图是否存在？</strong></p>

<ol>
<li>从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。</li>
<li>把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。</li>
</ol>

<h4 id="toc_3">应用三：数据校验</h4>

<p><strong>如何来校验文件块的安全、正确、完整呢？</strong></p>

<p>我们通过哈希算法，对文件块分别取哈希值，并且保存在种子文件中。哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p>

<h4 id="toc_4">应用四：散列函数</h4>

<ol>
<li>相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。</li>
<li>散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。</li>
<li>散列函数执行的快慢，会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。</li>
</ol>

<h4 id="toc_5">解答开篇</h4>

<p><strong>如何防止数据库中的用户信息被脱库？</strong></p>

<p>字典攻击你听说过吗？如果用户信息被“脱库”，黑客虽然拿到是加密之后的密文，但可以通过“猜”的方式来破解密码，这是因为，有些用户的密码太简单。比如很多人习惯用 00000、123456 这样的简单数字组合做密码，很容易就被猜中。那我们就需要维护一个常用密码的字典表，把字典中的每个密码用哈希算法计算哈希值，然后拿哈希值跟脱库后的密文比对。如果相同，基本上就可以认为，这个加密之后的密码对应的明文就是字典中的这个密码。</p>

<p>针对字典攻击，我们可以引入一个盐（salt），跟用户的密码组合在一起，增加密码的复杂度。我们拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742422914360.html">
                
                  <h1>22 | 哈希算法（下）：哈希算法在分布式系统中有哪些应用？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>今天，我们再来看剩余三种跟分布式系统有关的应用：负载均衡、数据分片、分布式存储。我们来看下，<strong>哈希算法是如何解决这些分布式问题的</strong>。</p>

<h4 id="toc_0">应用五：负载均衡</h4>

<p>负载均衡算法有很多，比如轮询、随机、加权轮询等。那如何才能实现一个会话粘滞（session sticky）的负载均衡算法呢？也就是说，我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。</p>

<p>最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。</p>

<p>这种方法简单直观，但也有几个弊端：</p>

<ul>
<li>如果客户端很多，映射表可能会很大，比较浪费内存空间；</li>
<li>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大；</li>
</ul>

<p>如果借助哈希算法，这些问题都可以非常完美地解决。<strong>我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行<mark>取模运算</mark>，最终得到的值就是应该被路由到的服务器编号。</strong> 这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p>

<h4 id="toc_1">应用六：数据分片</h4>

<p><strong>1. 如何统计“搜索关键词”出现的次数？</strong></p>

<p>假如我们有 1T 的日志文件，这里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数，该怎么做呢？</p>

<p>这个问题有两个难点，第一个是搜索日志很大，没办法放到一台机器的内存中。第二个难点是，如果只用一台机器来处理这么巨大的数据，处理时间会很长。</p>

<p>针对这两个难点，<strong>我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度</strong>。具体的思路是这样的：为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。</p>

<p>这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，<strong>同一个搜索关键词会被分配到同一个机器上</strong>。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。实际上，这里的处理过程也是 MapReduce 的基本设计思想。</p>

<p><strong>2. 如何快速判断图片是否在图库中？</strong></p>

<p>如何快速判断图片是否在图库中？上一节我们讲过这个例子，不知道你还记得吗？当时我介绍了一种方法，即给每个图片取唯一标识（或者信息摘要），然后构建散列表。假设现在我们的图库中有 1 亿张图片，很显然，在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 1 亿张图片构建散列表显然远远超过了单台机器的内存上限。</p>

<ol>
<li>我们同样可以对数据进行分片，然后采用多机处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。</li>
<li>我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。</li>
<li>当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。</li>
</ol>

<p>我们来估算一下，给这 1 亿张图片构建散列表大约需要多少台机器。</p>

<ol>
<li>散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设我们通过 MD5 来计算哈希值，那长度就是 128 比特，也就是 16 字节。文件路径长度的上限是 256 字节，我们可以假设平均长度是 128 字节。如果我们用链表法来解决冲突，那还需要存储指针，指针只占用 8 字节。所以，散列表中每个数据单元就占用 152 字节（这里只是估算，并不准确）。</li>
<li>假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万（2GB*0.75/152）张图片构建散列表。所以，如果要对 1 亿张图片构建索引，需要大约十几台机器。</li>
</ol>

<p>在工程中，这种估算还是很重要的，能让我们事先对需要投入的资源、资金有个大概的了解，能更好地评估解决方案的可行性。实际上，针对这种海量数据的处理问题，我们都可以采用多机分布式处理。借助这种分片的思路，可以突破单机内存、CPU 等资源的限制。</p>

<h4 id="toc_2">应用七：分布式存储</h4>

<p>现在互联网面对的都是海量的数据、海量的用户。我们为了提高数据的读取、写入能力，一般都采用分布式的方式来存储数据，比如分布式缓存。我们有海量的数据需要缓存，所以一个缓存机器肯定是不够的。于是，我们就需要将数据分布在多台机器上。该如何决定将哪个数据放到哪个机器上呢？</p>

<p>我们可以借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。但是，如果数据增多，原来的 10 个机器已经无法承受了，我们就需要扩容了，比如扩到 11 个机器，这时候麻烦就来了。因为，这里并不是简单地加个机器就可以了。原来的数据是通过与 10 来取模的。比如 13 这个数据，存储在编号为 3 这台机器上。但是新加了一台机器中，我们对数据按照 11 取模，原来 13 这个数据就被分配到 2 号这台机器上了。</p>

<p><img src="media/15742422914360/15742523287473.jpg" alt=""/></p>

<p>所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生<strong>雪崩效应</strong>，压垮数据库。</p>

<p>所以，我们需要一种方法，使得在新加入一个机器后，并不需要做大量的数据搬移。这时候，<strong>一致性哈希算法</strong>就要登场了。</p>

<p>假设我们有 k 个机器，数据的哈希值的范围是 [0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>

<p>一致性哈希算法的基本思想就是这么简单。除此之外，它还会借助一个虚拟的环和虚拟结点，更加优美地实现出来。</p>

<h4 id="toc_3">解答开篇 &amp; 内容小结</h4>

<p>在负载均衡应用中，利用哈希算法替代映射表，可以实现一个会话粘滞的负载均衡策略。在数据分片应用中，通过哈希算法对处理的海量数据进行分片，多机分布式处理，可以突破单机资源的限制。在分布式存储应用中，利用一致性哈希算法，可以解决缓存等分布式系统的扩容、缩容导致数据大量搬移的难题。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742423251170.html">
                
                  <h1>23 | 二叉树基础（上）：什么样的二叉树适合用数组来存储？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4 id="toc_0">树（Tree）</h4>

<p><strong>什么是“树”？</strong></p>

<p><img src="media/15742423251170/15743398844463.jpg" alt=""/></p>

<p>这里面每个元素我们叫作“节点”；用来连线相邻节点之间的关系，我们叫作“父子关系”。父节点，子节点，兄弟节点，根节点，叶（子）节点。</p>

<p><strong>高度（Height）、深度（Depth）、层（Level）：</strong></p>

<ul>
<li>节点的高度 = 节点到叶子节点的<mark>最长路径</mark>(边数)</li>
<li>节点的深度 = 根节点到这个节点所经历的<mark>边的个数</mark></li>
<li>节点的层数 = 节点的深度+1</li>
<li>树的高度 = 根节点的高度</li>
</ul>

<p>如图：</p>

<p><img src="media/15742423251170/15743402612681.jpg" alt=""/></p>

<h4 id="toc_1">二叉树（Binary Tree）</h4>

<p>二叉树，顾名思义，每个节点<mark>最多</mark>有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。也可以有只一个节点。</p>

<p>如图：<br/>
<img src="media/15742423251170/15743404283628.jpg" alt=""/></p>

<p>编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作<strong>满二叉树</strong>。</p>

<p>编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作<strong>完全二叉树</strong>。</p>

<p><img src="media/15742423251170/15743408598005.jpg" alt=""/></p>

<p>要理解完全二叉树定义的由来，我们需要先了解，<strong>如何表示（或者存储）一棵二叉树？</strong></p>

<p>想要存储一棵二叉树，我们有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。</p>

<p><strong>链式存储法</strong>如图所示，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。</p>

<p><img src="media/15742423251170/15743411885424.jpg" alt=""/></p>

<p>下面是基于数组的<strong>顺序存储法：</strong></p>

<p><img src="media/15742423251170/15743412233390.jpg" alt=""/></p>

<p>如果节点存储在数组中下标为 i 的位置，那么：</p>

<ul>
<li>左子节点下标： 2 * i</li>
<li>右子节点下标： 2 * i + 1</li>
<li>父节点下标：i / 2</li>
</ul>

<p>如果是非完全二叉树，会浪费比较多的数组存储空间：</p>

<p><img src="media/15742423251170/15743415012714.jpg" alt=""/></p>

<p>所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。</p>

<p>当我们讲到堆和堆排序的时候，你会发现，堆其实就是一种完全二叉树，最常用的存储方式就是数组。</p>

<h4 id="toc_2">二叉树的遍历</h4>

<p>如何将所有节点都遍历打印出来呢？经典的方法有三种，<strong>前序遍历、中序遍历和后序遍历</strong>。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。</p>

<ul>
<li>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。根左右</li>
<li>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。左根右</li>
<li>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。左右根</li>
</ul>

<p><img src="media/15742423251170/15745028172840.jpg" alt=""/></p>

<p>实际上，二叉树的前、中、后序遍历就是一个<mark>递归</mark>的过程。写递归代码的关键，就是看能不能写出<mark>递推公式</mark>，而写递推公式的关键就是，如果要解决问题 A，就假设子问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A。所以，我们可以把前、中、后序遍历的递推公式都写出来。</p>

<pre><code class="language-text">前序遍历的递推公式：
preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)

中序遍历的递推公式：
inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)

后序遍历的递推公式：
postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r
</code></pre>

<p><strong>二叉树遍历的时间复杂度是多少？</strong><br/>
个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说二叉树遍历的时间复杂度是 <strong>O(n)</strong>。</p>

<h4 id="toc_3">解答开篇 &amp; 内容小结</h4>

<p>今天，我讲了一种非线性表数据结构，树。关于树，有几个比较常用的概念你需要掌握，那就是：根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度、层数，以及树的高度。</p>

<p>我们平时最常用的树就是二叉树。二叉树的每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。</p>

<p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里非常重要的操作就是前、中、后序遍历操作，遍历的时间复杂度是 O(n)，你需要理解并能用递归代码来实现。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742423309937.html">
                
                  <h1>24 | 二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>二叉查找树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。<br/>
散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是 O(1)。既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？</p>

<h3 id="toc_0">二叉查找树（Binary Search Tree）</h3>

<p>二叉查找树要求，在<strong>树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong></p>

<p><img src="media/15742423309937/15746767591469.jpg" alt=""/></p>

<h4 id="toc_1">1. 二叉查找树的查找操作</h4>

<ul>
<li>我们先取根节点，如果它等于我们要查找的数据，那就返回；</li>
<li>如果要查找的数据比根节点的值小，那就在左子树中递归查找；</li>
<li>如果要查找的数据比根节点的值大，那就在右子树中递归查找。</li>
</ul>

<h4 id="toc_2">2. 二叉查找树的插入操作</h4>

<ul>
<li>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。</li>
<li>如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</li>
</ul>

<h4 id="toc_3">3. 二叉查找树的删除操作</h4>

<ul>
<li>第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 55。</li>
<li>第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 13。</li>
<li>第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。</li>
</ul>

<p><img src="media/15742423309937/15746819081212.jpg" alt=""/></p>

<h4 id="toc_4">4. 二叉查找树的其他操作</h4>

<p>*** 二叉查找树中还可以支持快速地查找最大节点和最小节点、前驱节点和后继节点。**</p>

<ul>
<li><strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。</strong>因此，二叉查找树也叫作二叉排序树。
### 支持重复数据的二叉查找树</li>
</ul>

<p>如果存储的两个对象键值相同，这种情况该怎么处理呢？我这里有两种解决方法。<br/>
第一种方法比较容易。二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。<br/>
第二种方法，在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。</p>

<h3 id="toc_5">二叉查找树的时间复杂度分析</h3>

<p>二叉查找树的形态各式各样。</p>

<p><img src="media/15742423309937/15746829625607.jpg" alt=""/></p>

<h3 id="toc_6">解答开篇</h3>

<p>散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，那我们为什么还要用二叉查找树呢？</p>

<ol>
<li>第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</li>
<li>第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</li>
<li>第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</li>
<li>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li>
</ol>

<h3 id="toc_7">内容小结</h3>

<p>今天我们学习了一种特殊的二叉树，二叉查找树。它支持快速地查找、插入、删除操作。</p>

<p>二叉查找树中，每个节点的值都大于左子树节点的值，小于右子树节点的值。不过，这只是针对没有重复数据的情况。对于存在重复数据的二叉查找树，我介绍了两种构建方法，一种是让每个节点存储多个值相同的数据；另一种是，每个节点中存储一个数据。针对这种情况，我们只需要稍加改造原来的插入、删除、查找操作即可。在二叉查找树中，查找、插入、删除等很多操作的时间复杂度都跟树的高度成正比。两个极端情况的时间复杂度分别是 O(n) 和 O(logn)，分别对应二叉树退化成链表的情况和完全二叉树。为了避免时间复杂度的退化，针对二叉查找树，我们又设计了一种更加复杂的树，平衡二叉查找树，时间复杂度可以做到稳定的 O(logn)，下一节我们具体来讲。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742423352063.html">
                
                  <h1>25 | 红黑树（上）：为什么工程中都用红黑树这种二叉树？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">什么是“平衡二叉查找树”？</h3>

<p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。完全二叉树、满二叉树其实都是平衡二叉树。</p>

<p>但是很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1）。<br/>
平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p>

<h3 id="toc_1">如何定义一棵“红黑树”？</h3>

<p>红黑树的英文是“Red-Black Tree”，简称 R-B Tree。</p>

<ul>
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li>
<li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li>
</ul>

<p><img src="media/15742423352063/15746860663540.jpg" alt=""/></p>

<h3 id="toc_2">为什么说红黑树是“近似平衡”的？</h3>

<p>“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重。</p>

<p>如果要证明红黑树是近似平衡的，我们只需要分析，红黑树的高度是否比较稳定地趋近 log2n 就好了。</p>

<p>首先，我们来看，如果我们将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度是多少呢？<br/>
<img src="media/15742423352063/15746863396644.jpg" alt=""/></p>

<p>我们现在知道只包含黑色节点的“黑树”的高度，那我们现在把红色节点加回去，高度会变成多少呢？</p>

<h3 id="toc_3">解答开篇</h3>

<p><strong>为什么在工程中大家都喜欢用红黑树这种平衡二叉查找树？</strong></p>

<ol>
<li>Treap、Splay Tree，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。</li>
<li>AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。</li>
<li>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。</li>
</ol>

<p>红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。</p>

<h3 id="toc_4">内容小结</h3>

<p>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。</p>

<p>因为红黑树是一种性能非常稳定的二叉查找树，所以，在工程中，但凡是用到动态插入、删除、查找数据的场景，都可以用到它。不过，它实现起来比较复杂，如果自己写代码实现，难度会有些高，这个时候，我们其实更倾向用跳表来替代它。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742423422927.html">
                
                  <h1>26 | 红黑树（下）：掌握这些技巧，你也可以实现一个红黑树</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">实现红黑树的基本思想</h3>

<p>一棵合格的红黑树需要满足这样几个要求：</p>

<ul>
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li>
<li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点。</li>
</ul>

<p>在插入、删除节点的过程中，第三、第四点要求可能会被破坏，而我们今天要讲的“平衡调整”，实际上就是要把被破坏的第三、第四点恢复过来。</p>

<p>在正式开始之前，我先介绍两个非常重要的操作：</p>

<ul>
<li>左旋（rotate left）：围绕某个节点的左旋。</li>
<li>右旋（rotate right）：围绕某个节点的右旋。</li>
</ul>

<p><img src="media/15742423422927/15748553873365.jpg" alt=""/></p>

<h3 id="toc_1">插入操作的平衡调整</h3>

<p><strong>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。</strong>所以，关于插入操作的平衡调整，有这样两种特殊情况，但是也都非常好处理。</p>

<ul>
<li>如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。</li>
<li>如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。</li>
</ul>

<p>除此之外，其他情况都会违背红黑树的定义，于是我们就需要进行调整，调整的过程包含两种基础的操作：<strong>左右旋转和改变颜色。</strong></p>

<h3 id="toc_2">删除操作的平衡调整</h3>

<p>删除操作的平衡调整分为两步，第一步是针对删除节点初步调整。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；第二步是针对关注节点进行二次调整，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。</p>

<h3 id="toc_3">内容小结</h3>

<p>第一点，<strong>把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性。</strong>你只需要明白，只要按照固定的操作步骤，保持插入、删除的过程，不破坏平衡树的定义就行了。</p>

<p>第二点，找准关注节点，不要搞丢、搞错关注节点。因为每种操作规则，都是基于关注节点来做的，只有弄对了关注节点，才能对应到正确的操作规则中。在迭代的调整过程中，关注节点在不停地改变，所以，这个过程一定要注意，不要弄丢了关注节点。</p>

<p>第三点，<strong>插入操作的平衡调整比较简单，但是删除操作就比较复杂</strong>。针对删除操作，我们有两次调整，第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义，“每个节点到可达叶子节点的路径都包含相同个数的黑色节点”。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。第二次调整就是解决这个问题，让红黑树不存在相邻的红色节点。课后思考</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742423473233.html">
                
                  <h1>27 | 递归树：如何借助树来求解递归算法的时间复杂度？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4 id="toc_0">递归树与时间复杂度分析</h4>

<p>递归的思想就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。如果我们把这个一层一层的分解过程画成图，它其实就是一棵树。我们给这棵树起一个名字，叫作<strong>递归树</strong>。</p>

<p><strong>如何用递归树来求解时间复杂度。</strong></p>

<p><img src="media/15742423473233/15749361962479.jpg" alt=""/></p>

<ol>
<li>因为每次分解都是一分为二，所以代价很低，我们把时间上的消耗记作常量 1。</li>
<li>我们只需要知道这棵树的高度 h，用高度 h 乘以每一层的时间消耗 n，就可以得到总的时间复杂度 O(n∗h)。</li>
<li>归并排序递归树是一棵满二叉树。满二叉树的高度大约是 log2​n，所以，归并排序递归实现的时间复杂度就是 O(nlogn)。</li>
</ol>

<h4 id="toc_1">实战一：分析快速排序的时间复杂度</h4>

<h4 id="toc_2">实战二：分析斐波那契数列的时间复杂度</h4>

<h4 id="toc_3">实战三：分析全排列的时间复杂度</h4>

<h4 id="toc_4">内容小结</h4>

<p>今天，我们用递归树分析了递归代码的时间复杂度。加上我们在排序那一节讲到的递推公式的时间复杂度分析方法，我们现在已经学习了两种递归代码的时间复杂度分析方法了。</p>

<p>有些代码比较适合用递推公式来分析，比如归并排序的时间复杂度、快速排序的最好情况时间复杂度；有些比较适合采用递归树来分析，比如快速排序的平均时间复杂度。而有些可能两个都不怎么适合使用，比如二叉树的递归前中后序遍历。</p>

<p>时间复杂度分析的理论知识并不多，也不复杂，掌握起来也不难，但是，在我们平时的工作、学习中，面对的代码千差万别，能够灵活应用学到的复杂度分析方法，来分析现有的代码，并不是件简单的事情，所以，你平时要多实战、多分析，只有这样，面对任何代码的时间复杂度分析，你才能做到游刃有余、毫不畏惧。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742423511680.html">
                
                  <h1>28 | 堆和堆排序：为什么说堆排序没有快速排序快？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>堆（Heap），经常被用于堆排序。<br/>
堆排序是一种原地的、时间复杂度为O(nlogn)的排序算法。</p>

<h3 id="toc_0">如何理解堆？</h3>

<p>堆是一种特殊的树。只要满足以下两点，就是一个堆：</p>

<ul>
<li>堆是一个完全二叉树。</li>
<li>堆中每一个节点的值都必需大于等于（或小于等于）其子树中每个节点的值。</li>
</ul>

<p>节点大于子树节点的堆叫“大顶堆”，否则为“小顶堆”。</p>

<p><img src="media/15742423511680/15751034746068.jpg" alt=""/></p>

<p>1、2是大顶堆，3是小顶堆，4不是堆。</p>

<h3 id="toc_1">如何实现一个堆？</h3>

<p>要实现一个堆，我们先要知道，<strong>堆都支持哪些操作</strong>以及<strong>如何存储一个堆</strong>。</p>

<p><strong>1.往堆中插入一个元素</strong></p>

<p>如果我们把新插入的元素放到堆中，需要对堆进行调整，让其重新满足堆的特性，这个过程称之为<strong>堆化</strong>（heapify）。</p>

<ul>
<li>堆化实际上有两种，从下往上和从上往下。</li>
<li>堆化就是顺着节点所在的路径，向上或者向下，对比，然后交换。</li>
</ul>

<p><strong>从下往上</strong>的堆化：<br/>
<img src="media/15742423511680/15751038657781.jpg" alt=""/></p>

<p><strong>2.删除堆顶元素</strong></p>

<ol>
<li>把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。</li>
<li>对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。</li>
</ol>

<p><strong>从上往下</strong>的堆化：<br/>
<img src="media/15742423511680/15751041351935.jpg" alt=""/></p>

<p>一个包含 n 个节点的完全二叉树，树的高度不会超过 log2​n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(logn)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。</p>

<h3 id="toc_2">如何基于堆实现排序？</h3>

<p><strong>1.建堆</strong></p>

<ol>
<li>第一种是借助我们前面讲的，在堆中插入一个元素的思路。</li>
<li>第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。<br/>
建堆的时间复杂度是O(n)。</li>
</ol>

<p><strong>2.排序</strong></p>

<ol>
<li>我们把堆顶元素跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。</li>
<li>然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆。</li>
<li>我们再取堆顶的元素，放到下标是 n−1 的位置，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。</li>
</ol>

<p>堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。堆排序不是稳定的排序算法。</p>

<h3 id="toc_3">解答开篇</h3>

<p><strong>在实际开发中，为什么快速排序要比堆排序性能好？</strong><br/>
第一点，堆排序数据访问的方式没有快速排序友好。<br/>
第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。</p>

<h3 id="toc_4">内容小结</h3>

<p>今天我们讲了堆这种数据结构。堆是一种完全二叉树。它最大的特性是：每个节点的值都大于等于（或小于等于）其子树节点的值。因此，堆被分成了两类，大顶堆和小顶堆。</p>

<p>堆中比较重要的两个操作是插入一个数据和删除堆顶元素。这两个操作都要用到堆化。插入一个数据的时候，我们把新插入的数据放到数组的最后，然后从下往上堆化；删除堆顶数据的时候，我们把数组中的最后一个元素放到堆顶，然后从上往下堆化。这两个操作时间复杂度都是 O(logn)。</p>

<p>除此之外，我们还讲了堆的一个经典应用，堆排序。堆排序包含两个过程，建堆和排序。我们将下标从 n/2​ 到 1 的节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。接下来，我们迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742423549739.html">
                
                  <h1>29 | 堆的应用：如何快速获取到Top 10最热门的搜索关键词？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">堆的应用一：优先级队列</h3>

<p>优先级队列，顾名思义，它首先应该是一个队列（先进先出）。不过，在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p>

<p>为什么用堆来实现一个优先级队列呢？堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p>

<p>应用场景赫夫曼编码、图的最短路径、最小生成树算法等等，还有Java 的 PriorityQueue，C++ 的 priority_queue 等。</p>

<p><strong>1. 合并有序小文件</strong></p>

<p>假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。这里就会用到优先级队列。</p>

<ol>
<li>我们将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。</li>
<li>我们将这个字符串放入到大文件中，并将其从堆中删除。</li>
<li>然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。</li>
</ol>

<p><strong>2. 高性能定时器</strong></p>

<p>假设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。</p>

<ol>
<li>我们按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。</li>
<li>拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。定时器就可以设定在 T 秒之后，再来执行任务。</li>
<li>当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。</li>
</ol>

<h3 id="toc_1">堆的应用二：利用堆求TopK</h3>

<p>针对<strong>静态数据</strong>，如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？</p>

<ol>
<li>维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。</li>
<li>如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。</li>
<li>这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。</li>
</ol>

<p>针对<strong>动态数据</strong>求得 Top K 就是实时 Top K。</p>

<ol>
<li>一直都维护一个 K 大小的小顶堆</li>
<li>当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。</li>
</ol>

<p><strong>针对动态数据集合</strong>，也就是说数据集合事先并不确定，有数据动态地加入到集合中。</p>

<h3 id="toc_2">堆的应用三：利用堆求中位数</h3>

<ol>
<li>我们需要维护两个堆，一个大顶堆，一个小顶堆。小顶堆中的数据都大于大顶堆中的数据。如果 n 是偶数，两个堆中的数据个数都是 n/2​；如果 n 是奇数，大顶堆有 n/2+1 个数据，小顶堆有 n/2​ 个数据。</li>
<li>如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。</li>
<li>如果堆的个数不平均，则从一个堆中不停地将堆顶元素移动到另一个堆。</li>
<li>中位数就是大顶堆的堆顶元素。</li>
</ol>

<p>同理“99% 响应时间”也是类似方法。</p>

<p><img src="media/15742423549739/15752894796910.jpg" alt=""/></p>

<h3 id="toc_3">解答开篇</h3>

<h3 id="toc_4">内容小结</h3>

<ul>
<li>优先级队列是一种特殊的队列，优先级高的数据先出队，而不再像普通的队列那样，先进先出。实际上，堆就可以看作优先级队列，只是称谓不一样罢了。</li>
<li>求 Top K 问题又可以分为针对静态数据和针对动态数据，只需要利用一个堆，就可以做到非常高效率的查询 Top K 的数据。</li>
<li>求中位数实际上还有很多变形，比如求 99 百分位数据、90 百分位数据等，处理的思路都是一样的，即利用两个堆，一个大顶堆，一个小顶堆，随着数据的动态添加，动态调整两个堆中的数据，最后大顶堆的堆顶元素就是要求的数据。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742423594200.html">
                
                  <h1>30 | 图的表示：如何存储微博、微信等社交网络中的好友关系？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>涉及图的算法有很多，也非常复杂，比如图的搜索、最短路径、最小生成树、二分图等等。</p>

<h3 id="toc_0">如何理解图？（Graph）</h3>

<p>树中的元素我们称为节点，图中的元素我们就叫作<strong>顶点</strong>（vertex）。图中的一个顶点可以与任意其他顶点建立连接关系。我们把这种建立的关系叫作<strong>边</strong>（edge）。顶点与顶点相连接的边的条数，叫做顶点的<strong>度</strong>（degree）。</p>

<p><img src="media/15742423594200/15753660181164.jpg" alt=""/></p>

<p>边有方向的图叫作“有向图”；边没有方向的图就叫作“无向图”。</p>

<p><img src="media/15742423594200/15753672758654.jpg" alt=""/></p>

<p>在有向图中，我们把度分为<strong>入度</strong>（In-degree）和<strong>出度</strong>（Out-degree）。顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。</p>

<p><strong>带权图</strong>（weighted graph），每条边都有一个权重（weight）。</p>

<p><img src="media/15742423594200/15753675147431.jpg" alt=""/></p>

<h3 id="toc_1">邻接矩阵存储方法</h3>

<p>图最直观的一种存储方法就是，<strong>邻接矩阵</strong>（Adjacency Matrix）。<br/>
邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j] 和 A[j][i] 标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j] 标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i] 标记为 1。对于带权图，数组中就存储相应的权重。</p>

<p><img src="media/15742423594200/15753678160693.jpg" alt=""/></p>

<p>优点：简单、直观；方便计算。<br/>
缺点：浪费存储空间。</p>

<h3 id="toc_2">邻接表存储方法</h3>

<p>如图，图中画的是一个有向图的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点。对于无向图来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点。</p>

<p><img src="media/15742423594200/15753679698216.jpg" alt=""/></p>

<p>在基于链表法解决冲突的散列表中，如果链过长，为了提高查找效率，我们可以将链表换成其他更加高效的数据结构，比如平衡二叉查找树等。实际开发中，我们可以选择用红黑树。这样，我们就可以更加快速地查找两个顶点之间是否存在边了。当然，这里的二叉查找树可以换成其他动态数据结构，比如跳表、散列表等。除此之外，我们还可以将链表改成有序动态数组，可以通过二分查找的方法来快速定位两个顶点之间否是存在边。</p>

<h3 id="toc_3">解答开篇</h3>

<p><strong>如何存储微博、微信等社交网络中的好友关系？</strong></p>

<ul>
<li>因为社交网络是一张稀疏图，使用邻接矩阵存储比较浪费存储空间。所以，这里我们采用邻接表来存储。</li>
<li>如果要想知道某个用户都被哪些用户关注了，我们需要一个逆邻接表。</li>
<li>快速判断两个用户之间是否是关注与被关注的关系？因为我们需要按照用户名称的首字母排序，分页来获取用户的粉丝列表或者关注列表，用跳表这种结构再合适不过了。</li>
<li>用户大时，我们可以通过哈希算法等数据分片方式，将邻接表存储在不同的机器上。或者利用外部存储（比如硬盘），用来持久化存储关系数据。</li>
</ul>

<h3 id="toc_4">内容小结</h3>

<p>今天我们学习了图这种非线性表数据结构，关于图，你需要理解这样几个概念：无向图、有向图、带权图、顶点、边、度、入度、出度。除此之外，我们还学习了图的两个主要的存储方式：邻接矩阵和邻接表。</p>

<p>邻接矩阵存储方法的缺点是比较浪费空间，但是优点是查询效率高，而且方便矩阵运算。邻接表存储方法中每个顶点都对应一个链表，存储与其相连接的其他顶点。尽管邻接表的存储方式比较节省存储空间，但链表不方便查找，所以查询效率没有邻接矩阵存储方式高。针对这个问题，邻接表还有改进升级版，即将链表换成更加高效的动态数据结构，比如平衡二叉查找树、跳表、散列表等。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742424378549.html">
                
                  <h1>31 | 深度和广度优先搜索：如何找出社交网络中的三度好友关系？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">什么是“搜索”算法？</h3>

<p>图上的搜索算法，就是在图中找出从一个顶点出发，到另一个顶点的路径。</p>

<p>用邻接表来存储图：</p>

<pre><code class="language-text">public class Graph { // 无向图
  private int v; // 顶点的个数
  private LinkedList&lt;Integer&gt; adj[]; // 邻接表

  public Graph(int v) {
    this.v = v;
    adj = new LinkedList[v];
    for (int i=0; i&lt;v; ++i) {
      adj[i] = new LinkedList&lt;&gt;();
    }
  }

  public void addEdge(int s, int t) { // 无向图一条边存两次
    adj[s].add(t);
    adj[t].add(s);
  }
}
</code></pre>

<h3 id="toc_1">广度优先搜索（BFS）</h3>

<p>广度优先搜索（Breadth-First-Search），简称为 BFS。直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。</p>

<p><img src="media/15742424378549/15754584747431.jpg" alt=""/></p>

<p>V 表示顶点的个数，E 表示边的个数。<br/>
广度优先搜索的时间复杂度也可以简写为 O(E)。<br/>
广度优先搜索的空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev 数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是 O(V)。</p>

<h3 id="toc_2">深度优先搜索（DFS）</h3>

<p>深度优先搜索（Depth-First-Search），简称 DFS。最直观的例子就是“走迷宫”。</p>

<p><img src="media/15742424378549/15754593308212.jpg" alt=""/></p>

<p>深度优先搜索用的是一种比较著名的算法思想，回溯思想。</p>

<p>图上的深度优先搜索算法的时间复杂度是 O(E)，E 表示边的个数。<br/>
深度优先搜索算法的消耗内存主要是 visited、prev 数组和递归调用栈。visited、prev 数组的大小跟顶点的个数 V 成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是 O(V)。</p>

<h3 id="toc_3">解答开篇</h3>

<p><strong>如何找出社交网络中某个用户的三度好友关系？</strong></p>

<p>首先，遍历与起始顶点最近的一层顶点，也就是用户的一度好友，然后再遍历与用户距离的边数为 2 的顶点，也就是二度好友关系，以及与用户距离的边数为 3 的顶点，也就是三度好友关系。</p>

<h3 id="toc_4">内容小结</h3>

<p>广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法，比起其他高级的搜索算法，比如 A<em>、IDA</em> 等，要简单粗暴，没有什么优化，所以，也被叫作暴力搜索算法。所以，这两种搜索算法仅适用于状态空间不大，也就是说图不大的搜索。</p>

<p>广度优先搜索，通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助队列来实现，遍历得到的路径就是，起始顶点到终止顶点的最短路径。深度优先搜索用的是回溯思想，非常适合用递归实现。换种说法，深度优先搜索是借助栈来实现的。在执行效率方面，深度优先和广度优先搜索的时间复杂度都是 O(E)，空间复杂度是 O(V)。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742424414473.html">
                
                  <h1>32 | 字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>单模式串匹配的算法，也就是一个串跟一个串进行匹配，如BF 算法、 RK 算法、BM 算法和 KMP 算法。<br/>
多模式串匹配算法，也就是在一个串中同时查找多个串，如 Trie 树和 AC 自动机。</p>

<h3 id="toc_0">BF算法</h3>

<p>BF 算法中的 BF 是 Brute Force 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。</p>

<p>我们在字符串 A 中查找字符串 B，那字符串 A 就是<strong>主串</strong>，字符串 B 就是<strong>模式串</strong>。我们把主串的长度记作 n，模式串的长度记作 m。因为我们是在主串中查找模式串，所以 n&gt;m。</p>

<p><strong>算法思想：</strong>我们在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。</p>

<p><img src="media/15742424414473/15754615349838.jpg" alt=""/></p>

<p>BF 算法的时间复杂度很高，是 O(n*m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法。原因：第一，大部分情况下，模式串和主串的长度都不会太长，不会达到最坏情况；第二，算法思想和实现简单。</p>

<h3 id="toc_1">RK算法</h3>

<p>RK 算法的全称叫 Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的。</p>

<p>RK 算法的思路是这样的：我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面我们会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p>

<p>有没有方法可以提高哈希算法计算子串哈希值的效率呢？这就需要哈希算法设计的非常有技巧了。我们假设要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。</p>

<p>可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 O(n)。模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共需要比较 n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 O(n)。所以，RK 算法整体的时间复杂度就是 O(n)。</p>

<h3 id="toc_2">解答开篇 &amp; 内容小结</h3>

<p>今天我们讲了两种字符串匹配算法，BF 算法和 RK 算法。</p>

<p>BF 算法是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。所以，时间复杂度也比较高，是 O(n*m)，n、m 表示主串和模式串的长度。不过，在实际的软件开发中，因为这种算法实现简单，对于处理小规模的字符串匹配很好用。</p>

<p>RK 算法是借助哈希算法对 BF 算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。所以，理想情况下，RK 算法的时间复杂度是 O(n)，跟 BF 算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 O(n*m)。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742424449181.html">
                
                  <h1>33 | 字符串匹配基础（中）：如何实现文本编辑器中的查找功能？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>BM 算法的核心思想</li>
<li>BM 算法原理分析
<ol>
<li>坏字符规则</li>
<li>好后缀规则</li>
</ol></li>
<li>BM 算法代码实现</li>
<li>BM 算法的性能分析及优化</li>
<li>解答开篇 &amp; 内容小结</li>
</ul>

<h3 id="toc_0">BM 算法的核心思想</h3>

<p>BM（Boyer-Moore）算法。<br/>
在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。</p>

<h3 id="toc_1">BM 算法原理分析</h3>

<h4 id="toc_2">1. 坏字符规则</h4>

<p>我们从模式串的末尾往前倒着匹配，当我们发现某个字符没法匹配的时候。我们把这个没有匹配的字符叫作<strong>坏字符</strong>（主串中的字符）。<br/>
<img src="media/15742424449181/15757063934055.jpg" alt=""/></p>

<p>我们拿坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。这个时候，我们可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较。</p>

<p><img src="media/15742424449181/15757069769768.jpg" alt=""/></p>

<p>这个时候，我们发现，模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，还能将模式串往后滑动三位吗？答案是不行的。因为这个时候，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a。这种情况下，我们可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配。</p>

<p><img src="media/15742424449181/15757070312780.jpg" alt=""/></p>

<h4 id="toc_3">2. 好后缀规则</h4>

<p>好后缀规则实际上跟坏字符规则的思路很类似。你看我下面这幅图。当模式串滑动到图中的位置的时候，模式串和主串有 2 个字符是匹配的，倒数第 3 个字符发生了不匹配的情况。</p>

<p><img src="media/15742424449181/15757074592628.jpg" alt=""/></p>

<p>我们把已经匹配的 bc 叫作好后缀，记作{u}。我们拿它在模式串中查找，如果找到了另一个跟{u}相匹配的子串{u*}，那我们就将模式串滑动到子串{u*}与主串中{u}对齐的位置。</p>

<p><img src="media/15742424449181/15757075749264.jpg" alt=""/></p>

<p>如果在模式串中找不到另一个等于{u}的子串，我们就直接将模式串，滑动到主串中{u}的后面，因为之前的任何一次往后滑动，都没有匹配主串中{u}的情况。</p>

<p><img src="media/15742424449181/15757081099068.jpg" alt=""/></p>

<p>不过，当模式串中不存在等于{u}的子串时，我们直接将模式串滑动到主串{u}的后面。这样做是否有点太过头呢？我们来看下面这个例子。这里面 bc 是好后缀，尽管在模式串中没有另外一个相匹配的子串{u*}，但是如果我们将模式串移动到好后缀的后面，如图所示，那就会错过模式串和主串可以匹配的情况。</p>

<p><img src="media/15742424449181/15757082879297.jpg" alt=""/></p>

<p>如果好后缀在模式串中不存在可匹配的子串，那在我们一步一步往后滑动模式串的过程中，只要主串中的{u}与模式串有重合，那肯定就无法完全匹配。但是当模式串滑动到前缀与主串中{u}的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况。</p>

<p><img src="media/15742424449181/15757083012163.jpg" alt=""/></p>

<p>所以，针对这种情况，我们不仅要看好后缀在模式串中，是否有另一个匹配的子串，我们还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。</p>

<p>所谓某个字符串 s 的后缀子串，就是最后一个字符跟 s 对齐的子串，比如 abc 的后缀子串就包括 c, bc。所谓前缀子串，就是起始字符跟 s 对齐的子串，比如 abc 的前缀子串有 a，ab。我们从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是{v}，然后将模式串滑动到如图所示的位置。</p>

<p><img src="media/15742424449181/15757083223781.jpg" alt=""/></p>

<p>坏字符和好后缀的基本原理都讲完了，我现在回答一下前面那个问题。当模式串和主串中的某个字符不匹配的时候，如何选择用好后缀规则还是坏字符规则，来计算模式串往后滑动的位数？</p>

<p><strong>我们可以分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。这种处理方法还可以避免我们前面提到的，根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。</strong></p>

<p>(太难了，看不下去了。。。)</p>

<h3 id="toc_4">BM 算法代码实现</h3>

<h3 id="toc_5">BM 算法的性能分析及优化</h3>

<h3 id="toc_6">解答开篇 &amp; 内容小结</h3>

<p>BM 算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。BM 算法构建的规则有两类，坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，我们可以只用好后缀规则来实现 BM 算法。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742424481943.html">
                
                  <h1>34 | 字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>KMP 算法基本原理</li>
<li>失效函数计算方法</li>
<li>KMP 算法复杂度分析</li>
</ul>

<p>（太难不看）</p>

<h3 id="toc_0">KMP 算法基本原理</h3>

<h3 id="toc_1">失效函数计算方法</h3>

<h3 id="toc_2">KMP 算法复杂度分析</h3>

<h3 id="toc_3">解答开篇 &amp; 内容小结</h3>

<p>KMP 算法和上一节讲的 BM 算法的本质非常类似，都是根据规律在遇到坏字符的时候，把模式串往后多滑动几位。</p>

<p>BM 算法有两个规则，坏字符和好后缀。KMP 算法借鉴 BM 算法的思想，可以总结成好前缀规则。这里面最难懂的就是 next 数组的计算。如果用最笨的方法来计算，确实不难，但是效率会比较低。所以，我讲了一种类似动态规划的方法，按照下标 i 从小到大，依次计算 next[i]，并且 next[i] 的计算通过前面已经计算出来的 next[0]，next[1]，……，next[i-1] 来推导。</p>

<p>KMP 算法的时间复杂度是 O(n+m)，不过它的分析过程稍微需要一点技巧，不那么直观，你只要看懂就好了，并不需要掌握，在我们平常的开发中，很少会有这么难分析的代码。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742424517788.html">
                
                  <h1>35 | Trie树：如何实现搜索引擎的搜索关键词提示功能？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>什么是“Trie 树”？</li>
<li>如何实现一棵 Trie 树？</li>
<li>Trie 树真的很耗内存吗？</li>
<li>Trie 树与散列表、红黑树的比较</li>
</ul>

<h3 id="toc_0">什么是“Trie 树”？</h3>

<p>Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</p>

<p><strong>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</strong></p>

<p><img src="media/15742424517788/15757094157669.jpg" alt=""/></p>

<p>其中，根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p>

<p><img src="media/15742424517788/15757095020770.jpg" alt=""/><br/>
<img src="media/15742424517788/15757095056783.jpg" alt=""/></p>

<h3 id="toc_1">如何实现一棵 Trie 树？</h3>

<p>从刚刚 Trie 树的介绍来看，Trie 树主要有两个操作：</p>

<ul>
<li><strong>一个是将字符串集合构造成 Trie 树</strong>。这个过程分解开来的话，就是一个将字符串插入到 Trie 树的过程。</li>
<li><strong>另一个是在 Trie 树中查询一个字符串。</strong></li>
</ul>

<p><strong>如何存储一个 Trie 树？</strong></p>

<p>二叉树中，一个节点的左右子节点是通过两个指针来存储的，如下所示 Java 代码：</p>

<pre><code class="language-text">class BinaryTreeNode {
  char data;
  BinaryTreeNode left;
  BinaryTreeNode right;  
}
</code></pre>

<p>我先介绍其中一种存储方式，也是经典的存储方式——散列表。借助散列表的思想，我们通过一个下标与字符一一映射的数组，来存储子节点的指针。</p>

<p><img src="media/15742424517788/15757097447111.jpg" alt=""/></p>

<p>当我们在 Trie 树中查找字符串的时候，我们就可以通过字符的 ASCII 码减去“a”的 ASCII 码，迅速找到匹配的子节点的指针。</p>

<pre><code class="language-text">public class Trie {
  private TrieNode root = new TrieNode(&#39;/&#39;); // 存储无意义字符

  // 往Trie树中插入一个字符串
  public void insert(char[] text) {
    TrieNode p = root;
    for (int i = 0; i &lt; text.length; ++i) {
      int index = text[i] - &#39;a&#39;;
      if (p.children[index] == null) {
        TrieNode newNode = new TrieNode(text[i]);
        p.children[index] = newNode;
      }
      p = p.children[index];
    }
    p.isEndingChar = true;
  }

  // 在Trie树中查找一个字符串
  public boolean find(char[] pattern) {
    TrieNode p = root;
    for (int i = 0; i &lt; pattern.length; ++i) {
      int index = pattern[i] - &#39;a&#39;;
      if (p.children[index] == null) {
        return false; // 不存在pattern
      }
      p = p.children[index];
    }
    if (p.isEndingChar == false) return false; // 不能完全匹配，只是前缀
    else return true; // 找到pattern
  }

  public class TrieNode {
    public char data;
    public TrieNode[] children = new TrieNode[26];
    public boolean isEndingChar = false;
    public TrieNode(char data) {
      this.data = data;
    }
  }
}
</code></pre>

<p><strong>在 Trie 树中，查找某个字符串的时间复杂度是多少？</strong></p>

<ul>
<li>构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)（n 表示所有字符串的长度和）。</li>
<li>构建好 Trie 树后，在其中查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度。</li>
</ul>

<h3 id="toc_2">Trie 树真的很耗内存吗？</h3>

<p>刚刚我们在讲 Trie 树的实现的时候，讲到用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p>

<p>我们可以稍微牺牲一点查询的效率，将每个节点中的数组换成其他数据结构，来存储一个节点的子节点指针。我们的选择其实有很多，比如有序数组、跳表、散列表、红黑树等。</p>

<p>实际上，Trie 树的变体有很多，都可以在一定程度上解决内存消耗的问题。比如，<strong>缩点优化</strong>，就是对只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并。这样可以节省空间，但却增加了编码难度。</p>

<p><img src="media/15742424517788/15757100539598.jpg" alt=""/></p>

<h3 id="toc_3">Trie 树与散列表、红黑树的比较</h3>

<p>在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。</p>

<ul>
<li>第一，字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。</li>
<li>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。</li>
<li>第三，如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</li>
<li>第四，我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</li>
</ul>

<p>针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树。Trie 树只是不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。Trie 树比较适合的是查找前缀匹配的字符串。</p>

<h3 id="toc_4">解答开篇</h3>

<p><strong>如何利用 Trie 树，实现搜索关键词的提示功能？</strong></p>

<p>我们假设关键词库由用户的热门搜索关键词组成。我们将这个词库构建成一个 Trie 树。当用户输入其中某个单词的时候，把这个词作为一个前缀子串在 Trie 树中匹配。为了讲解方便，我们假设词库里只有 hello、her、hi、how、so、see 这 6 个关键词。当用户输入了字母 h 的时候，我们就把以 h 为前缀的 hello、her、hi、how 展示在搜索提示框内。当用户继续键入字母 e 的时候，我们就把以 he 为前缀的 hello、her 展示在搜索提示框内。这就是搜索关键词提示的最基本的算法原理。</p>

<p><img src="media/15742424517788/15757105209082.jpg" alt=""/></p>

<p>Trie 树的这个应用可以扩展到更加广泛的一个应用上，就是自动输入补全，比如输入法自动补全功能、IDE 代码编辑器自动补全功能、浏览器网址输入的自动补全功能等等。</p>

<h3 id="toc_5">内容小结</h3>

<p>rie 树是一种解决字符串快速匹配问题的数据结构。如果用来构建 Trie 树的这一组字符串中，前缀重复的情况不是很多，那 Trie 树这种数据结构总体上来讲是比较费内存的，是一种空间换时间的解决问题思路。</p>

<p>尽管比较耗费内存，但是对内存不敏感或者内存消耗在接受范围内的情况下，在 Trie 树中做字符串匹配还是非常高效的，时间复杂度是 O(k)，k 表示要匹配的字符串的长度。</p>

<p>但是，Trie 树的优势并不在于，用它来做动态集合数据的查找，因为，这个工作完全可以用更加合适的散列表或者红黑树来替代。Trie 树最有优势的是查找前缀匹配的字符串，比如搜索引擎中的关键词提示功能这个场景，就比较适合用它来解决，也是 Trie 树比较经典的应用场景。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742424559568.html">
                
                  <h1>36 | AC自动机：如何用多模式串匹配实现敏感词过滤功能？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>基于单模式串和 Trie 树实现的敏感词过滤</li>
<li>经典的多模式串匹配算法：AC 自动机</li>
</ul>

<h3 id="toc_0">基于单模式串和 Trie 树实现的敏感词过滤</h3>

<h3 id="toc_1">经典的多模式串匹配算法：AC 自动机</h3>

<h3 id="toc_2">解答开篇</h3>

<h3 id="toc_3">内容小结</h3>

<p>今天我们讲了多模式串匹配算法，AC 自动机。单模式串匹配算法是为了快速在主串中查找一个模式串，而多模式串匹配算法是为了快速在主串中查找多个模式串。</p>

<p>AC 自动机是基于 Trie 树的一种改进算法，它跟 Trie 树的关系，就像单模式串中，KMP 算法与 BF 算法的关系一样。KMP 算法中有一个非常关键的 next 数组，类比到 AC 自动机中就是失败指针。而且，AC 自动机失败指针的构建过程，跟 KMP 算法中计算 next 数组极其相似。所以，要理解 AC 自动机，最好先掌握 KMP 算法，因为 AC 自动机其实就是 KMP 算法在多模式串上的改造。</p>

<p>整个 AC 自动机算法包含两个部分，第一部分是将多个模式串构建成 AC 自动机，第二部分是在 AC 自动机中匹配主串。第一部分又分为两个小的步骤，一个是将模式串构建成 Trie 树，另一个是在 Trie 树上构建失败指针。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742424600205.html">
                
                  <h1>37 | 贪心算法：如何用贪心算法实现Huffman压缩编码？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>如何理解“贪心算法”？</li>
<li>贪心算法实战分析
<ol>
<li>分糖果</li>
<li>钱币找零</li>
<li>区间覆盖</li>
</ol></li>
</ul>

<p>我们今天讲下霍夫曼编码，看看它是<strong>如何利用贪心算法来实现对数据压缩编码，有效节省数据存储空间的</strong>。</p>

<h3 id="toc_0">如何理解“贪心算法”？</h3>

<p>第一步，当我们看到这类问题的时候，首先要联想到贪心算法：针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。</p>

<p>第二步，我们尝试看下这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。</p>

<p>第三步，我们举几个例子看下贪心算法产生的结果是否是最优的。大部分情况下，举几个例子验证一下就可以了。</p>

<h3 id="toc_1">贪心算法实战分析</h3>

<p><strong>1. 分糖果</strong></p>

<p>我们有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m&lt;n），所以糖果只能分配给一部分孩子。每个糖果的大小不等，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。</p>

<p>如何分配糖果，能尽可能满足最多数量的孩子？</p>

<ol>
<li>我们可以从需求小的孩子开始分配糖果。因为满足一个需求大的孩子跟满足一个需求小的孩子，对我们期望值的贡献是一样的。</li>
<li>我们每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。</li>
</ol>

<p><strong>2. 钱币找零</strong></p>

<p>假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数不等。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？</p>

<p>在生活中，我们肯定是先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。在贡献相同期望值（纸币数目）的情况下，我们希望多贡献点金额，这样就可以让纸币数更少，这就是一种贪心算法的解决思路。</p>

<p><strong>3. 区间覆盖</strong></p>

<p>假设我们有 n 个区间，区间的起始端点和结束端点分别是 [l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？</p>

<p><img src="media/15742424600205/15759744732606.jpg" alt=""/></p>

<p>这个问题的处理思路在很多贪心算法问题中都有用到，比如任务调度、教师排课等等问题。</p>

<p>这个问题的解决思路是这样的：</p>

<ol>
<li>我们假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，我们选择几个不相交的区间，从左到右将 [lmin, rmax] 覆盖上。我们按照起始端点从小到大的顺序对这 n 个区间排序。</li>
<li>我们每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。</li>
</ol>

<p><img src="media/15742424600205/15759752450311.jpg" alt=""/></p>

<h3 id="toc_2">解答开篇</h3>

<p><strong>如何用贪心算法实现霍夫曼编码？</strong></p>

<p>假设我有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits，那有没有更加节省空间的存储方式呢？</p>

<p>假设我们通过统计分析发现，这 1000 个字符中只包含 6 种不同字符，假设它们分别是 a、b、c、d、e、f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间，每个字符我们用 3 个二进制位来表示。那存储这 1000 个字符只需要 3000bits 就可以了，比原来的存储方式节省了很多空间。不过，还有没有更加节省空间的存储方式呢？</p>

<p>霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，<mark>根据频率的不同，选择不同长度的编码</mark>。霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率。如何给不同频率的字符选择不同长度的编码呢？根据贪心的思想，我们可以<mark>把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码</mark>。</p>

<p>假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。我们把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。经过这种编码压缩之后，这 1000 个字符只需要 2100bits 就可以了。</p>

<p><img src="media/15742424600205/15759755140906.jpg" alt=""/></p>

<p>但是如何根据字符出现频率的不同，给不同的字符进行不同长度的编码呢？</p>

<p>我们把每个字符看作一个节点，并且辅带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p>

<p><img src="media/15742424600205/15759755413222.jpg" alt=""/></p>

<p>现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为 0，指向右子节点的边，我们统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</p>

<p><img src="media/15742424600205/15759755543037.jpg" alt=""/></p>

<h3 id="toc_3">内容小结</h3>

<p>贪心算法适用的场景比较有限。这种算法思想更多的是指导设计基础算法。比如最小生成树算法、单源最短路径算法，这些算法都用到了贪心算法。贪心算法的最难的一块是如何将要解决的问题抽象成贪心算法模型，只要这一步搞定之后，贪心算法的编码一般都很简单。</p>

<h3 id="toc_4">课后思考</h3>

<p><strong>问：在一个非负整数 a 中，我们希望从中移除 k 个数字，让剩下的数字值最小，如何选择移除哪 k 个数字呢？</strong></p>

<blockquote>
<p>答：从高位开始移除：移除高位数字比它低位数字大的那个；K 次循环。</p>
</blockquote>

<p><strong>问：假设有 n 个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同的，如何安排被服务的先后顺序，才能让这 n 个人总的等待时间最短？</strong></p>

<blockquote>
<p>由等待时间最短的开始服务</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742424638417.html">
                
                  <h1>38 | 分治算法：谈一谈大规模计算框架MapReduce中的分治思想</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>如何理解分治算法？</li>
<li>分治算法应用举例分析</li>
<li>分治思想在海量数据处理中的应用</li>
</ul>

<h3 id="toc_0">如何理解分治算法？</h3>

<p>分治算法（divide and conquer）的核心思想其实就是四个字，<mark>分而治之</mark> ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p>

<p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧。</strong>分治算法一般都比较适合用递归来实现。</p>

<p>分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p>

<ol>
<li>分解：将原问题分解成一系列子问题；</li>
<li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li>
<li>合并：将子问题的结果合并成原问题。</li>
</ol>

<p>分治算法能解决的问题，一般需要满足下面这几个条件：</p>

<ul>
<li>原问题与分解成的小问题具有相同的模式；</li>
<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；</li>
<li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li>
<li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li>
</ul>

<h3 id="toc_1">分治算法应用举例分析</h3>

<p>假设我们有 n 个数据，我们期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2。除了这两种极端情况外，我们通过计算有序对或者逆序对的个数，来表示数据的有序度或逆序度。</p>

<p><img src="media/15742424638417/15760587527848.jpg" alt=""/></p>

<p><strong>如何编程求出一组数据的有序对个数或者逆序对个数呢？</strong></p>

<p>我们套用分治的思想来求数组 A 的逆序对个数。我们可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。<br/>
如何快速计算出两个子问题 A1 与 A2 之间的逆序对个数呢？<br/>
这里就要借助归并排序算法了。归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，我们就可以计算这两个小数组的逆序对个数了。每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</p>

<p><img src="media/15742424638417/15760588080860.jpg" alt=""/></p>

<p>关于分治算法，我这还有两道比较经典的问题，你可以自己练习一下。</p>

<ul>
<li>二维平面上有 n 个点，如何快速计算出两个距离最近的点对？</li>
<li>有两个 n*n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A*B？</li>
</ul>

<h3 id="toc_2">分治思想在海量数据处理中的应用</h3>

<p>分治算法思想的应用是非常广泛的，并不仅限于指导编程和算法设计。它还经常用在海量数据处理的场景中。比如，给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而我们的机器的内存可能只有 2、3GB 这样子，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。</p>

<p>要解决这种数据量大到内存装不下的问题，我们就可以利用分治的思想。我们可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。</p>

<p>比如刚刚举的那个例子，给 10GB 的订单排序，我们就可以先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。</p>

<h3 id="toc_3">解答开篇</h3>

<p><strong>为什么说 MapReduce 的本质就是分治思想？</strong></p>

<p>实际上，MapReduce 框架只是一个任务调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。</p>

<h3 id="toc_4">内容小结</h3>

<p>今天我们讲了一种应用非常广泛的算法思想，分治算法。</p>

<p>分治算法用四个字概括就是“分而治之”，将原问题划分成 n 个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。这个思想非常简单、好理解。</p>

<p>今天我们讲了两种分治算法的典型的应用场景，一个是用来指导编码，降低问题求解的时间复杂度，另一个是解决海量数据处理问题。比如 MapReduce 本质上就是利用了分治思想。</p>

<p>我们也时常感叹 Google 的创新能力如此之强，总是在引领技术的发展。实际上，创新并非离我们很远，创新的源泉来自对事物本质的认识。无数优秀架构设计的思想来源都是基础的数据结构和算法，这本身就是算法的一个魅力所在。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742424672731.html">
                
                  <h1>39 | 回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>如何理解“回溯算法”？</li>
<li>两个回溯算法的经典应用
<ol>
<li>0-1 背包</li>
<li>正则表达式</li>
</ol></li>
</ul>

<p>我们在第 31 节提到，深度优先搜索算法利用的是回溯算法思想。回溯算法除了用来指导像深度优先搜索这种经典的算法设计之外，还可以用在很多实际的软件开发场景中，比如正则表达式匹配、编译原理中的语法分析等。除此之外，很多经典的数学问题都可以用回溯算法解决，比如数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列等等。</p>

<h3 id="toc_0">如何理解“回溯算法”？</h3>

<p>笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指我们前面讲过的图的搜索算法，而是在一组可能的解中，搜索满足期望的解。</p>

<p>回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。</p>

<p>我举一个经典的回溯例子，我想你可能已经猜到了，那就是八皇后问题。我们有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。你可以看我画的图，第一幅图是满足条件的一种方法，第二幅图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。</p>

<p><img src="media/15742424672731/15760600790363.jpg" alt=""/></p>

<p>我们把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，我们不停地检查当前的方法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种方法，继续尝试。</p>

<p>回溯算法非常适合用<mark>递归</mark>代码实现。</p>

<h3 id="toc_1">两个回溯算法的经典应用</h3>

<p><strong>1. 0-1 背包</strong><br/>
我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p>

<p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 n 个物品来说，总的装法就有 2<sup>n</sup> 种，去掉总重量超过 Wkg 的，从剩下的装法中选择总重量最接近 Wkg 的。不过，我们如何才能不重复地穷举出这 2<sup>n</sup> 种装法呢？</p>

<p>这里就可以用回溯的方法。我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p>

<p>这里还稍微用到了一点搜索剪枝的技巧，就是当发现已经选择的物品的重量超过 Wkg 之后，我们就停止继续探测剩下的物品。</p>

<pre><code class="language-text">public int maxW = Integer.MIN_VALUE; //存储背包中物品总重量的最大值
// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；
// w背包重量；items表示每个物品的重量；n表示物品个数
// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：
// f(0, 0, a, 10, 100)
public void f(int i, int cw, int[] items, int n, int w) {
  if (cw == w || i == n) { // cw==w表示装满了;i==n表示已经考察完所有的物品
    if (cw &gt; maxW) maxW = cw;
    return;
  }
  f(i+1, cw, items, n, w);
  if (cw + items[i] &lt;= w) {// 已经超过可以背包承受的重量的时候，就不要再装了
    f(i+1,cw + items[i], items, n, w);
  }
}
</code></pre>

<p><strong>2. 正则表达式</strong></p>

<p>正则表达式中，最重要的就是通配符，通配符结合在一起，可以表达非常丰富的语义。为了方便讲解，我假设正则表达式中只包含“*”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“*”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符。基于以上背景假设，我们看下，如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p>

<p>我们依次考察正则表达式中的每个字符，当是非通配符时，我们就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。</p>

<p>如果遇到特殊字符的时候，我们就有多种处理方式了，也就是所谓的岔路口，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，我们就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p>

<h3 id="toc_2">内容小结</h3>

<p>回溯算法的思想非常简单，大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。</p>

<p>尽管回溯算法的原理非常简单，但是却可以解决很多问题，比如我们开头提到的深度优先搜索、八皇后、0-1 背包问题、图的着色、旅行商问题、数独、全排列、正则表达式匹配等等。</p>

<h3 id="toc_3">课后思考</h3>

<p><strong>现在我们对今天讲到的 0-1 背包问题稍加改造，如果每个物品不仅重量不同，价值也不同。如何在不超过背包重量的情况下，让背包中的总价值最大？</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742424717033.html">
                
                  <h1>40 | 初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>动态规划学习路线</li>
<li>0-1 背包问题</li>
<li>0-1 背包问题升级版</li>
</ul>

<h3 id="toc_0">动态规划学习路线</h3>

<p>动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。</p>

<p>为了让你更容易理解动态规划，我分了三节给你讲解。这三节分别是，初识动态规划、动态规划理论、动态规划实战。</p>

<p>第一节，我会通过两个非常经典的动态规划问题模型，向你展示我们为什么需要动态规划，以及动态规划解题方法是如何演化出来的。实际上，你只要掌握了这两个例子的解决思路，对于其他很多动态规划问题，你都可以套用类似的思路来解决。</p>

<p>第二节，我会总结动态规划适合解决的问题的特征，以及动态规划解题思路。除此之外，我还会将贪心、分治、回溯、动态规划这四种算法思想放在一起，对比分析它们各自的特点以及适用的场景。</p>

<p>第三节，我会教你应用第二节讲的动态规划理论知识，实战解决三个非常经典的动态规划问题，加深你对理论的理解。</p>

<h3 id="toc_1">0-1 背包问题</h3>

<p>对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？</p>

<p>我们假设背包的最大承载重量是 9。我们有 5 个不同的物品，每个物品的重量分别是 2，2，4，6，3。如果我们把这个例子的回溯求解过程，用递归树画出来，就是下面这个样子：</p>

<p><img src="media/15742424717033/15760623533035.jpg" alt=""/></p>

<p>递归树中的每个节点表示一种状态，我们用（i, cw）来表示。其中，i 表示将要决策<mark>第几个物品是否装入背包</mark>，cw 表示<mark>当前背包中物品的总重量</mark>。比如，（2，2）表示我们将要决策第 2 个物品是否装入背包，在决策前，背包中物品的总重量是 2。</p>

<p>从递归树中，你应该能会发现，有些子问题的求解是重复的，比如图中 f(2, 2) 和 f(3,4) 都被重复计算了两次。我们可以借助递归那一节讲的“备忘录”的解决方式，记录已经计算好的 f(i, cw)，当再次计算到重复的 f(i, cw) 的时候，可以直接从备忘录中取出来用，就不用再递归计算了，这样就可以避免冗余计算。</p>

<pre><code class="language-text">private int maxW = Integer.MIN_VALUE; // 结果放到maxW中
private int[] weight = {2，2，4，6，3};  // 物品重量
private int n = 5; // 物品个数
private int w = 9; // 背包承受的最大重量
private boolean[][] mem = new boolean[5][10]; // 备忘录，默认值false
public void f(int i, int cw) { // 调用f(0, 0)
  if (cw == w || i == n) { // cw==w表示装满了，i==n表示物品都考察完了
    if (cw &gt; maxW) maxW = cw;
    return;
  }
  if (mem[i][cw]) return; // 重复状态
  mem[i][cw] = true; // 记录(i, cw)这个状态
  f(i+1, cw); // 选择不装第i个物品
  if (cw + weight[i] &lt;= w) {
    f(i+1,cw + weight[i]); // 选择装第i个物品
  }
}
</code></pre>

<p>这种解决方法非常好。实际上，它已经跟动态规划的执行效率基本上没有差别。但是，多一种方法就多一种解决思路，我们现在来看看动态规划是怎么做的。</p>

<p>我们把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点。</p>

<p>我们把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。我们可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量），也就是例子中的 9。于是，我们就成功避免了每层状态个数的指数级增长。</p>

<p>我们用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。</p>

<p>第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。我们用 states[0][0]=true 和 states[0][2]=true 来表示这两种状态。</p>

<p>第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。我们用 states[1][0]=true，states[1][2]=true，states[1][4]=true 来表示这三种状态。</p>

<p>以此类推，直到考察完所有的物品后，整个 states 状态数组就都计算好了。我把整个计算的过程画了出来，你可以看看。图中 0 表示 false，1 表示 true。我们只需要在最后一层，找一个值为 true 的最接近 w（这里是 9）的值，就是背包中物品总重量的最大值。</p>

<p><img src="media/15742424717033/15760644982240.jpg" alt=""/><br/>
<img src="media/15742424717033/15760645046695.jpg" alt=""/></p>

<pre><code class="language-text">weight:物品重量，n:物品个数，w:背包可承载重量
public int knapsack(int[] weight, int n, int w) {
  boolean[][] states = new boolean[n][w+1]; // 默认值false
  states[0][0] = true;  // 第一行的数据要特殊处理，可以利用哨兵优化
  if (weight[0] &lt;= w) {
    states[0][weight[0]] = true;
  }
  for (int i = 1; i &lt; n; ++i) { // 动态规划状态转移
    for (int j = 0; j &lt;= w; ++j) {// 不把第i个物品放入背包
      if (states[i-1][j] == true) states[i][j] = states[i-1][j];
    }
    for (int j = 0; j &lt;= w-weight[i]; ++j) {//把第i个物品放入背包
      if (states[i-1][j]==true) states[i][j+weight[i]] = true;
    }
  }
  for (int i = w; i &gt;= 0; --i) { // 输出结果
    if (states[n-1][i] == true) return i;
  }
  return 0;
}
</code></pre>

<p>实际上，这就是一种用动态规划解决问题的思路。我们把问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。</p>

<p>那动态规划解决方案的时间复杂度是多少呢？</p>

<p>这个代码的时间复杂度非常好分析，耗时最多的部分就是代码中的两层 for 循环，所以时间复杂度是 O(n*w)。n 表示物品个数，w 表示背包可以承载的总重量。</p>

<h3 id="toc_2">0-1 背包问题升级版</h3>

<p>我们现在引入物品价值这一变量。对于一组不同重量、不同价值、不可分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？</p>

<p>这个问题依旧可以用回溯算法来解决。在递归树中，每个节点表示一个状态。现在我们需要 3 个变量（i, cw, cv）来表示一个状态。其中，i 表示即将要决策第 i 个物品是否装入背包，cw 表示当前背包中物品的总重量，cv 表示当前背包中物品的总价值。</p>

<p><img src="media/15742424717033/15760648707513.jpg" alt=""/></p>

<p>我们发现，在递归树中，有几个节点的 i 和 cw 是完全相同的，比如 f(2,2,4) 和 f(2,2,3)。在背包中物品总重量一样的情况下，f(2,2,4) 这种状态对应的物品总价值更大，我们可以舍弃 f(2,2,3) 这种状态，只需要沿着 f(2,2,4) 这条决策路线继续往下决策就可以。</p>

<p>也就是说，对于 (i, cw) 相同的不同状态，那我们只需要保留 cv 值最大的那个，继续递归处理，其他状态不予考虑。</p>

<p>如果用回溯算法，这个问题就没法再用“备忘录”解决了。所以，我们就需要换一种思路，看看动态规划是不是更容易解决这个问题？</p>

<p>我们还是把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个阶段决策完之后，背包中的物品的总重量以及总价值，会有多种情况，也就是会达到多种不同的状态。</p>

<p>我们用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。不过这里数组存储的值不再是 boolean 类型的了，而是当前状态对应的最大总价值。我们把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态。</p>

<pre><code class="language-text">public static int knapsack3(int[] weight, int[] value, int n, int w) {
  int[][] states = new int[n][w+1];
  for (int i = 0; i &lt; n; ++i) { // 初始化states
    for (int j = 0; j &lt; w+1; ++j) {
      states[i][j] = -1;
    }
  }
  states[0][0] = 0;
  if (weight[0] &lt;= w) {
    states[0][weight[0]] = value[0];
  }
  for (int i = 1; i &lt; n; ++i) { //动态规划，状态转移
    for (int j = 0; j &lt;= w; ++j) { // 不选择第i个物品
      if (states[i-1][j] &gt;= 0) states[i][j] = states[i-1][j];
    }
    for (int j = 0; j &lt;= w-weight[i]; ++j) { // 选择第i个物品
      if (states[i-1][j] &gt;= 0) {
        int v = states[i-1][j] + value[i];
        if (v &gt; states[i][j+weight[i]]) {
          states[i][j+weight[i]] = v;
        }
      }
    }
  }
  // 找出最大值
  int maxvalue = -1;
  for (int j = 0; j &lt;= w; ++j) {
    if (states[n-1][j] &gt; maxvalue) maxvalue = states[n-1][j];
  }
  return maxvalue;
}
</code></pre>

<p>时间复杂度是 O(n*w)，空间复杂度也是 O(n*w)。</p>

<h3 id="toc_3">课后思考</h3>

<p>“杨辉三角”不知道你听说过吗？我们现在对它进行一些改造。每个位置的数字可以随意填写，经过某个数字只能到达下面一层相邻的两个数字。</p>

<p>假设你站在第一层，往下移动，我们把移动到最底层所经过的所有数字之和，定义为路径的长度。请你编程求出从最高层移动到最底层的最短路径长度。</p>

<p><img src="media/15742424717033/15760652019393.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742424750929.html">
                
                  <h1>41 | 动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>“一个模型三个特征”理论讲解
<ol>
<li>最优子结构</li>
<li>无后效性</li>
<li>3. 重复子问题</li>
</ol></li>
<li>“一个模型三个特征”实例剖析</li>
<li>两种动态规划解题思路总结
<ol>
<li>状态转移表法</li>
<li>状态转移方程法</li>
</ol></li>
<li>四种算法思想比较分析</li>
</ul>

<p>什么样的问题可以用动态规划解决？解决动态规划问题的一般思考过程是什么样的？贪心、分治、回溯、动态规划这四种算法思想又有什么区别和联系？</p>

<h3 id="toc_0">“一个模型三个特征”理论讲解</h3>

<p>“<strong>一个模型</strong>”？它指的是动态规划适合解决的问题的模型。我把这个模型定义为“<strong>多阶段决策最优解模型</strong>”。</p>

<p>我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p>

<p>什么是“三个特征”？它们分别是最优子结构、无后效性和重复子问题。</p>

<h4 id="toc_1">1. 最优子结构</h4>

<p>最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。</p>

<h4 id="toc_2">2. 无后效性</h4>

<p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。</p>

<h4 id="toc_3">3. 重复子问题</h4>

<p>不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p>

<h3 id="toc_4">“一个模型三个特征”实例剖析</h3>

<p>假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？</p>

<p><img src="media/15742424750929/15761484003875.jpg" alt=""/></p>

<h3 id="toc_5">两种动态规划解题思路总结</h3>

<h4 id="toc_6">1. 状态转移表法</h4>

<p>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。</p>

<p>找到重复子问题之后，接下来，我们有两种处理思路，第一种是直接用回溯加“备忘录”的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。第二种是使用动态规划的解决方法，状态转移表法。我们先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。</p>

<p>尽管大部分状态表都是二维的，但是如果问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是高维的，比如三维、四维。那这个时候，我们就不适合用状态转移表法来解决了。</p>

<h4 id="toc_7">2. 状态转移方程法</h4>

<p>状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。一般情况下，我们有两种代码实现方法，一种是<strong>递归加“备忘录”</strong>，另一种是<strong>迭代递推</strong>。</p>

<p><strong>状态转移方程是解决动态规划的关键。</strong>如果我们能写出状态转移方程，那动态规划问题基本上就解决一大半了，而翻译成代码非常简单。但是很多动态规划问题的状态本身就不好定义，状态转移方程也就更不好想到。</p>

<h3 id="toc_8">四种算法思想比较分析</h3>

<p>如果我们将这四种算法思想分一下类，那贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个都不大一样。为什么这么说呢？前三个算法解决问题的模型，都可以抽象成我们今天讲的那个<mark>多阶段决策最优解模型</mark>，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。</p>

<p>回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p>

<p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在<mark>重复子问题</mark>这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p>

<p>贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。</p>

<p>其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。内容小结</p>

<h3 id="toc_9">内容小结</h3>

<p>我首先讲了什么样的问题适合用动态规划解决。这些问题可以总结概括为“一个模型三个特征”。其中，“一个模型”指的是，问题可以抽象成分阶段决策最优解模型。“三个特征”指的是最优子节、无后效性和重复子问题。</p>

<p>然后，我讲了两种动态规划的解题思路。它们分别是状态转移表法和状态转移方程法。其中，状态转移表法解题思路大致可以概括为，<strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码</strong>。状态转移方程法的大致思路可以概括为，<strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码</strong>。</p>

<p>最后，我们对比了之前讲过的四种算法思想。贪心、回溯、动态规划可以解决的问题模型类似，都可以抽象成多阶段决策最优解模型。尽管分治算法也能解决最优问题，但是大部分问题的背景都不适合抽象成多阶段决策模型。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15742424779150.html">
                
                  <h1>42 | 动态规划实战：如何实现搜索引擎中的拼写纠错功能？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>如何量化两个字符串的相似度？</li>
<li>如何编程计算莱文斯坦距离？</li>
<li>如何编程计算最长公共子串长度？</li>
</ul>

<h3 id="toc_0">如何量化两个字符串的相似度？</h3>

<p>如何量化两个字符串之间的相似程度呢？有一个非常著名的量化方法，那就是<strong>编辑距离</strong>（Edit Distance）。编辑距离指的就是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 0。</p>

<p>根据所包含的编辑操作种类的不同，编辑距离有多种不同的计算方式，比较著名的有<strong>莱文斯坦距离</strong>（Levenshtein distance）和<strong>最长公共子串长度</strong>（Longest common substring length）。其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，最长公共子串长度只允许增加、删除字符这两个编辑操作。</p>

<p>而且，莱文斯坦距离和最长公共子串长度，从两个截然相反的角度，分析字符串的相似程度。莱文斯坦距离的大小，表示两个字符串<mark>差异</mark>的大小；而最长公共子串的大小，表示两个字符串<mark>相似程度</mark>的大小。</p>

<p>关于这两个计算方法，我举个例子给你说明一下。这里面，两个字符串 mitcmu 和 mtacnu 的莱文斯坦距离是 3，最长公共子串长度是 4。</p>

<p><img src="media/15742424779150/15764930027615.jpg" alt=""/></p>

<h3 id="toc_1">如何编程计算莱文斯坦距离？</h3>

<p>这个问题是求把一个字符串变成另一个字符串，需要的最少编辑次数。整个求解过程，涉及多个决策阶段，我们需要依次考察一个字符串中的每个字符，跟另一个字符串中的字符是否匹配，匹配的话如何处理，不匹配的话又如何处理。所以，这个问题符合<strong>多阶段决策最优解模型</strong>。</p>

<p>我们前面讲了，贪心、回溯、动态规划可以解决的问题，都可以抽象成这样一个模型。要解决这个问题，我们可以先看一看，用最简单的回溯算法，该如何来解决。回溯是一个递归处理的过程。如果 a[i] 与 b[j] 匹配，我们递归考察 a[i+1] 和 b[j+1]。如果 a[i] 与 b[j] 不匹配，那我们有多种处理方式可选：</p>

<ul>
<li>可以删除 a[i]，然后递归考察 a[i+1] 和 b[j]；</li>
<li>可以删除 b[j]，然后递归考察 a[i] 和 b[j+1]；</li>
<li>可以在 a[i] 前面添加一个跟 b[j] 相同的字符，然后递归考察 a[i] 和 b[j+1];</li>
<li>可以在 b[j] 前面添加一个跟 a[i] 相同的字符，然后递归考察 a[i+1] 和 b[j]；</li>
<li>可以将 a[i] 替换成 b[j]，或者将 b[j] 替换成 a[i]，然后递归考察 a[i+1] 和 b[j+1]。</li>
</ul>

<p>根据回溯算法的代码实现，我们可以画出递归树，看是否存在重复子问题。如果存在重复子问题，那我们就可以考虑能否用动态规划来解决；如果不存在重复子问题，那回溯就是最好的解决方法。</p>

<p><img src="media/15742424779150/15764931617599.jpg" alt=""/></p>

<p>在递归树中，每个节点代表一个状态，状态包含三个变量 (i, j, edist)，其中，edist 表示处理到 a[i] 和 b[j] 时，已经执行的编辑操作的次数。</p>

<p>在递归树中，(i, j) 两个变量<mark>重复的节点</mark>很多，比如 (3, 2) 和 (2, 3)。对于 (i, j) 相同的节点，我们只需要<mark>保留 edist 最小的</mark>，继续递归处理就可以了，剩下的节点都可以舍弃。所以，状态就从 (i, j, edist) 变成了 (i, j, min_edist)，其中 min_edist 表示处理到 a[i] 和 b[j]，已经执行的最少编辑次数。</p>

<p>上一节我们讲的矩阵最短路径问题中，到达状态 (i, j) 只能通过 (i-1, j) 或 (i, j-1) 两个状态转移过来，而今天这个问题，状态 (i, j) 可能从 (i-1, j)，(i, j-1)，(i-1, j-1)== 三个状态==中的任意一个转移过来。</p>

<p><img src="media/15742424779150/15764933363506.jpg" alt=""/></p>

<p>基于刚刚的分析，我们可以尝试着将把状态转移的过程，用公式写出来。这就是我们前面讲的状态转移方程。</p>

<pre><code class="language-text">如果：a[i]!=b[j]，那么：min_edist(i, j)就等于：
min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)

如果：a[i]==b[j]，那么：min_edist(i, j)就等于：
min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))

其中，min表示求三数中的最小值。     
</code></pre>

<p>了解了状态与状态之间的递推关系，我们画出一个二维的状态表，按行依次来填充状态表中的每个值。</p>

<p><img src="media/15742424779150/15764933988811.jpg" alt=""/></p>

<p>当我们拿到一个问题的时候，<strong>我们可以先不思考，计算机会如何实现这个问题，而是单纯考虑“人脑”会如何去解决这个问题</strong>。人脑比较倾向于思考具象化的、摸得着看得见的东西，不适合思考过于抽象的问题。所以，我们需要把抽象问题具象化。那如何具象化呢？我们可以实例化几个测试数据，通过人脑去分析具体实例的解，然后总结规律，再尝试套用学过的算法，看是否能够解决。</p>

<p>除此之外，我还有一个非常有效、但也算不上技巧的东西，我也反复强调过，那就是<strong>多练</strong>。实际上，等你做多了题目之后，自然就会有感觉，看到问题，立马就能想到能否用动态规划解决，然后直接就可以寻找最优子结构，写出动态规划方程，然后将状态转移方程翻译成代码。</p>

<h3 id="toc_2">如何编程计算最长公共子串长度？</h3>

<p>这个问题的解决思路，跟莱文斯坦距离的解决思路非常相似，也可以用动态规划解决。我刚刚已经详细讲解了莱文斯坦距离的动态规划解决思路，所以，针对这个问题，我直接定义状态，然后写状态转移方程。</p>

<p>每个状态还是包括三个变量 (i, j, max_lcs)，max_lcs 表示 a[0…i] 和 b[0…j] 的最长公共子串长度。那 (i, j) 这个状态都是由哪些状态转移过来的呢？</p>

<p>我们先来看回溯的处理思路。我们从 a[0] 和 b[0] 开始，依次考察两个字符串中的字符是否匹配。</p>

<ul>
<li>如果 a[i] 与 b[j] 互相匹配，我们将最大公共子串长度加一，并且继续考察 a[i+1] 和 b[j+1]。</li>
<li>如果 a[i] 与 b[j] 不匹配，最长公共子串长度不变，这个时候，有两个不同的决策路线：
<ul>
<li>删除 a[i]，或者在 b[j] 前面加上一个字符 a[i]，然后继续考察 a[i+1] 和 b[j]；</li>
<li>删除 b[j]，或者在 a[i] 前面加上一个字符 b[j]，然后继续考察 a[i] 和 b[j+1]。</li>
</ul></li>
</ul>

<p>反过来也就是说，如果我们要求 a[0…i] 和 b[0…j] 的最长公共长度 max_lcs(i, j)，我们只有可能通过下面三个状态转移过来：</p>

<ul>
<li>(i-1, j-1, max_lcs)，其中 max_lcs 表示 a[0…i-1] 和 b[0…j-1] 的最长公共子串长度；</li>
<li>(i-1, j, max_lcs)，其中 max_lcs 表示 a[0…i-1] 和 b[0…j] 的最长公共子串长度；</li>
<li>(i, j-1, max_lcs)，其中 max_lcs 表示 a[0…i] 和 b[0…j-1] 的最长公共子串长度。</li>
</ul>

<p>如果我们把这个转移过程，用状态转移方程写出来，就是下面这个样子：</p>

<pre><code class="language-text">如果：a[i]==b[j]，那么：max_lcs(i, j)就等于：
max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))；

如果：a[i]!=b[j]，那么：max_lcs(i, j)就等于：
max(max_lcs(i-1,j-1), max_lcs(i-1, j), max_lcs(i, j-1))；

其中max表示求三数中的最大值。
</code></pre>

<h3 id="toc_3">解答开篇</h3>

<p>当用户在搜索框内，输入一个拼写错误的单词时，我们就拿这个单词跟词库中的单词一一进行比较，计算编辑距离，将编辑距离最小的单词，作为纠正之后的单词，提示给用户。</p>

<p>这就是拼写纠错最基本的原理。不过，真正用于商用的搜索引擎，拼写纠错功能显然不会就这么简单。一方面，单纯利用编辑距离来纠错，效果并不一定好；另一方面，词库中的数据量可能很大，搜索引擎每天要支持海量的搜索，所以对纠错的性能要求很高。</p>

<ul>
<li>我们并不仅仅取出编辑距离最小的那个单词，而是取出编辑距离最小的 TOP 10，然后根据其他参数，决策选择哪个单词作为拼写纠错单词。比如使用搜索热门程度来决定哪个单词作为拼写纠错单词。</li>
<li>我们还可以用多种编辑距离计算方法，比如今天讲到的两种，然后分别编辑距离最小的 TOP 10，然后求交集，用交集的结果，再继续优化处理。</li>
<li>我们还可以通过统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词。搜索引擎在拼写纠错的时候，首先在这个最长被拼错单词列表中查找。如果一旦找到，直接返回对应的正确的单词。这样纠错的效果非常好。</li>
<li>我们还有更加高级一点的做法，引入个性化因素。针对每个用户，维护这个用户特有的搜索喜好，也就是常用的搜索关键词。当用户输入错误的单词的时候，我们首先在这个用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词。</li>
</ul>

<p>针对纠错性能方面，我们也有相应的优化方式。我讲两种分治的优化思路。</p>

<ul>
<li>如果纠错功能的 TPS 不高，我们可以部署多台机器，每台机器运行一个独立的纠错功能。当有一个纠错请求的时候，我们通过负载均衡，分配到其中一台机器，来计算编辑距离，得到纠错单词。</li>
<li>如果纠错系统的响应时间太长，也就是，每个纠错请求处理时间过长，我们可以将纠错的词库，分割到很多台机器。当有一个纠错请求的时候，我们就将这个拼写错误的单词，同时发送到这多台机器，让多台机器并行处理，分别得到编辑距离最小的单词，然后再比对合并，最终决定出一个最优的纠错单词。</li>
</ul>

<h3 id="toc_4">课后思考</h3>

<p>我们有一个数字序列包含 n 个不同的数字，如何求出这个序列中的最长递增子序列长度？比如 2, 9, 3, 6, 5, 1, 7 这样一组数字序列，它的最长递增子序列就是 2, 3, 5, 7，所以最长递增子序列的长度是 4。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15758905800959.html">
                
                  <h1>43 | 拓扑排序：如何确定代码源文件的编译依赖关系？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/09</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15758905852480.html">
                
                  <h1>44 | 最短路径：地图软件是如何计算出最优出行路径的？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/09</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15758905884334.html">
                
                  <h1>45 | 位图：如何实现网页爬虫中的URL去重功能？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/09</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15758905924696.html">
                
                  <h1>46 | 概率统计：如何利用朴素贝叶斯算法过滤垃圾短信？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/09</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15758905964159.html">
                
                  <h1>47 | 向量空间：如何实现一个简单的音乐推荐系统？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/09</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15758906020012.html">
                
                  <h1>48 | B+树：MySQL数据库索引是如何实现的？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/09</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15758906056638.html">
                
                  <h1>49 | 搜索：如何用A*搜索算法实现游戏中的寻路功能？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/09</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15758906098066.html">
                
                  <h1>50 | 索引：如何在海量数据中快速查找某个数据？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/09</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15758906151854.html">
                
                  <h1>51 | 并行算法：如何利用并行处理提高算法的执行效率？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/09</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html'>极客-数据结构与算法之美</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html"><strong>Android开发艺术探索</strong></a>
        
            <a href="Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html"><strong>Android进阶之光</strong></a>
        
            <a href="Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html"><strong>Android进阶解密</strong></a>
        
            <a href="Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html"><strong>Java核心技术</strong></a>
        
            <a href="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA.html"><strong>深入理解虚拟机</strong></a>
        
            <a href="%E6%9E%81%E5%AE%A2-Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98.html"><strong>极客-Java并发实战</strong></a>
        
            <a href="%E6%9E%81%E5%AE%A2-%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html"><strong>极客-深入拆解Java虚拟机</strong></a>
        
            <a href="%E6%9E%81%E5%AE%A2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E.html"><strong>极客-数据结构与算法之美</strong></a>
        
            <a href="%E8%8F%9C%E9%B8%9F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>菜鸟-设计模式</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15789721660565.html">0 Android开发艺术探索-目录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15789731325545.html">0 Android进阶之光-目录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15789733843338.html">0 Android进阶解密-目录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15790568493890.html">0 Java核心技术-目录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15749250659113.html">0 深入理解Java虚拟机-目录</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
