<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
  
  
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html">开发艺术探索</a></li>
        
            <li><a href="%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html">进阶之光</a></li>
        
            <li><a href="%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html">进阶解密</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15789721660565.html">
                
                  <h1>0 Android开发艺术探索-目录</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><a href="15511960673056.html">01 Activity的生命周期和启动模式</a><br/>
<a href="15513690535659.html">02 IPC机制</a><br/>
<a href="15760469998530.html">03 View的事件体系</a><br/>
<a href="15760471697724.html">04 View的工作原理</a><br/>
05 理解RemoteViews<br/>
<a href="15518627296094.html">06 Drawable</a><br/>
<a href="15518627036171.html">07 Android动画深入分析</a><br/>
<a href="15518627558192.html">08 理解Window和WindowManager </a><br/>
<a href="15518627494454.html">09 四大组件的工作过程</a><br/>
<a href="15518627703620.html">10 Android的消息机制</a><br/>
<a href="15518627802999.html">11 Android的线程和线程池</a><br/>
<a href="15518627622491.html">12 Bitmap的加载和Cache</a><br/>
13 综合技术<br/>
14 JNI和NDK编程<br/>
<a href="15518627896387.html">15 性能优化</a></p>

<p><a href="media/15789721660565/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.xmind">Android开发艺术探索.xmind</a></p>

<p><img src="media/15747599072091/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.png" alt="Android开发艺术探索"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15789731325545.html">
                
                  <h1>0 Android进阶之光-目录</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>01 Android新特性<br/>
02 Material Design<br/>
03 View体系与自定义View<br/>
<a href="15536970568598.html">04 多线程编程</a><br/>
<a href="15536970792185.html">05 网络编程与网络框架</a><br/>
06 设计模式<br/>
<a href="15536971035774.html">07 事件总线</a><br/>
<a href="15536971152612.html">08 函数响应式编程</a><br/>
<a href="15536971258250.html">09 注入与依赖注入框架</a><br/>
10 应用架构设计<br/>
11 系统架构与MediaPlayer框架</p>

<p><a href="media/15789731325545/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.xmind">Android进阶之光.xmind</a></p>

<p><img src="media/15789731325545/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.png" alt="Android进阶之光"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html'>进阶之光</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15789733843338.html">
                
                  <h1>0 Android进阶解密-目录</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>01 Android系统架构<br/>
<a href="15537009005767.html">02 Android系统启动</a><br/>
<a href="15537009111256.html">03 应用程序进程启动过程</a><br/>
<a href="15537009244450.html">04 四大组件的工作过程</a><br/>
<a href="15537009340660.html">05 理解上下文Context</a><br/>
<a href="15537009469734.html">06 理解ActivityManagerService</a><br/>
<a href="15537009631998.html">07 理解WindowManager</a><br/>
<a href="15537009745315.html">08 理解WindowManagerService</a><br/>
09 JNI原理<br/>
<a href="15537010008552.html">10 Java虚拟机</a><br/>
<a href="15537010053206.html">11 Dalvik和ART</a><br/>
<a href="15537010145803.html">12 理解ClassLoader</a><br/>
<a href="15537010271155.html">13 热修复原理</a><br/>
<a href="15537010310819.html">14 Hook技术</a><br/>
<a href="15537010351262.html">15 插件化技术</a><br/>
<a href="15537010402151.html">16 绘制优化</a><br/>
<a href="15537010506228.html">17 内存优化</a></p>

<p><a href="media/15789733843338/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.xmind">Android进阶解密.xmind</a></p>

<p><img src="media/15789733843338/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.png" alt="Android进阶解密"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15511960673056.html">
                
                  <h1>01 Activity的生命周期和启动模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ol>
<li>典型情况：在有用户参与的情况下，Activity所经过的生命周期的改变</li>
<li>异常情况：Activity被系统回收或者由于当前设备的Configuration发生改变从而导致Activity被销毁重建。</li>
</ol>

<h2 id="toc_0">1.1 Activity的生命周期全面分析 / 1</h2>

<h3 id="toc_1">1.1.1 典型情况下的生命周期分析 / 2</h3>

<p><img src="media/15511960673056/15762206826291.jpg" alt="" style="width:473px;"/></p>

<ul>
<li>onStart和onResume，onPause和onStop的区别？
<ul>
<li>onStart和onStop是从Activity是否可见来回调的</li>
<li>onResume和onPause是从Activity是否位于前台这个角度来回调的。</li>
</ul></li>
<li>当前Activity为A，打开ActivityB，A的onPause会先于B的onResume执行。所以不能在onPause中执行重量级的操作，因为onPause方法执行完新的Activity的onResume才可以执行。</li>
</ul>

<h3 id="toc_2">1.1.2 异常情况下的生命周期分析 / 8</h3>

<p><strong>情况1：资源相关的系统配置发生改变导致Activity被杀死并重新创建</strong></p>

<ol>
<li>Activity异常状态终止时，系统会调用onSaveInstanceState来保存Activity的状态</li>
<li>当Activity被重新创建时，系统会调用onRestoreInstanceState，同时把被销毁时保存的Bundle对象传递给方法。</li>
<li>系统默认恢复的：文本框的输入、ListView的滚动位置</li>
<li>保存和恢复View的层次结构：委托上层保存数据 Activity &gt; Window &gt; ViewGroup(DecorView) 委托思想 上层委托下层，父容器委托子元素处理事情。</li>
</ol>

<p><strong>情况2：内存资源不足导致低优先级的Activity被杀死</strong></p>

<ol>
<li>Activity按优先级从高到低：
<ol>
<li>前台Activity：正在和用户交互的Activity</li>
<li>可见但非前台Activity：有弹窗的Activity</li>
<li>后台Activity：已经被暂停的Activity</li>
</ol></li>
<li>系统配置发生改变时不重建Activity的方法：
<ol>
<li>android:configChange=&quot;orientation&quot;</li>
</ol></li>
</ol>

<h2 id="toc_3">1.2 Activity的启动模式 / 16</h2>

<h3 id="toc_4">1.2.1 Activity的LaunchMode / 16</h3>

<p><strong>四种启动模式</strong></p>

<ol>
<li>standard：标准模式</li>
<li>singtop：栈顶复用模式，位于栈顶时不会重复创建</li>
<li>singleTask：栈内复用模式，实例以上Activity全部出栈，把实例调到栈顶。</li>
<li>singleInstance：单实例模式，创建实例时会创建新的任务栈</li>
</ol>

<p><strong>TaskAffinity 任务相关性</strong></p>

<ol>
<li>taskAffinity：标识一个Activity所需要的任务栈的名字</li>
<li>默认Activity的栈名为包名</li>
<li>主要和singTask或allowTaskReparenting属性配对使用
<ol>
<li>taskAffinity+singleTask，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中</li>
<li>taskAffinity+allowTaskReparenting，应用A启动应用B的某个Activity后，此Activity的allowTaskReparenting为true时，此Activity会直接从应用A的任务栈转移到B的任务栈中。</li>
</ol></li>
</ol>

<h3 id="toc_5">1.2.2 Activity的Flags / 27</h3>

<p>Flags影响启动模式、运行状态等</p>

<ol>
<li>FLAG_ACTIVITY_NEW_TASK</li>
<li>FLAG_ACTIVITY_SINGLE_TOP</li>
<li>FLAG_ACTIVITY_CLEAR_TOP</li>
<li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</li>
</ol>

<h2 id="toc_6">1.3 IntentFilter的匹配规则 / 28</h2>

<p>Activity的隐式调用需要Intent能够匹配目标组件的IntentFilter中的过滤信息，如果不匹配将无法启动目标Activity。</p>

<p><strong>匹配规则：</strong></p>

<ol>
<li>一个intent-filter中可以有多个cation、category、data</li>
<li>一个Intent同时匹配action、category、data 才算完全匹配，只有完全匹配才能成功启动目标Activity。</li>
<li><p>一个Activity 中可以有多个intent-filter，只要能匹配任何一组intent-filter即可成功启动对应的Activity。</p></li>
</ol>

<ul>
<li>action的匹配规则
<ul>
<li>要求Intent中的action存在，且必须和过滤规则中的其中一个action相同。</li>
</ul></li>
<li>category的匹配规则
<ul>
<li>要求Intent 中如果含有category,那么所有的category都必须和过滤规则中的其中一个category相同。</li>
</ul></li>
<li>data的匹配规则
<ul>
<li>如果过滤规则中定义了data, 那么Intent 中必须也要定义可匹配的data。</li>
<li>data由两部分组成，mineType和URI。
<ul>
<li>mimeType指媒体类型，比如image/jpeg、audio/mpeg4-generic和video/*等，可以表示图片、文本、视频等不同的媒体格式。</li>
<li>URI包含的数据就比较多了，URI结构：<code>scheme://host:port/path|pathPrefix|pathPattern</code></li>
<li>Scheme、Host、Port、Path等</li>
</ul></li>
</ul></li>
<li>隐式启动一个Activity时，可能出现错误，判断是否有Activity符合匹配规则：
<ul>
<li>PackageManager.resolveActivity或Intent.resolveActivity，返回最佳匹配的Activity信息</li>
<li>queryIntentActivities，返回所有成功的Activity信息</li>
</ul></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/02/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15536968610805.html">
                
                  <h1>01 Android新特性</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html'>进阶之光</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537008898716.html">
                
                  <h1>01 Android系统架构</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">1.1 Android系统架构</h2>

<h2 id="toc_1">1.2 Android系统源码目录</h2>

<h3 id="toc_2">1.2.1 整体结构</h3>

<h3 id="toc_3">1.2.2 应用层部分</h3>

<h3 id="toc_4">1.2.3 应用框架层部分</h3>

<h3 id="toc_5">1.2.4 C/C++程序库部分</h3>

<h2 id="toc_6">1.3 源码阅读</h2>

<h3 id="toc_7">1.3.1 在线阅读</h3>

<h3 id="toc_8">1.3.2 使用Source Insight</h3>

<h2 id="toc_9">1.4 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009005767.html">
                
                  <h1>02 Android系统启动</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">2.1 init进程启动过程</h2>

<h3 id="toc_1">2.1.1 引入init进程</h3>

<p>Android系统启动流程的前几步：</p>

<ol>
<li>启动电源以及系统启动</li>
<li>引导程序Bootloader</li>
<li>linux内核启动</li>
<li>init进程启动</li>
</ol>

<h3 id="toc_2">2.1.2 init进程的入口函数</h3>

<h3 id="toc_3">2.1.3 解析init.rc</h3>

<h3 id="toc_4">2.1.4 解析Service类型语句</h3>

<h3 id="toc_5">2.1.5 init启动Zygote</h3>

<h3 id="toc_6">2.1.6 属性服务</h3>

<h3 id="toc_7">2.1.7 init进程启动总结</h3>

<p>init进程主要做了三件事：</p>

<ol>
<li>创建一些文件夹并挂载设备</li>
<li>初始化和启动属性服务</li>
<li>解析init.rc配置文件并启动zygote进程</li>
</ol>

<h2 id="toc_8">2.2 Zygote进程启动过程</h2>

<h3 id="toc_9">2.2.1 Zygote概述</h3>

<p>在Android系统中，DVM(Dalvik虚拟机)、应用程序进程以及运行系统的关键服务的SystemServer进程都是由Zygote进程来创建的，我们也将它称为孵化器。它通过fock(复制进程)的形式来创建应用程序进程和SystemServer进程，由于Zygote进程在启动时会创建DVM，因此通过fock而创建的应用程序进程和SystemServer进程可以在内部获取一个DVM的实例拷贝。</p>

<h3 id="toc_10">2.2.2 Zygote启动脚本</h3>

<h3 id="toc_11">2.2.3 Zygote进程启动过程介绍</h3>

<p><img src="media/15537009005767/15766612281852.jpg" alt="" style="width:660px;"/></p>

<h3 id="toc_12">2.2.4 Zygote进程启动总结</h3>

<p>Zygote进程共做了如下几件事：</p>

<ol>
<li>创建AppRuntime并调用其start方法，启动Zygote进程。</li>
<li>创建JVM并为JVM注册JNI方法。</li>
<li>通过JNI调用ZygoteInit的main函数进入Zygote的Java框架层。</li>
<li>通过registerZygoteSocket函数创建服务端Socket，并通过runSelectLoop函数等待ActivityManagerService的请求来创建新的应用程序进程。</li>
<li>启动SystemServer进程。</li>
</ol>

<h2 id="toc_13">2.3 SystemServer处理过程</h2>

<h3 id="toc_14">2.3.1 Zygote处理SystemServer进程</h3>

<p><img src="media/15537009005767/15766611480971.jpg" alt="" style="width:785px;"/></p>

<h3 id="toc_15">2.3.2 解析SystemServer进程</h3>

<h3 id="toc_16">2.3.3 SystemServer进程总结</h3>

<p>SystemServer进程被创建后，主要做了如下工作:</p>

<ol>
<li>启动Binder线程池，这样就可以与其他进程进行通信。</li>
<li>创建SystemServiceManager,其用于对系统的服务进行创建、启动和生命周期管理。</li>
<li>启动各种系统服务。</li>
</ol>

<h2 id="toc_17">2.4 Launcher启动过程</h2>

<h3 id="toc_18">2.4.1 Launcher概述</h3>

<p>系统启动的最后一步是启动一个应用程序用来显示系统中已经安装的应用程序，这个应用程序就叫作Launcher。Launcher在启动过程中会请求PackageManagerService返回系统中已经安装的应用程序的信息，并将这些信息封装成一一个快捷图标列表显示在系统屏幕上，这样用户可以通过点击这些快捷图标来启动相应的应用程序。<br/>
通俗来讲Launcher就是Android系统的桌面，它的作用主要有以下两点:</p>

<ol>
<li>作为Android系统的启动器，用于启动应用程序。</li>
<li>作为Android系统的桌面，用于显示和管理应用程序的快捷图标或者其他桌面组件。</li>
</ol>

<h3 id="toc_19">2.4.2 Launcher启动过程介绍</h3>

<p><img src="media/15537009005767/15766631518684.jpg" alt="" style="width:813px;"/></p>

<h3 id="toc_20">2.4.3 Launcher中应用图标显示过程</h3>

<h2 id="toc_21">2.5 Android系统启动流程</h2>

<ol>
<li>启动电源以及系统启动<br/>
当电源按下时引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序Bootloader到RAM，然后执行。</li>
<li>引导程序BootLoader<br/>
引导程序BootLoader是在Android操作系统开始运行前的一个小程序，它的主要作用是把系统OS拉起来并运行。</li>
<li>Linux内核启动<br/>
内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当内核完成系统设置，它首先在系统文件中寻找init.rc文件，并启动init进程。</li>
<li>init进程启动<br/>
初始化和启动属性服务，并且启动Zygote进程。</li>
<li>Zygote进程启动<br/>
创建JavaVM并为JavaVM注册JNI，创建服务端Socket，启动SystemServer进程。</li>
<li>SystemServer进程启动<br/>
启动Binder线程池和SystemServiceManager，并且启动各种系统服务。</li>
<li>Launcher启动</li>
</ol>

<p><img src="media/15537009005767/15766641511208.jpg" alt="" style="width:480px;"/></p>

<h2 id="toc_22">2.6 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15513690535659.html">
                
                  <h1>02 IPC机制</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">2.1 Android IPC简介</h2>

<ol>
<li><strong>IPC</strong> Inter-Process Communication，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。
<ul>
<li><strong>进程</strong>：一个执行单元，PC和移动设备上指一个程序或应用</li>
<li><strong>线程</strong>：CPU调度的最小单元，一种有限的系统资源</li>
</ul></li>
<li>为什么需要多进程？
<ol>
<li>一个应用因为某些原因需要采用多进程模式来实现。比如某些模块运行在单独进程中，或者为了更多的内存空间</li>
<li>向其他应用获取数据</li>
</ol></li>
</ol>

<h2 id="toc_1">2.2 Android中的多进程模式</h2>

<h3 id="toc_2">2.2.1 开启多进程模式</h3>

<p>指定<code>android:process</code>属性开启多进程模式：</p>

<ul>
<li>&quot;:&quot;：当前应用的私有进程，其他应用的组件不可以和它跑在一个进程中；</li>
<li>&quot;.&quot;：全局进程，其他应用通过ShareUID方式可以和他跑在同一个进程中。</li>
</ul>

<p>Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。两个应用通过ShareUID跑在同一个进程，需要这两个应用有相同的ShareUID并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录，组件信息等，不管他们是否跑在同一个进程中。如果在同一个进程中，还可以共享内存数据。</p>

<h3 id="toc_3">2.2.2 多进程模式的运行机制</h3>

<p>Android为每一个应用分配了独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间。</p>

<p><strong>使用多进程会导致的问题：</strong></p>

<ol>
<li>静态成员和单例模式完全失效</li>
<li>线程同步机制完全失效</li>
<li>SharedPreferences的可靠性下降</li>
<li>Application会创建多次</li>
</ol>

<h2 id="toc_4">2.3 IPC基础概念介绍</h2>

<p>序列化：将对象的状态信息转换为可以存储或传输的形式的过程。</p>

<h3 id="toc_5">2.3.1 Serializable接口</h3>

<ul>
<li><strong>serialVersionUID</strong>：
<ul>
<li>辅助序列化和反序列化</li>
<li>serialVersionUID相同才能反序列化成功</li>
</ul></li>
<li>两种变量不参与序列化：
<ul>
<li>静态成员属于类，不属于对象</li>
<li><code>transient</code>关键字标记的成员变量</li>
</ul></li>
<li>使用<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>进行对象的序列化和反序列化。</li>
<li>重写<code>writeObject()</code>和<code>readObject()</code>方法可以重写序列化和反序列化过程。</li>
<li>反序列化失败的几种情况：未指定serialVersionUID；成员变量的数量、类型结构等变化时；非常规性改版：类名变化。</li>
</ul>

<h3 id="toc_6">2.3.2 Parcelable接口</h3>

<p>Parcelable主页方法：</p>

<ul>
<li>writeToParcel：序列化</li>
<li>CREATOR：read方法，反序列化</li>
<li>describeContents：内容描述</li>
</ul>

<p>Serializable和Parcelable：</p>

<ul>
<li>两者都可以实现序列化并可用于intent间的数据传递</li>
<li>Serializable使用简单，但是开销很大，推荐使用在存储设备或者网络传输；</li>
<li>Parcelable效率很高，主要用在内存序列化上。</li>
</ul>

<h3 id="toc_7">2.3.3 Binder</h3>

<p>Binder的理解：</p>

<ul>
<li>直观来说，Binder 是Android中的一个类，它实现了IBinder接口。</li>
<li>从IPC角度来说，Binder是Android中的一种跨进程通信方式：
<ul>
<li>从Android Framework角度来说，Binder是ServiceManager连接各种Manager (ActivityManager、WindowManager， 等等)和相应ManagerService的桥梁;</li>
<li>从Android应用层来说，Binder 是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder 对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</li>
</ul></li>
</ul>

<p>Android开发中， Binder主要用在Service中，包括AIDL和Messenger。其中普通的Service的Binder不涉及进程间通讯；而Messenger的底层其实就是AIDL。</p>

<ol>
<li><p>新建一个AIDL示例，SDK会自动为我们生产AIDL所对应的Binder类。创建<code>Book.java</code>、<code>Book.aidl</code>、<code>IBookManager.aidl</code>，Build后生成<code>IBookManager.java</code>。</p></li>
</ol>

<ul>
<li><p>Book.java</p>
<pre><code class="language-text">public class Book implements Parcelable {
    public int bookId;<br/>
    public String bookName;<br/>
    //...<br/>
}
</code></pre></li>
<li><p>Book.aidl</p>
<pre><code class="language-text">package com.wz.testaidl;
import com.wz.testaidl.Book;<br/>
parcelable Book ;
</code></pre></li>
<li><p>IBookManager.aidl</p>
<pre><code class="language-text">package com.wz.testaidl;
import com.wz.testaidl.Book;<br/>
interface IBookManager{<br/>
    List&lt;Book&gt; getBookList();<br/>
    void addBook(in Book book);<br/>
}
</code></pre></li>
</ul>

<p>AIDL自动生成的java文件方法说明：</p>

<ul>
<li><strong>DESCRIPTOR</strong>：Binder的唯一标识，一般用当前Binder的类名表示。</li>
<li><strong>asInterface</strong>：将服务端的Binder对象转换成客户端所需要的AIDL接口类型的对象；
<ul>
<li>客户端和服务端位于相同进程，那么此方法返回的就是服务端Stub对象本身；</li>
<li>否则返回系统封装后的Stub.proxy对象。</li>
</ul></li>
<li><strong>asBinder</strong>：用于返回当前的Binder对象</li>
<li><strong>onTransact</strong>：运行在服务端的Binder线程池中，当客户端发起跨进程通讯时，远程请求会通过系统底层封装交由此方法处理。</li>
<li><strong>Proxy#[Method]</strong>：代理类中的接口方法。内部实现：
<ol>
<li>首先创建该方法所需要的输入型参数Parcel对象_data和输出型参数Parcel对象_reply；</li>
<li>然后把参数写入_data中（如果有参数的话）；</li>
<li>接着调用transact方法来发起RPC（远程过程调用）请求，同时当前线程挂起；</li>
<li>然后服务端的onTransace方法会被调用直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果；</li>
<li>最后返回_reply中的数据。</li>
</ol></li>
</ul>

<p>首先，当客户端发起远程请求时，由于当前线程会被挂起直至服务端进程返回数据，所以如果一个远程方法是很耗时的，那么<mark>不能在UI线程中发起此远程请求</mark>；其它，由于服务端的Binder方法运行在Binder的线程池中，所以Binder方法不管是否耗时都应该采用<mark>同步</mark>的方式去实现，因为它已经运行在一个线程中了。</p>

<p><img src="media/15513690535659/15764863288077.jpg" alt=""/></p>

<p><strong>Binder死亡通知</strong><br/>
Binder的两个重要方法<code>linkToDeath</code>和<code>unlinkToDeath</code>。</p>

<ul>
<li>通过linkToDeath可以给Binder设置一个死亡代理，当Binder死亡时，我们就会收到通知，然后就可以重新发起连接请求。</li>
<li><p>声明一个DeathRecipient对象，DeathRecipient是一个接口，其内部只有一个方法binderDied，实现这个方法后就可以在Binder死亡的时候收到通知了。</p>
<pre><code class="language-text">private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient(){
    @override<br/>
    public void binderDied(){<br/>
        if(mBookManager==null){<br/>
            return;<br/>
        }<br/>
        mBookManager.asBinder().unlinkToDeath(mDeathRecipient，0);<br/>
        mBookManager=null;<br/>
        //TODO:重新绑定远程Service<br/>
    }<br/>
}
</code></pre></li>
<li><p>在客户端绑定远程服务成功后，给binder设置死亡代理:</p>
<pre><code class="language-text">mService = IMessageBoxManager.Stub.asInterface(binder);
binder.linkToDeath(mDeathRecipient，0);
</code></pre></li>
<li><p>另外，通过Binder的<code>isBinderAlive</code>方法，也可以判断Binder是否死亡。</p></li>
<li><p><code>binderDied</code>和<code>onServiceDisconnected</code>区别：</p>
<ul>
<li>binderDied在客户端的Binder线程池中被回调</li>
<li>onServiceDisconnected在UI线程中被回调</li>
</ul></li>
</ul>

<h2 id="toc_8">2.4 Android中的IPC方式</h2>

<h3 id="toc_9">2.4.1 使用Bundle</h3>

<p>我们知道，四大组件中的三大组件( Activity、Service、 Receiver) 都是支持在Intent中传递Bundle数据的，由于Bundle实现了Parcelable 接口，所以它可以方便地在不同的进程间传输。基于这一点，当我们在<mark>一个进程中启动了另一个进程</mark>的Activity、 Service 和Receiver，我们就可以在Bundle 中附加我们需要传输给远程进程的信息并通过Intent 发送出去。当然，我们传输的数据必须能够被序列化，比如基本类型、实现了Parcellable 接口的对象、实现了Serializable 接口的对象以及一些Android支持的特殊对象，具体内容可以看Bundle这个类，就可以看到所有它支持的类型。Bundle不支持的类型我们无法通过它在进程间传递数据。</p>

<p>除了直接传递数据这种典型的使用场景，它还有一种特殊的使用场景。比如<mark>A进程</mark>正在进行一个<mark>计算</mark>，计算完成后它要启动B进程的一个组件并<mark>把计算结果传递给B进程</mark>，可是遗憾的是这个计算结果不支持放入Bundle中，因此无法通过Intent来传输，这个时候如果我们用其他IPC方式就会略显复杂。可以考虑如下方式：我们通过Intent启动进程B的一个Service组件(比如IntentService)， 让Service在后台进行计算，计算完毕后再启动B进程中真正要启动的目标组件，由于Service也运行在B进程中，所以目标组件就可以直接获取计算结果，这样一来就轻松解决了跨进程的问题。这种方式的核心思想在于<mark>将原本需要在A进程的计算任务转移到B进程的后台Service中去执行</mark>，这样就成功地避免了进程间通信问题，而且只用了很小的代价。</p>

<h3 id="toc_10">2.4.2 使用文件共享</h3>

<p>通过文件共享这种方式来共享数据对文件格式是没有具体要求的，比如可以是文本文件，也可以是XML文件，只要读/写双方约定数据格式即可。通过文件共享的方式也是有局限性的，比如并发读/写的问题，如果并发读/写，那么我们读出的内容就有可能不是最新的，如果是并发写的话那就更严重了。因此我们要尽量避免并发写这种情况的发生或者考虑使用线程同步来限制多个线程的写操作。<strong>文件共享方式适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读/写的问题。</strong></p>

<p>当然，SharedPreferences 是个特例，SharedPreferences 是Android中提供的轻量级存储方案，它通过键值对的方式来存储数据，在底层实现上它采用XML文件来存储键值对，每个应用的SharedPreferences文件都可以在当前包所在的data目录下查看到。一般来说， 它的目录位于/data/data/package name/shared_ prefs 目录下，其中package name表示的是当前应用的包名。从本质上来说，SharedPreferences 也属于文件的一种，但是由于<mark>系统对它的读/写有一定的缓存策略</mark>，即在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下，系统对它的读/写就变得不可靠，当面对高并发的读/写访问，Sharedpreferences有很大几率会丢失数据，因此，<strong>不建议在进程间通信中使用SharedPreferences</strong>。</p>

<h3 id="toc_11">2.4.3 使用Messenger</h3>

<ol>
<li><p>构建服务端Service，运行在独立进程中：</p>
<pre><code class="language-text">public class MessengerService extends Service {
    private static final String TAG = &quot;MessengerService&quot;;<br/>
    @Override<br/>
    public IBinder onBind(Intent intent) {<br/>
        return mMessenger.getBinder();<br/>
    }<br/>
    private final Messenger mMessenger = new Messenger(new MessengerHandler());<br/>
    private static class MessengerHandler extends Handler {<br/>
        @Override<br/>
        public void handleMessage(@NonNull Message msg) {<br/>
            Log.e(TAG， &quot;server receive msg: &quot; + msg.what);<br/>
            final Messenger replyTo = msg.replyTo;<br/>
            final Message replyMsg = Message.obtain();<br/>
            replyMsg.what = 999;<br/>
            try {<br/>
                replyTo.send(replyMsg);<br/>
            } catch (RemoteException e) {<br/>
                e.printStackTrace();<br/>
            }<br/>
        }<br/>
    }<br/>
}
</code></pre>
<pre><code class="language-text">// AndroidManifext.xml
&lt;service android:name=&quot;.MessengerService&quot;<br/>
    android:process=&quot;:remote&quot;/&gt;
</code></pre></li>
<li><p>客户端：</p>
<ol>
<li>通过绑定服务端返回的binder创建Messenger对象，并通过这个Messenger对象向服务端发送消息。</li>
<li>服务端给客户端回复消息：使用Message的<code>replyTo</code>参数。</li>
</ol>
<pre><code class="language-text">public class MainActivity extends AppCompatActivity {
    private static final String TAG = &quot;MainActivity&quot;;<br/>
    @Override<br/>
    protected void onCreate(Bundle savedInstanceState) {<br/>
        super.onCreate(savedInstanceState);<br/>
        setContentView(R.layout.activity_main);<br/>
        final Intent intent = new Intent(this， MessengerService.class);<br/>
        bindService(intent， serviceConnection， Context.BIND_AUTO_CREATE);<br/>
    }<br/>
    private ServiceConnection serviceConnection = new ServiceConnection() {<br/>
        @Override<br/>
        public void onServiceConnected(ComponentName componentName， IBinder iBinder) {<br/>
            Log.e(TAG， &quot;onServiceConnected: &quot;);<br/>
            Messenger mServerMessenger = new Messenger(iBinder);<br/>
            final Message msg = Message.obtain();<br/>
            msg.what = 666;<br/>
            //赋值replyTo，服务端才可以回复消息<br/>
            msg.replyTo = mClientMessenger;<br/>
            try {<br/>
                mServerMessenger.send(msg);<br/>
            } catch (RemoteException e) {<br/>
                e.printStackTrace();<br/>
            }<br/>
        }<br/>
        @Override<br/>
        public void onServiceDisconnected(ComponentName componentName) {<br/>
        }<br/>
    };<br/>
    private Messenger mClientMessenger = new Messenger(new MessengerHandler());<br/>
    private static class MessengerHandler extends Handler {<br/>
        @Override<br/>
        public void handleMessage(@NonNull Message msg) {<br/>
            Log.e(TAG， &quot;client receive msg: &quot; + msg.what);<br/>
        }<br/>
    }<br/>
    @Override<br/>
    protected void onDestroy() {<br/>
        unbindService(serviceConnection);<br/>
        super.onDestroy();<br/>
    }<br/>
}
</code></pre>
<p>流程图如下：<br/>
<img src="media/15513690535659/15765748325024.jpg" alt=""/></p></li>
</ol>

<p><strong>总结：</strong></p>

<ul>
<li>Messenger 是以串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务端，服务端仍然只能一个个处理，如果有大量的并发请求，那么用Messenger就不太合适了。</li>
<li>Messenger的作用主要是为了传递消息，很多时候我们可能需要跨进程调用服务端的方法，这种情形用Messenger就无法做到了，但是我们可以使用AIDL来实现跨进程的方法调用。</li>
</ul>

<h3 id="toc_12">2.4.4 使用AIDL</h3>

<p>使用AIDL来进行进程间通信的流程，分为服务端和客户端两个方面。</p>

<ol>
<li><p>服务端：</p>
<ol>
<li>创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明(见2.3.3)</li>
<li>创建一个Service用来监听客户端的连接请求，在Service中实现AIDL接口。</li>
</ol>
<pre><code class="language-text">public class BookMangerService extends Service {
    private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;();<br/>
    @Override<br/>
    public IBinder onBind(Intent intent) {<br/>
        return mBinder;<br/>
    }<br/>
    private IBinder mBinder = new IBookManager.Stub(){<br/>
        @Override<br/>
        public List&lt;Book&gt; getBookList() {<br/>
            return mBookList;<br/>
        }<br/>
        @Override<br/>
        public void addBook(Book book) {<br/>
            mBookList.add(book);<br/>
        }<br/>
    };<br/>
}
</code></pre>
<pre><code class="language-text">&lt;service android:name=&quot;.BookMangerService&quot;
    android:process=&quot;:remote&quot;/&gt;
</code></pre></li>
<li><p>客户端</p>
<ol>
<li>首先需要绑定服务端的Service</li>
<li>绑定成功后，将服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法了。</li>
</ol>
<pre><code class="language-text">public class MainActivity extends AppCompatActivity {
    private static final String TAG = &quot;MainActivity&quot;;<br/>
    @Override<br/>
    protected void onCreate(Bundle savedInstanceState) {<br/>
        super.onCreate(savedInstanceState);<br/>
        setContentView(R.layout.activity_main);<br/>
        final Intent intent = new Intent(this， BookMangerService.class);<br/>
        bindService(intent， serviceConnection， Context.BIND_AUTO_CREATE);<br/>
    }<br/>
    private ServiceConnection serviceConnection = new ServiceConnection() {<br/>
        @Override<br/>
        public void onServiceConnected(ComponentName componentName， IBinder iBinder) {<br/>
            final IBookManager bookManager = IBookManager.Stub.asInterface(iBinder);<br/>
            try {<br/>
                Log.e(TAG， &quot;bookList.size()： &quot; + bookManager.getBookList().size());<br/>
                bookManager.addBook(new Book());<br/>
                bookManager.addBook(new Book());<br/>
                Log.e(TAG， &quot;bookList.size()： &quot; + bookManager.getBookList().size());<br/>
            } catch (RemoteException e) {<br/>
                e.printStackTrace();<br/>
            }<br/>
        }<br/>
        @Override<br/>
        public void onServiceDisconnected(ComponentName componentName) {<br/>
        }<br/>
    };<br/>
    @Override<br/>
    protected void onDestroy() {<br/>
        unbindService(serviceConnection);<br/>
        super.onDestroy();<br/>
    }<br/>
}
</code></pre></li>
</ol>

<p><strong>RemoteCallbackList</strong></p>

<p>在解注册的过程中，服务端无法找到之前注册的那个listener，因为Binder会把客户端传递过来的对象重新转化并生成一个新的对象。</p>

<p><code>RemoteCallbackList</code>是系统专门提供的用于删除跨进程listener的接口。Remote一CallbackList是一个泛型，支持管理任意的AIDL接口。内部有一个Map结构专门用来保存所有的AIDL回调，这个Map的key是IBinder类型，value 是Callback类型，如下所示。</p>

<pre><code class="language-text">public class RemoteCallbackList&lt;E extends IInterface&gt;{
    ArrayMap&lt;IBinder， Callback&gt; mCallbacks = new ArrayMap&lt;IBinder， Callback&gt;() ;
}
</code></pre>

<p>其中Callback中封装了真正的远程listener。 当客户端注册listener 的时候，它会把这个listener的信息存入mCallbacks中，其中key和value分别通过下面的方式获得：</p>

<pre><code class="language-text">IBinder key = listener.asBinder();
Callback value = new Callback(listener，cookie);
</code></pre>

<p>当客户端解注册的时候，只要遍历服务端所有的listener，找出那个和解注册listener具有相同Binder对象的服务端listener并把它删除就可以了。当客户端进程终止后，RemoteCallbackList能够自动移除客户端所注册的listener。RemoteCallbackList内部自动实现了线程同步的功能，所以使用它来注册和解注册时，不需要做额外的线程同步工作。</p>

<p>使用RemoteCallbackList，有一点需要注意。我们无法像操作List一样去操作它，尽管它的名字中也带个List，但是它并不是一个List。遍历RemoteCallbackList，必须要按照下面的方式进行，其中<code>beginBroadcast</code>和<code>finishBroadcast</code>必须配对使用，哪怕我们仅仅是想要获取RemoteCallbackList的元素个数。</p>

<pre><code class="language-text">final int N = mListenerList.beginBroadcast();
for(int i=0;i&lt;N;i++){   
    IOnNewBookArrivedListener l = mListenerList.getBroadcastItem(i);
    if(l!=null){
        //TODO
    }
}
mListenerList.finishBroadcast();
</code></pre>

<p><strong>如何在AIDL中使用权限验证功能？</strong></p>

<ol>
<li><p>第一种方法：可以在onBind中进行验证，验证不通过就直接返回null。然后在AndroidMenifest中声明所需的权限。</p>
<pre><code class="language-text">public IBinder onBind(Intent intent){
    int check = checkCallingOrSelfPermission(&quot;xx.xx.xx&quot;);<br/>
    if(check==PackageManager.PERMISSION_DENIED){<br/>
        return null;<br/>
    }<br/>
    return mBinder;<br/>
}
</code></pre>
<pre><code class="language-text">&lt;uses-permission android:name=&quot;xx.xx.xx&quot;/&gt;
</code></pre></li>
<li><p>第二种方法：可以在服务端的onTransact中进行权限验证，如果验证失败，就直接返回false，这样服务端就不会终止执行AIDL中的方法从而达到保护服务端的效果。可以验证permission，也可以验证Uid和Pid。</p>
<pre><code class="language-text">public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException{
    int check = checkCallingOrSelfPermission(&quot;xx.xx.xx&quot;);<br/>
    if(check==PackageManager.PERMISSION_DENIED){<br/>
        return false;<br/>
    }<br/>
    String packageName = null;<br/>
    String[] packages = getPackageManager().getPackgesForUid(getCallingUid());<br/>
    if(packages!=null&amp;&amp;packages.length&gt;0){<br/>
        packageName = packages[0];<br/>
    }<br/>
    if(!packageName.startWith(&quot;xx.xx&quot;)){<br/>
        return false;<br/>
    }<br/>
    return super.onTransact(code,data,reply,flags);<br/>
}
</code></pre></li>
<li><p>还可以为Service指定<code>android:permission</code>属性等。</p></li>
</ol>

<h3 id="toc_13">2.4.5 使用ContentProvider</h3>

<h3 id="toc_14">2.4.6 使用Socket</h3>

<h2 id="toc_15">2.5 Binder连接池</h2>

<p>随着AIDL数量的增加，我们不能无限制地增加Service，Service 是四大组件之一一，本身就是一种系统资源。针对上述问题，我们需要减少Service的数量，将所有的AIDL放在同一个Service中去管理。</p>

<p>每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的 Binder 对象；对于服务端来说，只需要一个 Service就可以了，服务端提供一个queryBinder 接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。由此可见，Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service中去执行，从而避免了重复创建Service的过程。</p>

<h2 id="toc_16">2.6 选用合适的IPC方式</h2>

<p><img src="media/15513690535659/15766526817701.jpg" alt="" style="width:614px;"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/02/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15536971481970.html">
                
                  <h1>02 Material Design</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html'>进阶之光</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15760325676409.html">
                
                  <h1>03 View体系与自定义View</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">3.1　View与ViewGroup</h2>

<h2 id="toc_1">3.2　坐标系</h2>

<h3 id="toc_2">3.2.1　Android坐标系</h3>

<h3 id="toc_3">3.2.2　View坐标系</h3>

<h2 id="toc_4">3.3　View的滑动</h2>

<h3 id="toc_5">3.3.1　layout()方法</h3>

<h3 id="toc_6">3.3.2　offsetLeftAndRight()与offsetTopAndBottom()</h3>

<h3 id="toc_7">3.3.3　LayoutParams（改变布局参数）</h3>

<h3 id="toc_8">3.3.4　动画</h3>

<h3 id="toc_9">3.3.5　scrollTo与scollBy</h3>

<h3 id="toc_10">3.3.6　Scroller</h3>

<h2 id="toc_11">3.4　属性动画</h2>

<h2 id="toc_12">3.5　解析Scroller</h2>

<h2 id="toc_13">3.6　View的事件分发机制</h2>

<h3 id="toc_14">3.6.1　源码解析Activity的构成</h3>

<h3 id="toc_15">3.6.2　源码解析View的事件分发机制</h3>

<h2 id="toc_16">3.7　View的工作流程</h2>

<h3 id="toc_17">3.7.1　View的工作流程入口</h3>

<h3 id="toc_18">3.7.2　理解MeasureSpec</h3>

<h3 id="toc_19">3.7.3　View的measure流程</h3>

<h3 id="toc_20">3.7.4　View的layout流程</h3>

<h3 id="toc_21">3.7.5　View的draw流程</h3>

<h2 id="toc_22">3.8　自定义View</h2>

<h3 id="toc_23">3.8.1　继承系统控件的自定义View</h3>

<h3 id="toc_24">3.8.2　继承View的自定义View</h3>

<h3 id="toc_25">3.8.3　自定义组合控件</h3>

<h3 id="toc_26">3.8.4　自定义ViewGroup</h3>

<h2 id="toc_27">3.9　本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html'>进阶之光</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15760469998530.html">
                
                  <h1>03 View的事件体系</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">3.1 View基础知识</h2>

<h3 id="toc_1">3.1.1 什么是View</h3>

<ul>
<li>View是Android中所有控件的基类，是界面层的控件的一种抽象</li>
<li>ViewGroup，继承View，内部包含了许多控件</li>
<li>通过View和ViewGroup构成View树的结构，类似于Web中的Dom树</li>
</ul>

<h3 id="toc_2">3.1.2 View的位置参数</h3>

<p><img src="media/15760469998530/15760473367818.jpg" alt="" style="width:702px;"/></p>

<ul>
<li>坐标：X轴和Y轴，正方向为右和下</li>
<li>View的属性：
<ul>
<li>x/y：View左上角的位置</li>
<li>top/left/right/bottom：上下左右</li>
<li>translationX/translationY：平移量</li>
</ul></li>
</ul>

<h3 id="toc_3">3.1.3 MotionEvent和TouchSlop</h3>

<p><strong>1.MotionEvent</strong><br/>
手指接触屏幕后产生的事件。</p>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>ACTION_DOWN</td>
<td>按下</td>
</tr>
<tr>
<td>ACTION_MOVE</td>
<td>滑动</td>
</tr>
<tr>
<td>ACTION_UP</td>
<td>离开</td>
</tr>
<tr>
<td>ACTION_CANCEL</td>
<td>取消</td>
</tr>
<tr>
<td>ACTION_OUTSIDE</td>
<td>超出边界</td>
</tr>
<tr>
<td>ACTION_POINTER_DOWN</td>
<td>多点按下</td>
</tr>
<tr>
<td>ACTION_POINTER_UP</td>
<td>多点离开</td>
</tr>
</tbody>
</table>

<blockquote>
<p>ACTION_CANCEL：从当前控件转移到外层控件时会触发</p>
</blockquote>

<p>获得点击事件发生时的X Y坐标：</p>

<ul>
<li>getX()/getY()：相对控件的位置</li>
<li>getRawX()/getRawY()：相对整个屏幕的位置</li>
</ul>

<p><strong>2.TouchSlop</strong></p>

<p>系统能识别的滑动最小距离，和设备相关。<br/>
获取方法：</p>

<pre><code class="language-text">ViewConfiguration.get(getContext()).getScaledTouchSlop()
</code></pre>

<h3 id="toc_4">3.1.4 VelocityTracker、GestureDetector和Scroller</h3>

<p><strong>1.VelocityTracker</strong></p>

<p>速度追踪</p>

<p>使用：<br/>
首先在view的onTouchEvent方法中追踪当前单击事件的速度:</p>

<pre><code class="language-text">VelocityTracker velocityTracker = VelocityTracker.obtain();//实例化一个VelocityTracker 对象
velocityTracker.addMovement(event);//添加追踪事件
</code></pre>

<p>接着在ACTION_UP事件中获取当前的速度:</p>

<pre><code class="language-text">velocityTracker .computeCurrentVelocity(1000);//指定时间
float xVelocity = velocityTracker .getXVelocity();//水平方向
float yVelocity = velocityTracker .getYVelocity();//垂直方向
</code></pre>

<p>最后，当不需要使用它的时候，释放、回收：</p>

<pre><code class="language-text">/*清除释放*/
velocityTracker.clear();
velocityTracker.recycle()
</code></pre>

<p>速度 = (终点位置-起点位置)/时间</p>

<p><strong>2.GestureDetector</strong></p>

<p>手势检测，辅助检测用户单击、滑动、长按、双击等行为</p>

<p>使用：</p>

<p>创建一个GestureDetecor对象并实现OnGestureListener接口：</p>

<pre><code class="language-text">GestureDetector mGestureDetector = new GestureDetector(this);//实例化一个GestureDetector对象
mGestureDetector.setIsLongpressEnabled(false);// 解决长按屏幕后无法拖动的现象
</code></pre>

<p>然后，在待监听view的onTouchEvent方法中添加如下实现：</p>

<pre><code class="language-text">//目标view的onTouchEvent方法中修改返回值
boolean consume = mGestureDetector.onTouchEvent(event);
return consume;
</code></pre>

<p>建议：</p>

<blockquote>
<p>监听滑动，使用<code>onTouchEvent</code><br/>
监听双击，使用<code>GestureDetector</code>   </p>
</blockquote>

<p><strong>3.Scroller</strong></p>

<p>使用Scroller的实现滑动的步骤：</p>

<ol>
<li>初始化一个Scroller对象</li>
<li>重写View.computeScroll()方法</li>
<li>调用startScroll()开始滑动，invalidate()重绘</li>
</ol>

<pre><code class="language-text">Scroller scroller = new Scroller(mContext); //实例化一个Scroller对象

@Override
public void computeScroll() {
    super.computeScroll();
    if(mScroller.computeScrollOffset()){
        ((View) getParent()).scrollTo(mScroller.getCurrX(),mScroller.getCurrY());
         //通过不断的重绘不断的调用computeScroll方法
         invalidate();
    }  
}

public void smoothScrollTo(int destX,int destY){
      int scrollX=getScrollX();
      int delta=destX-scrollX;
      //1000秒内滑向destX
      mScroller.startScroll(scrollX,0,delta,0,2000);
      invalidate();
  }
</code></pre>

<h2 id="toc_5">3.2 View的滑动</h2>

<h3 id="toc_6">3.2.1 使用scrollTo/scrollBy</h3>

<ul>
<li>scrollTo：基于所传参数的绝对滑动</li>
<li>scrollBy：基于当前位置的相对滑动，调用的也是scrollTo方法。</li>
</ul>

<h3 id="toc_7">3.2.2 使用动画</h3>

<p><strong>1.视图动画：</strong></p>

<pre><code class="language-text">//translate.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;translate android:fromXDelta=&quot;0&quot; android:toXDelta=&quot;300&quot; android:duration=&quot;1000&quot;/&gt;
&lt;/set&gt;

//Java代码
mCustomView.setAnimation(AnimationUtils.loadAnimation(this, R.anim.translate));
</code></pre>

<p><strong>2.属性动画：</strong></p>

<pre><code class="language-text">ObjectAnimator.ofFloat(mCustomView,&quot;translationX&quot;,0,300).setDuration(1000).start();
</code></pre>

<h3 id="toc_8">3.2.3 改变布局参数</h3>

<p>通过改变View的布局参数，实现View的滑动。</p>

<pre><code class="language-text">LinearLayout.LayoutParams layoutParams= (LinearLayout.LayoutParams) getLayoutParams();
layoutParams.leftMargin = getLeft() + offsetX;
layoutParams.topMargin = getTop() + offsetY;
setLayoutParams(layoutParams);
</code></pre>

<h3 id="toc_9">3.2.4 各种滑动方式的对比</h3>

<p>针对上面的分析做一下总结,如下所示:</p>

<ul>
<li>scrollTo/scrollBy:操作简单,适合对 View 内容的滑动;</li>
<li>动画:操作简单,主要适用于没有交互的View 和实现复杂的动画效果;</li>
<li>改变布局参数:操作稍微复杂,适用于有交互的View。</li>
</ul>

<h2 id="toc_10">3.3 弹性滑动</h2>

<p>弹性滑动思想:将一次大的滑动分成若干次小的滑动<br/>
并在一个时间段內完成,弹性滑动的具体实现方式有很多,比如通过 Scroller、Handler#postDelayed以及Thread#sleep等。</p>

<h3 id="toc_11">3.3.1 使用Scroller</h3>

<pre><code class="language-text">Scroller scroller = new Scroller(mContext); //实例化一个Scroller对象

@Override
public void computeScroll() {
    super.computeScroll();
    if(mScroller.computeScrollOffset()){
        ((View) getParent()).scrollTo(mScroller.getCurrX(),mScroller.getCurrY());
         //通过不断的重绘不断的调用computeScroll方法
         invalidate();
    }  
}

public void smoothScrollTo(int destX,int destY){
      int scrollX=getScrollX();
      int delta=destX-scrollX;
      //1000秒内滑向destX
      mScroller.startScroll(scrollX,0,delta,0,2000);
      invalidate();
  }
</code></pre>

<p>分析：<br/>
Scroller.invalidate方法导致View重绘，View.draw方法被执行，然后在重写的View.computeScroll方法中，会判断computeScrollOffset，true则调用scrollTo/scrollBy滚动、invalidate/postInvalidate再次重绘，如此反复，直到computeScrollOffset为false。</p>

<p><img src="media/15760469998530/15760488044726.jpg" alt="" style="width:697px;"/></p>

<h3 id="toc_12">3.3.2 通过动画</h3>

<p>动画本身就是一种渐近的过程,因此通过它来实现的滑动天然就具有弹性效果,比如以下代码可以让一个 View 的内容在 100ms 内向左移动 100 像素。</p>

<pre><code class="language-text">ObjectAnimator.ofFloat (targetView, “translationX”, 0, 100).setDuration
(100).start () ;
</code></pre>

<p>我们还可以利用动画的特性来实现一些动画不能实现的效果，例如：</p>

<pre><code class="language-text">final int startX = 0;
final int deltaX = 100;

ValueAnimator animator = ValueAnimator.ofInt (0, 1).setDuration (1000);
animator.addUpdateListener (new AnimatorUpdateListener () {
    @Override
    public void onAnimationUpdate (ValueAnimator animator) {
        float fraction =  animator.getAnimatedFraction ();
        mButton1.scrollTo (startX + (int) (deltaX * fraction), 0);
    }
});
animator.start ();
</code></pre>

<p>利用onAnimationUpdate,我们就可以在动画的每一帧到来时获取动画完成的比例,然后再根据这个比例计算出当前View 所要滑动的距离。</p>

<h3 id="toc_13">3.3.3 使用延时策略</h3>

<h2 id="toc_14">3.4 View的事件分发机制</h2>

<h3 id="toc_15">3.4.1 点击事件的传递规则</h3>

<p>所谓点击事件的事件分发,其实就是对 MotionEvent事件的分发过程,即当一个MotionEvent 产生了以后,系统需要把这个事件传递给一个具体的View,而这个传递的过程就是分发过程。</p>

<p>事件分发的三个方法：</p>

<ul>
<li><strong>dispatchTouchEvent</strong> 
<ul>
<li>用来<mark>进行事件的分发</mark>。如果事件能够传递给当前 View,那么此方法一定会被调用,返回结果受当前View 的 onTouchEvent 和下级 View的dispatchTouchEvent 方法的影响,表示<mark>是否消耗当前事件</mark>。</li>
</ul></li>
<li><strong>onInterceptTouchEvent</strong> 
<ul>
<li>在 dispatchTouchEvent 方法中调用,用来<mark>判断是否拦截某个事件</mark>,如果当前 View 拦截了某个事件,那么在同一个事件序列当中,此方法不会被再次调用,返回结果表示是否拦截当前事件。</li>
</ul></li>
<li><strong>onTouchEvent</strong>
<ul>
<li>在 dispatchTouchEvent 方法中调用,用来<mark>处理点击事件</mark>,返回结果表示是否消耗当前事件,如果不消耗,则在同一个事件序列中,当前 View 无法再次接收到事件。</li>
</ul></li>
</ul>

<pre><code class="language-text">//伪代码
public boolean dispatchTouchEvent(MotionEvent ev) {
    boolean result = false;
    if(onInterceptTouchEvent(ev)) { //是否拦截
        result = onTouchEvent(ev);  //拦截，处理事件
    } else {    //不拦截，分发事件
        result = child.dispatchTouchEvent(ev);
    }
    return result;
}
</code></pre>

<blockquote>
<p><em>点击事件和监听优先级</em>：<br/>
onTouchListener &gt; onTouchEvent &gt; onClickListener</p>
</blockquote>

<p>当一个点击事件产生后,它的传递过程遵循如下顺序: Activity-&gt; Window-&gt; View,即事件总是先传递给 Activity, Activity 再传递给 Window,最后后Window 再传递给顶级 View。顶级 View 接收到事件后,就会按照事件分发机制去分发事件。<br/>
考虑一种情况,如果一个View 的 onTouchEvent 返回false,那么它的父容器的 onTouchEvent 将会被调用,依此类推。如果所有的元素都不处理这个事件,那么这个事件将会最终传递给 Activity 处理,即Activity的onTouchEvent 方法会被调用。</p>

<h3 id="toc_16">3.4.2 事件分发的源码解析</h3>

<p><strong>1.Activity对点击事件的分发过程</strong></p>

<ol>
<li><p>Activity#dispatchTouchEvent</p>
<pre><code class="language-text">public boolean dispatchTouchEvent (MotionEvent ev) {
    if (ev.getAction () == MotionEvent.ACTION DOWN) {<br/>
        onUserInteraction ();<br/>
    }<br/>
    if (getWindow ().superDispatchTouchEvent (ev)) {<br/>
        return true;<br/>
    }<br/>
    return onTouchEvent (ev) ;<br/>
}
</code></pre></li>
<li><p>Window#superDispatchTouchEvent</p>
<p>Window 类可以控制顶级 View 的外观和行为策略,它的唯一实现位于 android.policy.PhoneWindow 。</p>
<pre><code class="language-text">public abstract boolean superDispatchTouchEvent(MotionEvent event);
</code></pre></li>
<li><p>PhoneWindow#superDispatchTouchEvent</p>
<pre><code class="language-text">@Override
public boolean superDispatchTouchEvent(MotionEvent event) {<br/>
    return mDecor.superDispatchTouchEvent(event);<br/>
}
</code></pre></li>
<li><p>DecorView#getDecorView</p>
<p>顶层View，是一个FrameLayout。</p></li>
</ol>

<p><strong>2.顶级View对点击事件的分发过程</strong></p>

<ul>
<li>如果顶级 ViewGroup 拦截事件即onInterceptTouchEvent 返回 true,则事件由 ViewGroup 处理,这时如果 ViewGroup 的mOnTouchListener 被设置,则 onTouch 会被调用,否则 onTouchEvent会被调用。也就是说,如果都提供的话,onTouch 会屏蔽掉 onTouchEvent。在onTouchEvent中,如果设置了mOnClickListener,则 onClick 会被调用。</li>
<li>如果顶级ViewGroup 不拦截事件,则事件会传递给它所在的点击事件链上的子 View,这时子 View 的 dispatchTouchEvent 会被调用。到此为止,事件已经从顶级 View 传递给了下一层 View,接下来的传递过程和顶级 View 是一致的,如此循环,完成整个事件的分发。</li>
</ul>

<p><strong>ViewGroup#dispatchTouchEvent</strong></p>

<ol>
<li><p>判断当前View是否拦截点击事件</p>
<pre><code class="language-text">// Check for interception.
final boolean intercepted;<br/>
if (actionMasked == MotionEvent.ACTION_DOWN<br/>
        || mFirstTouchTarget != null) {<br/>
    final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;<br/>
    if (!disallowIntercept) {<br/>
        intercepted = onInterceptTouchEvent(ev);<br/>
        ev.setAction(action); // restore action in case it was changed<br/>
    } else {<br/>
        intercepted = false;<br/>
    }<br/>
} else {<br/>
    // There are no touch targets and this action is not an initial down<br/>
    // so this view group continues to intercept touches.<br/>
    intercepted = true;<br/>
}
</code></pre>
<ul>
<li>判断拦截：<br/>
<ol>
<li>MotionEvent.ACTION_DOWN </li>
<li>mFirstTouchTarget != null</li>
<li>判断mGroupFlags，可通过子View的requestDisallowInterceptTouchEvent()设置</li>
</ol></li>
</ul></li>
<li><p>ViewGroup遍历子所有View</p>
<ol>
<li>判断子元素是否能接受这个点击事件。主要是通过两点：
<ol>
<li>子元素是否在播放动画</li>
<li>点击事件的着落点是否在子元素的区域内。</li>
</ol></li>
<li><code>dispatchTransformedTouchEvent()</code>
<ol>
<li>实际就是调用子元素的dispatchTouchEvent()方法。</li>
<li>返回值为true，那么mFirstTouchTarget将会赋值并且跳出循环</li>
<li>返回值为false，将事件分发给下一个子View。</li>
</ol></li>
</ol>
<pre><code class="language-text">final View[] children = mChildren;
for (int i = childrenCount - 1; i &gt;= 0; i--){<br/>
    ...<br/>
    //2. 通过dispatchTransformedTouchEvent()将事件传递给子View<br/>
    if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {<br/>
        // Child wants to receive touch within its bounds.<br/>
        mLastTouchDownTime = ev.getDownTime();<br/>
        if (preorderedList != null) {<br/>
            // childIndex points into presorted list, find original index<br/>
            for (int j = 0; j &lt; childrenCount; j++) {<br/>
                if (children[childIndex] == mChildren[j]) {<br/>
                    mLastTouchDownIndex = j;<br/>
                    break;<br/>
                }<br/>
            }<br/>
        } else {<br/>
            mLastTouchDownIndex = childIndex;<br/>
        }<br/>
        mLastTouchDownX = ev.getX();<br/>
        mLastTouchDownY = ev.getY();<br/>
        //3.对mFirstTouchTarget赋值<br/>
        newTouchTarget = addTouchTarget(child, idBitsToAssign);<br/>
        alreadyDispatchedToNewTouchTarget = true;<br/>
        break;<br/>
    }<br/>
    ev.setTargetAccessibilityFocus(false);<br/>
}
</code></pre>
<pre><code class="language-text">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
        View child, int desiredPointerIdBits) {<br/>
    final boolean handled;<br/>
    if (child == null) {<br/>
        handled = super.dispatchTouchEvent(transformedEvent);<br/>
    } else {<br/>
        handled = child.dispatchTouchEvent(transformedEvent);<br/>
    }<br/>
    return handled;<br/>
}
</code></pre>
<pre><code class="language-text">private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
    final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);<br/>
    target.next = mFirstTouchTarget;<br/>
    //mFirstTouchTarget为链表结构<br/>
    mFirstTouchTarget = target;<br/>
    return target;<br/>
}
</code></pre>
<p>mFirstTouchTarget是否赋值，将会影响ViewGroup的拦截策略。如果mFirstTouchTarget为null，那么ViewGroup将会拦截下来同一序列的所有事件，自己处理并不再向子元素传递。那mFirstTouchTarget在什么情况下才为null呢？一般在两种情况下，</p>
<ul>
<li>要么是ViewGroup遍历了所有的子元素事件没有被处理；</li>
<li>要么是子元素处理了ACTION_DOWN但是dispatchTouchEvent返回为false。</li>
</ul>
<pre><code class="language-text">if (mFirstTouchTarget == null) {
    // 此处的第三个参数为null，代表事件交给ViewGroup自己处理<br/>
    handled = dispatchTransformedTouchEvent(ev, canceled, null,<br/>
            TouchTarget.ALL_POINTER_IDS);<br/>
}
</code></pre></li>
</ol>

<p><strong>3.View对点击事件的处理过程</strong></p>

<ol>
<li>是否设置了onTouchListener()</li>
<li>是：调用onTouch()</li>
<li>否：调用onTouchEvent()</li>
</ol>

<p>onTouch()的优先级要高于onTouchEvent()。</p>

<pre><code class="language-text">public boolean dispatchTouchEvent(MotionEvent event) {
    //...
    //首先判断是否设置了onTouchListener()
    ListenerInfo li = mListenerInfo;
    if (li != null &amp;&amp; li.mOnTouchListener != null
            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
            &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
        result = true;
    }
    //调用onTouchEvent(event)
    if (!result &amp;&amp; onTouchEvent(event)) {
        result = true;
    }
    //...
    return result;
}
</code></pre>

<p>View的点击事件是在ACTION_UP事件中调用了performClick()方法处理,长按事件是在ACTION_DOWN事件中调用了checkForLongClick()方法处理。</p>

<pre><code class="language-text">public boolean onTouchEvent(MotionEvent event) {
    ...
    //如果View设有代理，将会执行TouchDelegate.onTouchEvent(event)
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    //只要View的CLICKABLE和LONG_CLICKABLE有一个返回true，他就会被消耗这个事件。
    if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                  ...
                        if (!focusTaken) {
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            //点击事件
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    ...
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_DOWN:
                ...
                //长按事件
                if (!clickable) {
                    checkForLongClick(0, x, y);
                    break;
                }
                ...
                break;
                ...
        }
        return true;
    }
    return false;
}
</code></pre>

<h2 id="toc_17">3.5 View的滑动冲突</h2>

<h3 id="toc_18">3.5.1 常见的滑动冲突场景</h3>

<ol>
<li>外部滑动方向和内部滑动方向不一致；</li>
<li>外部滑动方向和内部滑动方向一致；</li>
<li>上面两种情况的嵌套。</li>
</ol>

<h3 id="toc_19">3.5.2 滑动冲突的处理规则</h3>

<ol>
<li>场景1，当用户左右滑动时，让外部的View拦截点击事件；当用户上下滑动时，让内部View拦截点击事件。</li>
<li>场景2，根据业务不同进行判断，让外部或内部View拦截处理。</li>
<li>场景3，相对复杂，根据业务进行处理。</li>
</ol>

<blockquote>
<p>如何判断是左右滑动还是上下滑动？<br/>
根据水平或垂直方向的<strong>距离差</strong>、<strong>夹角</strong>或<strong>速度差</strong>进行判断。</p>
</blockquote>

<h3 id="toc_20">3.5.3 滑动冲突的解决方式</h3>

<p><strong>1）外部拦截法</strong></p>

<p>父容器如果需要此事件就拦截，重写父容器的onInterceptTouchEvent方法。</p>

<pre><code class="language-text">public boolean onInterceptTouchEvent(MotionEvent event) {
    boolean intercepted = false;
    int x = (int) event.getX();
    int y = (int) event.getY();
    switch (event.getAction()) {
    case MotionEvent.ACTION_DOWN: {
        intercepted = false;    //!!!
        break;
    }
    case MotionEvent.ACTION_MOVE: {
        if (满足父容器的拦截要求) {
            intercepted = true;
        } else {
            intercepted = false;
        }
        break;
    }
    case MotionEvent.ACTION_UP: {
        intercepted = false;
        break;
    }
    default:
        break;
    }
    mLastXIntercept = x;
    mLastYIntercept = y;
    return intercepted;
}
</code></pre>

<p><strong>2）内部拦截法</strong></p>

<p>父容器不拦截任何事件，所有事件传递给子元素，如果子元素需要就直接消耗，否则就交给父容器处理。父容器需要的话，调用parent.requestDisallowInterceptTouchEvent方法。</p>

<pre><code class="language-text">public boolean dispatchTouchEvent(MotionEvent event) {
    int x = (int) event.getX();
    int y = (int) event.getY();

    switch (event.getAction()) {
    case MotionEvent.ACTION_DOWN: {
        parent.requestDisallowInterceptTouchEvent(true);
        break;
    }
    case MotionEvent.ACTION_MOVE: {
        int deltaX = x - mLastX;
        int deltaY = y - mLastY;
        if (父容器需要此类点击事件) {
            parent.requestDisallowInterceptTouchEvent(false);
        }
        break;
    }
    case MotionEvent.ACTION_UP: {
        break;
    }
    default:
        break;
    }

    mLastX = x;
    mLastY = y;
    return super.dispatchTouchEvent(event);
}
</code></pre>

<p>重写父容器的onInterceptTouchEvent方法。</p>

<pre><code class="language-text">public boolean onInterceptTouchEvent(MotionEvent event) {
    int action = event.getAction();
    if (action == MotionEvent.ACTION_DOWN) {
        return false;
    } else {
        return true;
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009111256.html">
                
                  <h1>03 应用程序进程启动过程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">3.1 应用程序进程简介</h2>

<p>要想启动一个应用程序，首先要保证这个应用程序所需要的应用程序进程已经启动。AMS在启动应用程序时会检查这个应用程序需要的应用程序进程是否存在，不存在就会请求Zygote进程启动需要的应用程序进程。在2.2节中，我们知道在Zygote的Java框架层中会创建一个Server端的Socket,这个Socket用来等待AMS请求Zygote来创建新的应用程序进程。Zygote进程通过fock自身创建应用程序进程，这样应用程序进程就会获得Zygote进程在启动时创建的虚拟机实例。当然，在应用程序进程创建过程中除了获取虚拟机实例外，还创建了Binder 线程池和消息循环，这样运行在应用进程中的应用程序就可以方便地使用Binder进行进程间通信以及处理消息了。</p>

<h2 id="toc_1">3.2 应用程序<mark>进程</mark>启动过程介绍</h2>

<h3 id="toc_2">3.2.1 AMS发送启动应用程序进程请求</h3>

<p><img src="media/15537009111256/15768257270184.jpg" alt="" style="width:750px;"/></p>

<h3 id="toc_3">3.2.2 Zygote接收请求并创建应用程序进程</h3>

<p><img src="media/15537009111256/15768260299978.jpg" alt="" style="width:791px;"/></p>

<h2 id="toc_4">3.3 Binder线程池启动过程</h2>

<h2 id="toc_5">3.4 消息循环创建过程</h2>

<h2 id="toc_6">3.5 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15760471697724.html">
                
                  <h1>04 View的工作原理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">4.1 初识ViewRoot和DecorView</h2>

<ol>
<li>ActivityThread#handleResumeActivity
<ol>
<li>当 Activity 对象被创建完毕后，会将 DecorView 通过 WindowManager 添加到 Window 中。</li>
</ol></li>
<li>WindowManagerGlobal#addView
<ol>
<li>创建 ViewRootImpl 对象，并将 ViewRootImpl 对象和 DecorView 建立关联。</li>
</ol></li>
<li>ViewRootImpl#setView
<ol>
<li>ViewRootImpl#requestLayout</li>
<li>ViewRootImpl#scheduleTraversals</li>
<li>ViewRootImpl.TraversalRunnable#performTraversals
<ol>
<li>ViewRootImpl#performMeasure</li>
<li>ViewRootImpl#performLayout</li>
<li>ViewRootImpl#performDraw</li>
</ol></li>
</ol></li>
</ol>

<p><img src="media/15760471697724/15761424793755.jpg" alt=""/></p>

<p><img src="media/15760471697724/15761426152782.jpg" alt="" style="width:445px;"/></p>

<h2 id="toc_1">4.2 理解MeasureSpec</h2>

<h3 id="toc_2">4.2.1 MeasureSpec</h3>

<ul>
<li>测量规格，决定View的大小。</li>
<li>是一个32位int值，高2位代表SpecMode(测量模式)，低30位代表SpecSize(规格大小)。</li>
<li>三种模式：
<ul>
<li><strong>UNSPECIFIED</strong> 父容器不对View有任何限制，要多大就给多大。常用于系统内部。</li>
<li><strong>EXACTLY</strong> 父容器已经检测出View所需要的精确大小即SpecSize。对应LyaoutParams中的match_parent或具体数值。</li>
<li><strong>AT_MOST</strong> 父容器为子视图指定一个最大尺寸SpecSize。对应LayoutParams中的wrap_content。</li>
</ul></li>
<li>View的MeasureSpec由LayoutParams和父容器的LayoutParams共同决定。</li>
</ul>

<h3 id="toc_3">4.2.2 MeasureSpec和LayoutParams的对应关系</h3>

<h2 id="toc_4">4.3 View的工作流程</h2>

<ol>
<li>先将DecorView加载到Window中</li>
<li>然后开始View的绘制，调用ViewRootImpl的PerformTraversals方法</li>
<li>performTraversals()中依次调用performMeasure()、performLayout()和performDraw()三个方法，分别完成顶级 View的绘制</li>
<li>performMeasure() &gt; measure() &gt; onMeasure()，其中会实现子View的measure过程，layout和draw同理。</li>
</ol>

<h3 id="toc_5">4.3.1 measure过程</h3>

<p>测量View的宽高</p>

<pre><code class="language-text">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
                         getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}
</code></pre>

<ul>
<li>View的Measure
<ul>
<li>measure() &gt; onMeasure() &gt; setMeasuredDimension() &gt; getDefaultSize()</li>
</ul></li>
<li>ViewGroup的Measure
<ul>
<li>measureChildren() &gt; measureChild() &gt; getChildMeasureSpec() &gt; child.measure()</li>
</ul></li>
</ul>

<blockquote>
<p>直接继承View的自定义View，需要重写onMeasure()并设置wrap_content时的自身大小，否则效果相当于macth_parent。</p>
</blockquote>

<p><strong>如何保证某个View已经测量完毕？</strong></p>

<ol>
<li>Activity/View#onWindowFocusChanged</li>
<li>view.post(runnable)</li>
<li>ViewTreeObserver</li>
<li>view.measure(int widthMeasureSpec , int heightMeasureSpec)</li>
</ol>

<h3 id="toc_6">4.3.2 layout过程</h3>

<p>确定元素的位置</p>

<ol>
<li>View的layout()，通过setFrame()来设定自己的四个顶点，确定自己的位置</li>
<li>onLayout()确定子元素的位置，空方法，不同的ViewGroup实现不同。</li>
</ol>

<h3 id="toc_7">4.3.3 draw过程</h3>

<p>将View绘制到屏幕上</p>

<ol>
<li>绘制背景（drawBackground）</li>
<li>绘制自己（onDraw）</li>
<li>绘制children（dispatchDraw）</li>
<li>绘制装饰（onDrawScrollBars）</li>
</ol>

<h2 id="toc_8">4.4 自定义View</h2>

<h3 id="toc_9">4.4.1 自定义View的分类</h3>

<ol>
<li>继承View
<ul>
<li>重写onDraw</li>
<li>支持wrap_content、处理padding</li>
</ul></li>
<li>继承ViewGroup
<ul>
<li>处理自身和子元素的测量和布局</li>
</ul></li>
<li>继承特定的View(如TextView)</li>
<li>继承ViewGroup(如LinearLayout)</li>
</ol>

<h3 id="toc_10">4.4.2 自定义View须知</h3>

<ol>
<li>尽量不要在View中使用Handler，使用post</li>
<li>及时停止线程和动画</li>
<li>滑动嵌套时，处理滑动冲突</li>
<li>自定义属性
<ol>
<li>values下创建自定义属性的xml</li>
<li>View的构造方法中解析自定义属性并处理</li>
<li>在布局中使用自定义属性</li>
</ol></li>
</ol>

<h3 id="toc_11">4.4.3 自定义View示例</h3>

<h3 id="toc_12">4.4.4 自定义View的思想</h3>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009244450.html">
                
                  <h1>04 四大组件的工作过程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">4.1 根Activity的启动过程</h2>

<ol>
<li>Launcher请求AMS过程</li>
<li>AMS到ApplicationThread的调用过程</li>
<li>ActivityThread启动Activity的过程</li>
</ol>

<h3 id="toc_1">4.1.1 Launcher请求AMS过程</h3>

<p><img src="media/15537009244450/15768281426977.jpg" alt="" style="width:889px;"/></p>

<h3 id="toc_2">4.1.2 AMS到ApplicationThread的调用过程</h3>

<p><img src="media/15537009244450/15768281976932.jpg" alt="" style="width:849px;"/></p>

<h3 id="toc_3">4.1.3 ActivityThread启动Activity的过程</h3>

<p><img src="media/15537009244450/15768288851079.jpg" alt="" style="width:920px;"/></p>

<h3 id="toc_4">4.1.4 根Activity启动过程中涉及的进程</h3>

<p><img src="media/15537009244450/15768289325581.jpg" alt="" style="width:598px;"/></p>

<p><img src="media/15537009244450/15768289840295.jpg" alt="" style="width:787px;"/></p>

<h2 id="toc_5">4.2 Service的启动过程</h2>

<ol>
<li>ContextImpl到AMS的调用过程</li>
<li>ActivityThread启动Service</li>
</ol>

<h3 id="toc_6">4.2.1 ContextImpl到AMS的调用过程</h3>

<p><img src="media/15537009244450/15768290386139.jpg" alt="" style="width:801px;"/></p>

<h3 id="toc_7">4.2.2 ActivityThread启动Service</h3>

<p><img src="media/15537009244450/15768291077812.jpg" alt="" style="width:933px;"/></p>

<h2 id="toc_8">4.3 Service的绑定过程</h2>

<ol>
<li>ContextImpl到AMS的调用过程</li>
<li>Service的绑定过程</li>
</ol>

<h3 id="toc_9">4.3.1 ContextImpl到AMS的调用过程</h3>

<p><img src="media/15537009244450/15768291875167.jpg" alt="" style="width:783px;"/></p>

<h3 id="toc_10">4.3.2 Service的绑定过程</h3>

<p><img src="media/15537009244450/15768292334460.jpg" alt="" style="width:810px;"/></p>

<p><img src="media/15537009244450/15768292543038.jpg" alt="" style="width:938px;"/></p>

<h2 id="toc_11">4.4 广播的注册、发送和接收过程</h2>

<h3 id="toc_12">4.4.1 广播的注册过程</h3>

<p><img src="media/15537009244450/15768292786702.jpg" alt="" style="width:806px;"/></p>

<h3 id="toc_13">4.4.2 广播的发送和接收过程</h3>

<ol>
<li>ContextImpl到AMS的调用过程</li>
<li>AMS到BroadcastReceiver的调用过程。</li>
</ol>

<p><img src="media/15537009244450/15768293074798.jpg" alt="" style="width:831px;"/></p>

<p><img src="media/15537009244450/15768294354518.jpg" alt="" style="width:967px;"/></p>

<h2 id="toc_14">4.5 Content Provider的启动过程</h2>

<ol>
<li>query方法到AMS的调用过程</li>
<li>AMS启动Content Provider的过程</li>
</ol>

<h3 id="toc_15">4.5.1 query方法到AMS的调用过程</h3>

<p><img src="media/15537009244450/15768294724962.jpg" alt="" style="width:817px;"/></p>

<h3 id="toc_16">4.5.2 AMS启动Content Provider的过程</h3>

<p><img src="media/15537009244450/15768295158004.jpg" alt="" style="width:911px;"/></p>

<h2 id="toc_17">4.6 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15536970568598.html">
                
                  <h1>04 多线程编程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">4.1　线程基础</h2>

<h3 id="toc_1">4.1.1　进程与线程</h3>

<p><strong>1.什么是进程</strong><br/>
进程是操作系统结构的基础，是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的基本单位。进程可以被看作程序的实体，同样，它也是线程的容器。进程就是程序的实体，是受操作系统管理的基本运行单元。<br/>
<strong>2.什么是线程</strong><br/>
线程是操作系统调度的最小单元，也叫作轻量级进程。在一个进程中可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。<br/>
<strong>3.为何要使用多线程</strong><br/>
在操作系统级别上来看主要有以下几个方面：</p>

<ul>
<li>使用多线程可以减少程序的响应时间，使程序具备了更好的交互性。</li>
<li>与进程相比，线程创建和切换开销更小，同时多线程在数据共享方面效率非常高。</li>
<li>避免多CPU或者多核计算机的资源浪费，提高CPU的利用率。</li>
<li>使用多线程能简化程序的结构，使程序便于理解和维护。</li>
</ul>

<h3 id="toc_2">4.1.2　线程的状态</h3>

<p>Java线程在运行的声明周期中可能会处于6种不同的状态，这6种线程状态分别为如下所示。</p>

<ul>
<li> <strong>New</strong>：新创建状态。线程被创建，还没有调用 start 方法，在线程运行之前还有一些基础工作要做。</li>
<li> <strong>Runnable</strong>：可运行状态。一旦调用start方法，线程就处于Runnable状态。一个可运行的线程可能正在 运行也可能没有运行，这取决于操作系统给线程提供运行的时间。</li>
<li> <strong>Blocked</strong>：阻塞状态。表示线程被锁阻塞，它暂时不活动。</li>
<li> <strong>Waiting</strong>：等待状态。线程暂时不活动，并且不运行任何代码，这消耗最少的资源，直到线程调度器重新激活它。</li>
<li> <strong>Timed waiting</strong>：超时等待状态。和等待状态不同的是，它是可以在指定的时间自行返回的。</li>
<li> <strong>Terminated</strong>：终止状态。表示当前线程已经执行完毕。导致线程终止有两种情况：第一种就是run方法执行完毕正常退出；第二种就是因为一个没有捕获的异常而终止了run方法，导致线程进入终止状态。</li>
</ul>

<p><img src="media/15536970568598/15774178989655.jpg" alt="" style="width:811px;"/></p>

<h3 id="toc_3">4.1.3　创建线程</h3>

<p>多线程的实现一般有以下3种方法，其中前两种为最常用的方法。</p>

<ol>
<li>继承<strong>Thread</strong>类，重写run()方法</li>
<li>实现<strong>Runnable</strong>接口，并实现该接口的run()方法</li>
<li>实现<strong>Callable</strong>接口，重写call()方法</li>
</ol>

<p>Callable接口实际是属于Executor框架中的功能类，Callable接口与Runnable接口的功能类似，但提供了比Runnable更强大的功能，主要表现为以下3点： </p>

<ol>
<li>Callable可以在任务接受后提供一个返回值；</li>
<li>Callable中的call()方法可以抛出异常；</li>
<li>运行Callable可以拿到一个Future对象，Future对象表示异步计算的结果，它提供了检查计算是否完成的方法。由于线程属于异步计算模型，因此无法从别的线程中得到函数的返回值，在这种情况下就可 以使用 Future 来监视目标线程调用 call()方法的情况。但调用 Future的get()方法以获取结果时，当前线程就会阻塞，直到call()方法返回结果。</li>
</ol>

<h3 id="toc_4">4.1.4　理解中断</h3>

<p>当线程的run方法执行完毕，或者在方法中出现没有捕获的异常时，线程将终止。</p>

<ul>
<li><code>interrupt()</code>方法可以用来请求中断线程。当一个线程调用 interrupt 方法时，线程的中断标识位将被置位(中断标识位为true)，线程会不时地检测这个中断标识位，以判断线程是否应该被中断。</li>
<li>Thread.currentThread().<code>isInterrupted()</code> 判断线程是否被置位</li>
<li>Thread.<code>interrupted()</code>，对中断标识位进行复位。</li>
</ul>

<p>但是如果一个线程被阻塞，就无法检测中断状态。如果一个线程处于阻塞状态，线程在检查中断标识位时如果发现中断标识位为true，则会在阻塞方法调用处抛出<mark>InterruptedException异常</mark>，并且在抛出异常前将线程的<mark>中断标识位复位</mark>，即重新设置为false。需要注意的是被中断的线程不一定会终止，中断线程是为了引起线程的注意，被中断的线程可以决定如何 去响应中断。如果是比较重要的线程则不会理会中断，而大部分情况则是线程会将中断作为一个终止的请求。</p>

<p>抛出InterruptedException异常后合理的处理方式：</p>

<ol>
<li><p>在catch子句中，调用Thread.currentThread.interrupt()来设置中断状态(因为抛出异常后中断标识位会复位)，让外界通过判断Thread.currentThread().isInterrupted()来决定是否终止线程还是继续下去。</p>
<pre><code class="language-text">void my Task() {
    try {<br/>
        sleep(50)<br/>
    } catch(InterruptedException) {<br/>
        Thread.currentThread().interrupted();<br/>
        //...<br/>
    }<br/>
}
</code></pre></li>
<li><p>更好的做法就是，不使用try来捕获这样的异常，让方法直接抛出，这样调用者可以捕获这个异常。</p>
<pre><code class="language-text">void myTask() throw InterruptedException {
    sleep(50)<br/>
}
</code></pre></li>
</ol>

<h3 id="toc_5">4.1.5　安全地终止线程</h3>

<h2 id="toc_6">4.2　同步</h2>

<p>在多线程应用中，两个或者两个以上的线程需要共享对同一个数据的存取。如果两个线程存取相同的对象，并且每一个线程都调用了修改该对象的方法， 这种情况通常被称为<strong>竞争条件</strong>。比如很多人同时买火车票，如果不使用同步保证其原子性，有可能出现两个人买同一张票的情况。解决方法如下：当一个线程要使用火车票这个资源时，我们就交给它一把锁，等它把事情做完后再把锁给另一个要用这个资源的线程。这样就不会出现上述情况了。</p>

<h3 id="toc_7">4.2.1　重入锁与条件对象</h3>

<p>synchronized 关键字自动提供了锁以及相关的条件。重入锁<strong>ReentrantLock</strong>是 Java SE 5.0引入的，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。用 ReentrantLock保护代码块的结构如下所示：</p>

<pre><code class="language-text">Lock mLock = new ReentrantLock();
mLock.lock() ;
try {
//...
} finally {
mLock.unlock() ;
}
</code></pre>

<p>这一结构确保任何时刻只有一个线程进入临界区，临界区就是在同一时刻只能有一个任务访问的代码区。一旦一个线程封锁了锁对象，其他任何线程都无法进入Lock语句。把解锁的操作放在finally中是十分必 要的。如果在临界区发生了异常，锁是必须要释放的，否则其他线程将会永远被阻塞。进入临界区时，却 发现在某一个条件满足之后，它才能执行。这时可以使用一个条件对象来管理那些已经获得了一个锁但是 却不能做有用工作的线程，条件对象又被称作<strong>条件变量</strong>。</p>

<p>一个锁对象拥有多个相关的条件对象，可以用newCondition方法获得一个条件对象<strong>Condition</strong>，我们得到条件对象后调用<code>await</code>方法，当前线程就被阻塞了并放弃了锁。一旦一个线程调用 await 方法，它就会进入该条件的等待集并处于阻塞状态，直到另一个线程调用了同 一个条件的<code>signalAll</code>方法时为止。调用signalAll方法时并不是立即激活一个等待线程，它仅仅解除了等待线程的阻塞，以便这些线程能 够在当前线程退出同步方法后，通过竞争实现对对象的访问。还有一个方法是signal，它则是随机解除某个线程的阻塞。如果该线程仍然不能运行，则再次被阻塞。如果没有其他线程再次调用signal，那么系统就死锁了。</p>

<h3 id="toc_8">4.2.2　同步方法</h3>

<p>如果一个方法用 synchronized 关键字声明，那么对象的锁将保护整个方法。</p>

<pre><code class="language-text">public synchronized void method() {
}
</code></pre>

<p>等价于：</p>

<pre><code class="language-text">Lock mLock = new ReentrantLock();
public void method() {
    mLock.lock();
    try {
    } finally {
        mLock.unlock();
    }
}
</code></pre>

<h3 id="toc_9">4.2.3　同步代码块</h3>

<p>其获得了obj的锁，obj指的是一个对象。</p>

<pre><code class="language-text">synchronized(obj) {
}
</code></pre>

<p>同步代码块是非常脆弱的， 通常不推荐使用。一般实现同步最好用java.util.concurrent包下提供的类，比如阻塞队列。</p>

<h3 id="toc_10">4.2.4　volatile</h3>

<p>有时仅仅为了读写一个或者两个实例域就使用同步的话，显得开销过大;而volatile关键字为实例域的同步访问提供了免锁的机制。如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另一个 线程并发更新的。再讲到volatile关键字之前，我们需要了解一下内存模型的相关概念以及并发编程中的3个 特性：原子性、可见性和有序性。</p>

<p><strong>1.Java内存模型</strong></p>

<p>Java中的堆内存用来存储对象实例，堆内存是被所有线程共享的运行时内存区域，因此，它存在内存可见性的问题。而局部变量、方法定义的参数则不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。Java 内存模型定义了线程和主存之间的抽象关系：线程之间的共享变量存储在主存中， 每个线程都有一个私有的本地内存，本地内存中存储了该线程共享变量的副本。需要注意的是本地内存是 Java内存模型的一个抽象概念，其并不真实存在，它涵盖了缓存、写缓冲区、寄存器等区域。Java内存模型控制线程之间的通信，它决定一个线程对主存共享变量的写入何时对另一个线程可见。</p>

<p><img src="media/15536970568598/15774323929212.jpg" alt="" style="width:525px;"/></p>

<p>线程A与线程B之间若要通信的话，必须要经历下面两个步骤：</p>

<ol>
<li>线程A把线程A本地内存中更新过的共享变量刷新到主存中去。</li>
<li>线程B到主存中去读取线程A之前已更新过的共享变量。</li>
</ol>

<p><strong>2.原子性、可见性和有序性</strong></p>

<ul>
<li>原子性
<ul>
<li>对基本数据类型变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行完毕， 要么就不执行。一个语句含有多个操作时，就不是原子性操作。</li>
<li>java.util.concurrent.atomic 包中有 很多类使用了很高效的机器级指令(而不是使用锁)来保证其他操作的原子性。例如 AtomicInteger 类提供 了方法incrementAndGet和decrementAndGet，它们分别以原子方式将一个整数自增和自减。可以安全地使用 AtomicInteger类作为共享计数器而无须同步。另外这个包还包含AtomicBoolean、AtomicLong和 AtomicReference这些原子类，这仅供开发并发工具的系统程序员使用，应用程序员不应该使用这些类。</li>
</ul></li>
<li> 可见性
<ul>
<li>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。</li>
<li>当一个共享变量被volatile修饰时，它会保证修改的值立即被更新到主存，所以对其他线程是可见的。当有其他线程需要读取该值时，其他线程会去主存中读取新值。</li>
<li>普通的共享变量不能保证可见性，因为普通共享变量被修改之后，并不会立即被写入主存，何时被写入主存也是不确定的。当其他线程去读取该值时，此时主存中可能还是原来的旧值，这样就无法保证可见性。</li>
</ul></li>
<li>有序性
<ul>
<li>Java内存模型中允许编译器和处理器对指令进行重排序，虽然重排序过程不会影响到单线程执行的正确性，但是会影响到多线程并发执行的正确性。</li>
<li>可以通过volatile来保证有序性；</li>
<li>还可以通 过synchronized和Lock来保证有序性。我们知道，synchronized和Lock保证每个时刻只有一个线程执行同步代码，这相当于是让线程顺序执行同步代码，从而保证了有序性。</li>
</ul></li>
</ul>

<p><strong>3.volatile关键字</strong></p>

<p>当一个共享变量被volatile修饰之后，其就具备了两个含义，一个是线程修改了变量的值时，变量的新值对其他线程是立即可见的，即不同线程对这个变量进行操作时具有可见性。另一个含义是禁止使用指令重排序。</p>

<p>什么是重排序呢?重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：编译期重排序和运行期重排序，分别对应编译时和运行时环境。</p>

<p><strong>volatile不保证操作原子性</strong><br/>
<strong>volatile保证有序性</strong></p>

<p><strong>4.正确使用volatile关键字</strong></p>

<p>synchronized关键字可防止多个线程同时执行一段代码，那么这就会很影响程序执行效率。而volatile关键字在某些情况下的性能要优于synchronized。但是要注意volatile关键字是无法替代synchronized关键字的， 因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下两个条件：</p>

<ol>
<li>对变量的写操作不会依赖于当前值。</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ol>

<p>使用volatile有很多种场景，这里介绍其中的两种。</p>

<ol>
<li><p>状态标志</p>
<pre><code class="language-text">volatile boolean shutdownRequested;
public void shutdown () {<br/>
    shutdownRequested = true;<br/>
}<br/>
public void doWork() {<br/>
    while (!shutdownRequested) {<br/>
    }<br/>
}
</code></pre></li>
<li><p>双重检查模式(DCL)</p></li>
</ol>

<h2 id="toc_11">4.3　阻塞队列</h2>

<h3 id="toc_12">4.3.1　阻塞队列简介</h3>

<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元 素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>

<p><strong>1.常见阻塞场景</strong></p>

<p>阻塞队列有两个常见的阻塞场景，它们分别是：</p>

<ol>
<li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞(挂起)，直到有数据放入队列。队列空，消费者堵塞。</li>
<li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞(挂起)，直到队列中有空的位置，线程被自动唤醒。队列满，生产者堵塞。</li>
</ol>

<p>支持以上两种阻塞场景的队列被称为阻塞队列。</p>

<p><strong>2.BlockingQueue的核心方法</strong></p>

<ul>
<li>放入数据
<ul>
<li> <strong>offer</strong>(anObject)：表示如果可能的话，将anObject加到BlockingQueue里。即如果BlockingQueue可以容纳，则返回true，否则返回false。(本方法不阻塞当前执行方法的线程。)</li>
<li> <strong>offer</strong>(E o，long timeout，TimeUnit unit)：可以设定等待的时间。如果在指定的时间内还不能往队列中加入BlockingQueue，则返回失败。</li>
<li> <strong>put</strong>(anObject)：将anObject加到BlockingQueue里。如果BlockQueue没有空间，则调用此方法的线程被阻断，直到BlockingQueue里面有空间再继续。</li>
</ul></li>
<li>获取数据：
<ul>
<li>  <strong>poll</strong>(time)：取走BlockingQueue 里排在首位的对象。若不能立即取出，则可以等 time参数规定的时间。取不到时返回null。</li>
<li> <strong>poll</strong>(long timeout，TimeUnit unit)：从BlockingQueue中取出一个队首的对象。如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据;否则直到时间超时还没有数据可取，返回失败。</li>
<li> <strong>take</strong>()：取走BlockingQueue里排在首位的对象。若BlockingQueue为空，则阻断进入等待状态，直到 BlockingQueue有新的数据被加入。</li>
<li> <strong>drainTo</strong>()：一次性从BlockingQueue获取所有可用的数据对象(还可以指定获取数据的个数)。通过该方法，可以提升获取数据的效率;无须多次分批加锁或释放锁。</li>
</ul></li>
</ul>

<h3 id="toc_13">4.3.2　Java中的阻塞队列</h3>

<p>在Java中提供了7个阻塞队列，它们分别如下所示。</p>

<ul>
<li>ArrayBlockingQueue：由数组结构组成的有界阻塞队列。 </li>
<li>LinkedBlockingQueue：由链表结构组成的有界阻塞队列。 </li>
<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。 </li>
<li>DelayQueue：使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列。 </li>
<li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列。</li>
</ul>

<h3 id="toc_14">4.3.3　阻塞队列的实现原理</h3>

<h3 id="toc_15">4.3.4　阻塞队列的使用场景</h3>

<h2 id="toc_16">4.4　线程池</h2>

<p>在编程中经常会使用线程来异步处理任务，但是每个线程的创建和销毁都需要一定的开销。如果每次 执行一个任务都需要开一个新线程去执行，则这些线程的创建和销毁将消耗大量的资源;并且线程都是“各 自为政”的，很难对其进行控制，更何况有一堆的线程在执行。这时就需要线程池来对线程进行管理。在 Java 1.5中提供了Executor框架用于把任务的提交和执行解耦，任务的提交交给Runnable或者Callable，而 Executor框架用来处理任务。Executor框架中最核心的成员就是 ThreadPoolExecutor，它是线程池的核心实现 类。</p>

<h3 id="toc_17">4.4.1　ThreadPoolExecutor</h3>

<p>ThreadPoolExecutor构造方法：</p>

<pre><code class="language-text">public ThreadPoolExecutor(
    int corePoolSize,   //核心线程数
    int maximumPoolSize,//最大线程数
    long keepAliveTime,//非核心线程超时时间
    TimeUnit unit,//keepAliveTime参数的时间单位
    BlockingQueue&lt;Runnable&gt; workQueue,//任务队列
    ThreadFactory threadFactory,//线程工厂，可创建新线程
    RejectedExecutionHandler handler//饱和策略
)
</code></pre>

<h3 id="toc_18">4.4.2　线程池的处理流程和原理</h3>

<p><img src="media/15536970568598/15774373999521.jpg" alt="" style="width:361px;"/></p>

<p><img src="media/15536970568598/15774374381979.jpg" alt="" style="width:652px;"/></p>

<h3 id="toc_19">4.4.3　线程池的种类</h3>

<p>通过直接或者间接地配置ThreadPoolExecutor的参数可以创建不同类型的ThreadPoolExecutor，其中有 4 种线程池比较常用，它们分别是 FixedThreadPool、CachedThreadPool、SingleThreadExecutor和 ScheduledThreadPool。下面分别介绍这4种线程池。</p>

<p><strong>1.FixedThreadPool</strong></p>

<p>FixedThreadPool 是可重用固定线程数的线程池。</p>

<p><img src="media/15536970568598/15774375675934.jpg" alt="" style="width:597px;"/></p>

<p>FixedThreadPool就是一个有固定数量核心线程的线程池，并且这些核心线程不会被回收。当线程数超过 corePoolSize 时，就将任务存储在任务队列中;当线程池有空闲线程时，则从任务队列中去取任务执行。</p>

<p><strong>2.CachedThreadPool</strong></p>

<p>CachedThreadPool是一个根据需要创建线程的线程池。CachedThreadPool 比较适于大量的需要立即处理并且耗时较少的任务。</p>

<p><img src="media/15536970568598/15774377191970.jpg" alt="" style="width:592px;"/></p>

<p><strong>3.SingleThreadExecutor</strong></p>

<p>SingleThreadExecutor是使用单个工作线程的线程池。能确保所有的任务在一个线程中按照顺序逐一执行。</p>

<p><img src="media/15536970568598/15774381710086.jpg" alt="" style="width:604px;"/></p>

<p><strong>4.ScheduledThreadPool</strong></p>

<p>ScheduledThreadPool是一个能实现定时和周期性任务的线程池。</p>

<p><img src="media/15536970568598/15774382268529.jpg" alt="" style="width:650px;"/></p>

<h2 id="toc_20">4.5　AsyncTask的原理</h2>

<h2 id="toc_21">4.6　本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html'>进阶之光</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15789728715756.html">
                
                  <h1>05 理解RemoteViews</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009340660.html">
                
                  <h1>05 理解上下文Context</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">5.1 Context的关联类</h2>

<p><img src="media/15537009340660/15768297234805.jpg" alt="" style="width:646px;"/></p>

<p>从图中我们可以看出，ContextImpl和ContextWrapper继承自Context，ContextWrapper内部包含有Context类型的mBase对象，mBase具体指向的是ContextImpl。ContextImpl提供了很多功能，但是外界需要使用并拓展ContextImpl的功能，因此设计上使用了装饰模式，ContextWrapper是装饰类，它对ContextImpl进行包装，ContextWrapper主要是起了方法传递作用，ContextWrapper中几乎所有的方法实现都是调用ContextImpl的相应方法来实现的。ContextThemeWrapper、Service和Application都继承自ContextWrapper，这样他们都可以通过mBase来使用Context的方法，同时它们也是装饰类，在ContextWrapper的基础上又添加了不同的功能。ContextThemeWrapper中包含和主题相关的方法（比如： getTheme方法），因此，需要主题的Activity继承ContextThemeWrapper，而不需要主题的Service则继承ContextWrapper。</p>

<p>Context的关联类采用了装饰模式，主要有以下的优点:</p>

<ul>
<li>使用者(比如Service) 能够更方便地使用Context。</li>
<li>如果ContextImpl发生了变化，它的装饰类ContextWrapper不需要做任何修改。</li>
<li>ContextImpl 的实现不会暴露给使用者，使用者也不必关心ContextImpl的实现。●通过组合而非继承的方式，拓展ContextImpl的功能，在运行时选择不同的装饰类，实现不同的功能。</li>
</ul>

<h3 id="toc_1">5.2 Application Context的创建过程</h3>

<p><img src="media/15537009340660/15768303177957.jpg" alt="" style="width:854px;"/></p>

<h3 id="toc_2">5.3 Application Context的获取过程</h3>

<h3 id="toc_3">5.4 Activity的Context创建过程</h3>

<p><img src="media/15537009340660/15768306549478.jpg" alt="" style="width:959px;"/></p>

<h3 id="toc_4">5.5 Service的Context创建过程</h3>

<h2 id="toc_5">5.6 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15536970792185.html">
                
                  <h1>05 网络编程与网络框架</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">5.1　网络分层</h2>

<p>网络分层就是将网络节点所要完成的数据的发送或转发、打包或拆包，以及控制信息的加载或拆出等 工作，分别由不同的硬件和软件模块来完成。这样可以将通信和网络互联这一复杂的问题变得较为简单。 网络分层有不同的模型，有的模型分7层，有的模型分5层。这里介绍分5层的，因为它更好理解。网络分层 的每一层都是为了完成一种功能而设的。为了实现这些功能，就需要遵守共同的规则，这个规则叫作“协议”。</p>

<p><img src="media/15536970792185/15780247720754.jpg" alt="" style="width:253px;"/></p>

<p>如图5-1所示，网络分层从上到下分别是应用层、传输层、网络层、数据链路层和物理层。越靠下的层越接近硬件。接下来我们从下而上来分别了解这些分层。</p>

<ol>
<li>物理层<br/>
该层负责比特流在节点间的传输，即负责物理传输。该层的协议既与链路有关，也与传输介质有关。 其通俗来讲就是把计算机连接起来的物理手段。</li>
<li>数据链路层<br/>
该层控制网络层与物理层之间的通信，其主要功能是如何在不可靠的物理线路上进行数据的可靠传递。为了保证传输，从网络层接收到的数据被分割成特定的可被物理层传输的帧。帧是用来移动数据的结 构包，它不仅包括原始数据，还包括发送方和接收方的物理地址以及纠错和控制信息。其中的地址确定了 帧将发送到何处，而纠错和控制信息则确保帧无差错到达。如果在传送数据时，接收点检测到所传数据中 有差错，就要通知发送方重发这一帧。</li>
<li>网络层 <br/>
该层决定如何将数据从发送方路由到接收方。网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中的节点 A 到另一个网络中节点 B 的最佳路径。 </li>
<li>传输层<br/>
该层为两台主机上的应用程序提供端到端的通信。相比之下，网络层的功能是建立主机到主机的通 信。传输层有两个传输协议:TCP(传输控制协议)和UDP(用户数据报协议)。其中，TCP是一个可靠的 面向连接的协议，UDP是不可靠的或者说无连接的协议。</li>
<li>应用层<br/>
应用程序收到传输层的数据后，接下来就要进行解读。解读必须事先规定好格式，而应用层就是规定 应用程序的数据格式的。它的主要协议有HTTP、FTP、Telnet、SMTP、POP3等。</li>
</ol>

<h2 id="toc_1">5.2　TCP的三次握手与四次挥手</h2>

<p>通常我们进行HTTP连接网络的时候会进行TCP的三次握手，然后传输数据，之后再释放连接。</p>

<p><img src="media/15536970792185/15780249369715.jpg" alt="" style="width:769px;"/></p>

<p>TCP三次握手的过程如下。</p>

<ul>
<li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN设置为1、Sequence Number (seq)为x;接下来客户端进入SYN_SENT状态，等待服务端的确认。</li>
<li>第二次握手：服务器收到客户端的SYN报文段，对SYN报文段进行确认，设置AcknowledgmentNumber (ACK)为x+1 (seq+1) ;同时自己还要发送SYN请求信息，将SYN设置为1、seq为y。 服务端将上述所有信息放到SYN+ACK报文段中，一并发送给客户端，此时服务端进入SYN_RCVD状态。</li>
<li>第三次握手：客户端收到服务端的SYN+ACK报文段;然后将ACK设置为y+1，向服务端发送ACK报文段，这个报文段发送完毕后，客户端和服务端都进入ESTABLISHED (TCP连 接成功)状态，完成TCP的三次握手。</li>
</ul>

<p>当客户端和服务端通过三次握手建立了TCP连接以后，当数据传送完毕，断开连接时就需要进行TCP的四次挥手。其四次挥手如下所示。</p>

<ul>
<li>第一次挥手：客户端设置seq和ACK, 向服务端发送一个FIN报文段。此时，客户端进入FIN_WAIT_1状态，表示客户端没有数据要发送给服务端了。</li>
<li>第二次挥手：服务端收到了客户端发送的FIN报文段，向客户端回了一个ACK报文段。</li>
<li>第三次挥手：服务端向客户端发送FIN报文段，请求关闭连接，同时服务端进入LAST_ACK状态。</li>
<li>第四次挥手：客户端收到服务端发送的FIN报文段，向服务端发送ACK报文段，然后客户端进入TIME_WAIT状态。服务端收到客户端的ACK报文段以后，就关闭连接。此时，客户端等待2MSL (最大报文段生存时间)后依然没有收到回复，则说明服务端已正常关闭，这样客户端也可以关闭连接了。</li>
</ul>

<p><img src="media/15536970792185/15782948994350.jpg" alt="" style="width:377px;"/></p>

<p>如果有大量的连接，每次在连接、关闭时都要经历三次握手、四次挥手，这很显然会造成性能低下。 因此，HTTP有一种叫作keepalive connections的机制，它可以在传输数据后仍然保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而无须再次握手。</p>

<p><img src="media/15536970792185/15782949498354.jpg" alt="" style="width:776px;"/></p>

<h2 id="toc_2">5.3　HTTP协议原理</h2>

<h3 id="toc_3">5.3.1　HTTP简介</h3>

<p>HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p>

<p><strong>1.HTTP的历史版本</strong></p>

<ul>
<li>HTTP 0.9：1991年发布的第一个版本，只有一个命令GET，服务器只能回应HTML格式的字符串。</li>
<li>HTTP 1.0：1996年发布的版本，内容量大大增加。除了GET命令外，还引入了POST命令和HEAD命 令。HTTP请求和回应的格式除了数据部分，每次通信都必须包括头信息，用来描述一些元数据。</li>
<li>HTTP 1.1：1997发布的版本，进一步完善了HTTP协议，直到现在还是最流行的版本。 </li>
<li>SPDY协议：2009年谷歌为了解决 HTTP 1.1效率不高的问题而自行研发的协议。</li>
<li>HTTP 2：2015年新发布的版本，SPDY 协议的主要特性也在此版本中。</li>
</ul>

<p><strong>2.HTTP协议的主要特点</strong></p>

<ul>
<li>支持C/S(客户/服务器)模式。</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、 POST，每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>无状态：HTTP协议是无状态协议，无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如 果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大;而另一方面，在服务器不需要先前信息时它的应答速度就较快。</li>
</ul>

<p>HTTP URL的格式如下所示：<code>http://host[&quot;:&quot;port][abs_path]</code></p>

<ul>
<li>http表示要通过HTTP协议来定位网络资源;</li>
<li>host表示合法的Internet主机域名或者IP地址;</li>
<li>port指定一个 端口号，为空则使用默认端口80;</li>
<li>abs_path指定请求资源的URI(Web上任意的可用资源)。</li>
</ul>

<p>HTTP有两种报 文，分别是请求报文和响应报文，下面先来查看请求报文。</p>

<h3 id="toc_4">5.3.2　HTTP请求报文</h3>

<p>HTTP 报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。一 般一个HTTP请求报文由请求行、请求报头、空行和请求数据4个部分组成。</p>

<p><img src="media/15536970792185/15782958444029.jpg" alt="" style="width:533px;"/></p>

<ol>
<li><p>请求行<br/>
请求行由请求方法、URL字段和HTTP协议的版本组成，格式如下:<br/>
<code>Method Request-URI HTTP-Version CRLF</code><br/>
其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行(除了作为结尾的CRLF外，不允许出现单独的CR或LF字符)。<br/>
HTTP请求方法有8种，分别是GET、POST、HEAD、PUT、DELETE、TRACE、CONNECT、 OPTIONS。对于移动开发最常用的就是GET和POST了。</p>
<ul>
<li>GET:请求获取Request-URI所标识的资源。</li>
<li>POST:在Request-URI所标识的资源后附加新的数据。</li>
<li>HEAD:请求获取由Request-URI所标识的资源的响应消息报头。</li>
<li>PUT:请求服务器存储一个资源，并用Request-URI作为其标识。</li>
<li>DELETE:请求服务器删除Request-URI所标识的资源。</li>
<li>TRACE:请求服务器回送收到的请求信息，主要用于测试或诊断。</li>
<li>CONNECT:HTTP 1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>
<li>OPTIONS:请求查询服务器的性能，或者查询与资源相关的选项和需求。<br/>
例如，访问我的CSDN博客地址的请求行:<br/>
GET <a href="http://blog.csdn.net/itachi85">http://blog.csdn.net/itachi85</a> HTTP/1.1</li>
</ul></li>
<li><p>请求报头<br/>
在请求行之后会有0个或者多个请求报头，每个请求报头都包含一个名字和一个值，它们之间用英文冒 号“:”分割。关于请求报头，我们会在后面做统一解释。</p></li>
<li><p>请求数据<br/>
请求数据不在GET方法中使用，而在POST方法中使用。POST方法适用于需要客户填写表单的场合，与请求数据相关的最常用的请求报头是Content-Type和Content-Length。</p></li>
</ol>

<h3 id="toc_5">5.3.3　HTTP响应报文</h3>

<p>响应报文的一般格式：<br/>
<img src="media/15536970792185/15782964755327.jpg" alt="" style="width:536px;"/></p>

<p>HTTP 的响应报文由状态行、响应报头、空行、响应正文组成。响应正文是服务器返回的资源的内容。我们先来看看状态行。 <br/>
状态行格式如下所示:<br/>
<code>HTTP-Version Status-Code Reason-Phrase CRLF</code><br/>
HTTP-Version表示服务器HTTP协议的版本;Status-Code表示服务器发回的响应状态码;Reason- Phrase表示状态码的文本描述。状态码由3位数字组成，第一个数字定义了响应的类别，且有以下5种可能取值。</p>

<ul>
<li>100~199:指示信息，收到请求，需要请求者继续执行操作。 * 200~299:请求成功，请求已被成功接收并处理。</li>
<li>300~399:重定向，要完成请求必须进行更进一步的操作。</li>
<li>400~499:客户端错误，请求有语法错误或请求无法实现。</li>
<li>500~599:服务器错误，服务器不能实现合法的请求。</li>
</ul>

<p>常见的状态码如下。</p>

<ul>
<li>200 OK:客户端请求成功。</li>
<li>400 Bad Request:客户端请求有语法错误，服务器无法理解。</li>
<li>401 Unauthorized:请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用。 </li>
<li>403 Forbidden:服务器收到请求，但是拒绝提供服务。</li>
<li>500 Internal Server Error:服务器内部错误，无法完成请求。</li>
<li>503 Server Unavailable:服务器当前不能处理客户端的请求，一段时间后可能恢复正常。 </li>
</ul>

<h3 id="toc_6">5.3.4　HTTP的消息报头</h3>

<p>消息报头分为通用报头、请求报头、响应报头、实体报头等。消息报头由键值对组成，每行一对，关键字和值用英文冒号“:”分隔。</p>

<ol>
<li>通用报头<br/>
它既可以出现在请求报头，也可以出现在响应报头中，如下所示。
<ul>
<li>Date:表示消息产生的日期和时间。</li>
<li>Connection:允许发送指定连接的选项。例如指定连接是连续的;或者指定“close”选项，通知服务器，在响应完成后，关闭连接。</li>
<li>Cache-Control:用于指定缓存指令，缓存指令是单向的(响应中出现的缓存指令在请求中未必会出现)，且是独立的(一个消息的缓存指令不会影响另一个消息处理的缓存机制)。</li>
</ul></li>
<li>请求报头<br/>
请求报头通知服务器关于客户端请求的信息。典型的请求报头如下所示。
<ul>
<li>Host:请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</li>
<li>User-Agent:发送请求的浏览器类型、操作系统等信息。</li>
<li>Accept:客户端可识别的内容类型列表，用于指定客户端接收哪些类型的信息。 * Accept-Encoding:客户端可识别的数据编码。</li>
<li>Accept-Language:表示浏览器所支持的语言类型。</li>
<li>Connection:允许客户端和服务器指定与请求/响应连接有关的选项。例如，这时为Keep-Alive则表示<br/>
保持连接。</li>
<li>Transfer-Encoding:告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。</li>
</ul></li>
<li>响应报头<br/>
用于服务器传递自身信息的响应。常见的响应报头如下所示。
<ul>
<li>Location:用于重定向接收者到一个新的位置，常用在更换域名的时候。</li>
<li>Server:包含服务器用来处理请求的系统信息，与User-Agent请求报头是相对应的。</li>
</ul></li>
<li>实体报头<br/>
实体报头用来定义被传送资源的信息，其既可用于请求也可用于响应。请求和响应消息都可以传送一 个实体。常见的实体报头如下所示。
<ul>
<li>Content-Type:发送给接收者的实体正文的媒体类型。</li>
<li>Content-Lenght:实体正文的长度。</li>
<li>Content-Language:描述资源所用的自然语言。</li>
<li>Content-Encoding:实体报头被用作媒体类型的修饰符。它的值指示了已经被应用到实体正文的附加 内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。</li>
<li>Last-Modified:实体报头用于指示资源的最后修改日期和时间。 * Expires:实体报头给出响应过期的日期和时间。</li>
</ul></li>
</ol>

<h3 id="toc_7">5.3.5　抓包应用举例</h3>

<h2 id="toc_8">5.4　HttpClient与HttpURLConnection</h2>

<h3 id="toc_9">5.4.1　HttpClient</h3>

<h3 id="toc_10">5.4.2　HttpURLConnection</h3>

<h2 id="toc_11">5.5　解析Volley</h2>

<p>适合进行数据量不大但通信频繁的网络操作。</p>

<h3 id="toc_12">5.5.1　Volley基本用法</h3>

<p>1.Volley网络请求队列<br/>
2.StringRequest的用法<br/>
3.JsonRequest的用法<br/>
4.使用lmageRequest加载图片<br/>
5.使用lmageLoader加载图片<br/>
6.使用NetworklmageView加载图片<br/>
7.NetworklmageView</p>

<h3 id="toc_13">5.5.2　源码解析Volley</h3>

<p>1.从RequestQueue入手<br/>
2.CacheDispatcher缓存调度线程<br/>
3.NetworkDispatcher网络调度线程<br/>
<img src="media/15536970792185/15782975620837.jpg" alt="" style="width:734px;"/></p>

<h2 id="toc_14">5.6　解析OkHttp</h2>

<h3 id="toc_15">5.6.1　OkHttp基本用法</h3>

<p>基本步骤就是创建OkHttpClient、Request和Call，最后调用Call的异步方法enqueue()或同步方法execute()。</p>

<h3 id="toc_16">5.6.2　源码解析OkHttp</h3>

<p><strong>1. OkHttp的请求网络流程</strong></p>

<ol>
<li>从请求处理开始分析</li>
<li>Dispatcher任务调度</li>
<li>Interceptor拦截器</li>
<li>缓存策略</li>
<li>失败重连</li>
</ol>

<p><img src="media/15536970792185/15782990572087.jpg" alt="" style="width:358px;"/></p>

<p><strong>2. OkHttp的复用连接池</strong></p>

<ol>
<li>主要变量与构造方法</li>
<li>缓存操作</li>
<li>自动回收连接</li>
<li>引用计数</li>
<li>(5)小结<br/>
可以看出连接池复用的核心就是用Deque<RealConnection>来存储连接，通过 put、get、connectionBecameIdle和evictAll几个操作来对Deque进行操作，另外通过判断连接中的计数对象 StreamAllocation来进行自动回收连接。</li>
</ol>

<h2 id="toc_17">5.7　解析Retrofit</h2>

<p>Retrofit底层是基于OkHttp实现的，使用运行时注解的方式提供功能。</p>

<h3 id="toc_18">5.7.1　Retrofit基本用法</h3>

<p>1.使用前的准备工作<br/>
2.Retrofit的注解分类<br/>
3.GET请求访问网络<br/>
4.POST请求访问网络<br/>
5.消息报头Header</p>

<h3 id="toc_19">5.7.2　源码解析Retrofit</h3>

<p>1.Retrofit的创建过程<br/>
2.Call的创建过程<br/>
3.Call的enqueue方法</p>

<h2 id="toc_20">5.8　本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html'>进阶之光</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15518627296094.html">
                
                  <h1>06 Drawable</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Drawable简介</h2>

<p>可绘制对象资源是一般概念，是指可在屏幕上绘制的图形，以及可以使用 <code>getDrawable(int)</code> 等 API 检索或者应用到具有 <code>android:drawable</code> 和 <code>android:icon</code>2 等属性的其他 XML 资源的图形。</p>

<p>详情见<a href="https://developer.android.com/guide/topics/resources/drawable-resource?hl=zh-CN">官方文档</a></p>

<h2 id="toc_1">Drawable分类</h2>

<p><strong>BitmapDrawable</strong></p>

<p>表示一张图片</p>

<pre><code class="language-text">bitmap
    |- src=&quot;@drawable/res_id&quot;
    |- antialias=&quot;[true | false]&quot;
    |- dither=&quot;[true | false]&quot;
    |- filter=&quot;[true | false]&quot;
    |- tileMode=&quot;[disabled | clamp | repeat | mirror]&quot;
    |- gravity=&quot;[top | bottom | left | right | center_vertical |
    |            fill_vertical | center_horizontal | fill_horizontal |
    |            center | fill | clip_vertical | clip_horizontal]&quot;
</code></pre>

<p><strong>NinePatchDrawable</strong></p>

<p>表示一张.9格式的图片，可自动地根据所需的宽/高进行相应的缩放并保证不失真。</p>

<pre><code class="language-text">nine-patch
    |- src=&quot;@drawable/9_png_resid&quot;
    |- dither=&quot;[true | false]&quot;
</code></pre>

<p><strong>ShapeDrawable</strong></p>

<p>可表示纯色、有渐变效果的基础几何图形（矩形,圆形,线条等）。</p>

<pre><code class="language-text">&lt;shape
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=&quot;[rectangle | oval | line | ring]&quot;
    &lt;corners
        android:radius=&quot;integer&quot;
        android:topLeftRaidus=&quot;integer&quot;
        android:topRightRaidus=&quot;integer&quot;
        android:bottomLeftRaidus=&quot;integer&quot;
        android:bottomRightRaidus=&quot;integer&quot; /&gt;
    &lt;gradient
        android:angle=&quot;integer&quot;
        android:centerX=&quot;integer&quot;
        android:centerY=&quot;integer&quot;
        android:centerColor=&quot;color&quot;
        android:endColor=&quot;color&quot;
        android:gradientRadius=&quot;integer&quot;
        android:startColor=&quot;color&quot;
        android:type=&quot;[linear | radial | sweep]&quot;
        android:useLevel=&quot;[true | false]&quot; /&gt;
    &lt;padding
        android:left=&quot;integer&quot;
        android:top=&quot;integer&quot;
        android:right=&quot;integer&quot;
        android:bottom=&quot;integer&quot; /&gt;
    &lt;size
        android:width=&quot;integer&quot;
        android:height=&quot;integer&quot; /&gt;
    &lt;solid
        android:color=&quot;color&quot; /&gt;
    &lt;stroke
        android:width=&quot;integer&quot;
        android:color=&quot;color&quot;
        android:dashWidth=&quot;integer&quot;
        android:dashGap=&quot;integer&quot; /&gt;
</code></pre>

<p><strong>LayerDrawable</strong></p>

<p>表示一种层次化的Drawable集合，通过将不同的Drawable放置在不同的层上面从而达到一种叠加后的效果。</p>

<pre><code class="language-text">layer-list
    |- item
    |    |- drawable=&quot;@drawable/drawable_id&quot;
    |    |- id=&quot;@+id/xxx_id&quot;
    |    |- top=&quot;dimension&quot;
    |    |- left=&quot;dimension&quot;
    |    |- right=&quot;dimension&quot;
    |    |- bottom=&quot;dimension&quot;
</code></pre>

<p><strong>StateListDrawable</strong></p>

<p>表示一个Drawable的集合，每个Drawable对应着View的一种状态。</p>

<pre><code class="language-text">selector
    |-constantSize=&quot;[true | false]&quot;
    |-dither=&quot;[true | false]&quot;
    |-variablePadding=&quot;[true | false]&quot;
    |- item
    |    |- drawable=&quot;@drawable/drawable_id&quot;
    |    |- state_pressed=&quot;[true | false]&quot;
    |    |- state_focused=&quot;[true | false]&quot;
    |    |- state_selected=&quot;[true | false]&quot;
    |    |- state_hovered=&quot;[true | false]&quot;
    |    |- state_checked=&quot;[true | false]&quot;
    |    |- state_checkable=&quot;[true | false]&quot;
    |    |- state_enabled=&quot;[true | false]&quot;
    |    |- state_activated=&quot;[true | false]&quot;
    |    |- state_window_focused=&quot;[true | false]&quot;
</code></pre>

<p><strong>LevelListDrawable</strong></p>

<p>表示一个Drawable集合，集合中的每个Drawable都有一个等级的概念。</p>

<pre><code class="language-text">level-list
    |- item
    |    |- drawable=&quot;@drawable/drawable_id&quot;
    |    |- maxLevel=&quot;integer&quot;
    |    |- minlevel=&quot;integer&quot;
</code></pre>

<p><strong>TransitionDrawable</strong></p>

<p>LayerDrawable的子类，实现两层 Drawable之间的淡入淡出效果。</p>

<pre><code class="language-text">transition
    |- item
    |    |- drawable=&quot;@drawable/drawable_id&quot;
    |    |- id=&quot;@+id/xxx_id&quot;
    |    |- top=&quot;dimension&quot;
    |    |- left=&quot;dimension&quot;
    |    |- right=&quot;dimension&quot;
    |    |- bottom=&quot;dimension&quot;
</code></pre>

<p><strong>InsetDrawable</strong></p>

<p>表示把一个Drawable嵌入到另外一个Drawable的内部，并在四周留一些间距。</p>

<pre><code class="language-text">inset
    |- drawable=&quot;@drawable/drawable_id&quot;
    |- visible=&quot;[true | false]&quot;
    |- insetTop=&quot;dimension&quot;
    |- insetLeft=&quot;dimension&quot;
    |- insetRight=&quot;dimension&quot;
    |- insetBottom=&quot;dimension&quot;
</code></pre>

<p><strong>ScaleDrawable</strong></p>

<p>表示将Drawable缩放到一定比例。</p>

<pre><code class="language-text">scale
    |- drawable=&quot;@drawable/drawable_id&quot;
    |- scaleGravity=&quot;[top | bottom | left | right |
        center_vertical | center_horizontal | center |
        fill_vertical | fill_horizontal | fill |
        clip_vertical | clip_horizontal]&quot;
    |- scaleWidth=&quot;percentage&quot;
    |- scaleHeight=&quot;percentage&quot;
</code></pre>

<p><strong>ClipDrawable</strong></p>

<p>表示裁剪一个Drawable。</p>

<pre><code class="language-text">scale
    |- drawable=&quot;@drawable/drawable_id&quot;
    |- gravity=&quot;[top | bottom | left | right |
        center_vertical | center_horizontal | center |
        fill_vertical | fill_horizontal | fill |
        clip_vertical | clip_horizontal]&quot;
    |- clipOrientation=&quot;[vertical | horizontal]&quot;
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/06</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009469734.html">
                
                  <h1>06 理解ActivityManagerService</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">6.1 AMS家族</h2>

<h3 id="toc_1">6.1.1 Android 7.0的AMS家族</h3>

<p><img src="media/15537009469734/15768310861282.jpg" alt="" style="width:788px;"/></p>

<p><img src="media/15537009469734/15768311034814.jpg" alt="" style="width:790px;"/></p>

<h3 id="toc_2">6.1.2 Android 8.0的AMS家族</h3>

<p><img src="media/15537009469734/15768311293526.jpg" alt="" style="width:730px;"/></p>

<h2 id="toc_3">6.2 AMS的启动过程</h2>

<h2 id="toc_4">6.3 AMS与应用程序进程</h2>

<p>AMS与应用程序进程的关系主要有以下两点:</p>

<ul>
<li>启动应用程序时AMS会检查这个应用程序需要的应用程序进程是否存在。</li>
<li>如果需要的应用程序进程不存在，AMS就会请求Zygote进程创建需要的应用程序进程。</li>
</ul>

<h2 id="toc_5">6.4 AMS重要的数据结构</h2>

<h3 id="toc_6">6.4.1 解析ActivityRecord</h3>

<p>ActivityRecord内部记录了Activity 的所有信息，因此它用来描述一个Activity， 它是在启动Activity 时被创建的，具体是在ActivityStarter 的startActivity方法中被创建的，具体可以查看4.1.2节。ActivityRecord 的部分重要成员变量如表6一1所示。</p>

<p><img src="media/15537009469734/15768331492510.jpg" alt="" style="width:883px;"/></p>

<p>从表中可以看出ActivityRecord的作用，其内部存储了Activity 的所有信息，包括AMS的引用、AndroidManifest 节点信息、Activity 状态、Activity 资源信息和Activity 进程相关信息等，需要注意的是其中含有该ActivityRecord 所在的TaskRecord， 这就将ActivityRecord和TaskRecord关联在一起，它们是Activity 任务栈模型的重要成员，我们接着来查看TaskRecord。</p>

<h3 id="toc_7">6.4.2 解析TaskRecord</h3>

<p>从表中可以发现TaskRecord的作用，其内部存储了任务栈的所有信息，包括任务栈的唯一标识符、任务栈的倾向性、任务栈中的Activity记录和AMS的引用等，需要注意的是其中含有ActivityStack,也就是当前Activity 任务栈所归属的ActivityStack,我们接着来查看ActivityStack。</p>

<p><img src="media/15537009469734/15768333354799.jpg" alt="" style="width:876px;"/><br/>
<img src="media/15537009469734/15768333476066.jpg" alt="" style="width:859px;"/></p>

<h3 id="toc_8">6.4.3 解析ActivityStack</h3>

<p>ActivityStack是一个管理类，用来管理系统所有Activity的各种状态，其内部维护了TaskRecord的列表，因此从Activity任务栈这一角度来说，ActivityStack也可以理解为Activity堆栈。它由ActivityStackSupervisor来进行管理的，而ActivityStackSupervisor在AMS中的构造方法中被创建。</p>

<p><strong>ActivityStack的实例类型</strong></p>

<pre><code class="language-text">```
public final class ActivityStackSupervisor implements DisplayListener {
   ...
    //用来存储Launcher App的所有Activity
    ActivityStack mHomeStack;

    //表示当前正在接收输入或启动下一个Activity的所有Activity
    ActivityStack mFocusedStack; 

    //表示此前接收输入的所有Activity。
    private ActivityStack mLastFocusedStack;
    ...
}
```
</code></pre>

<p><strong>ActivityState</strong></p>

<ul>
<li><p>ActivityStack中通过枚举存储了Activity的所有的状态：</p>
<pre><code class="language-text">enum ActivityState {
       INITIALIZING,<br/>
       RESUMED,<br/>
       PAUSING,<br/>
       PAUSED,<br/>
       STOPPING,<br/>
       STOPPED,<br/>
       FINISHING,<br/>
       DESTROYING,<br/>
       DESTROYED<br/>
}
</code></pre></li>
</ul>

<p><strong>特殊状态的Activity</strong></p>

<ul>
<li><p>这些特殊的状态都是ActivityRecord类型的，ActivityRecord用来记录一个Activity的所有信息。</p>
<pre><code class="language-text">ActivityRecord mPausingActivity = null;//正在暂停的Activity
ActivityRecord mLastPausedActivity = null;//上一个已经暂停的Activity<br/>
ActivityRecord mLastNoHistoryActivity = null;//最近一次没有历史记录的Activity<br/>
ActivityRecord mResumedActivity = null;//已经Resume的Activity<br/>
ActivityRecord mLastStartedActivity = null;//最近一次启动的Activity<br/>
ActivityRecord mTranslucentActivityWaiting = null;//传递给convertToTranslucent方法的最上层的Activity
</code></pre></li>
</ul>

<p><strong>维护的ArrayList</strong></p>

<ul>
<li>ActivityStack中维护了很多ArrayList，这些ArrayList中的元素类型主要有ActivityRecord和TaskRecord，其中TaskRecord用来记录Activity的Task。</li>
</ul>

<p><img src="media/15537009469734/15768324062971.jpg" alt="" style="width:716px;"/></p>

<h2 id="toc_9">6.5 Activity栈管理</h2>

<p>Activity栈：存储和管理Activity。</p>

<h3 id="toc_10">6.5.1 Activity任务栈模型</h3>

<p><img src="media/15537009469734/15770729871003.jpg" alt="" style="width:335px;"/></p>

<ul>
<li>ActivityRecord用来记录一个Activity 的所有信息</li>
<li>TaskRecord 中包含了一个或多个ActivityRecord, TaskRecord 用来表示Activity 的任务栈，用来管理栈中的ActivityRecord</li>
<li>ActivityStack又包含了一个或多个TaskRecord,它是TaskRecord的管理者。Activity 栈管理就是建立在Activity 任务栈模型之上的</li>
</ul>

<p>有了栈管理，我们可以对应用程序进行操作，应用可以复用自身应用中以及其他应用的Activity, 节省了资源。</p>

<h3 id="toc_11">6.5.2 Launch Mode</h3>

<ul>
<li>standerd：默认模式，每次启动Activity都会创建一个新的Activity实例。</li>
<li>singleTop：如果要启动的Activity已经在栈顶，则不会重新创建Activity，同时该Activity的onNewIntent方法会被调用。如果要启动的Activity不在栈顶，则会重新创建该Activity的实例。</li>
<li>singleTask：如果要启动的Activity已经存在于它想要归属的栈中，那么不会创建该Activity实例，将栈中位于该Activity上的所有的Activity出栈，同时该Activity的onNewIntent方法会被调用。如果要启动的Activity不存在于它想要归属的栈中，并且该栈存在，则会重新创建该Activity的实例。如果要启动的Activity想要归属的栈不存在，则首先要创建一个新栈，然后创建该Activity实例并压入到新栈中。</li>
<li>singleInstance：和singleTask基本类似，不同的是启动Activity时，首先要创建在一个新栈，然后创建该Activity实例并压入新栈中，新栈中只会存在这一个Activity实例。</li>
</ul>

<h3 id="toc_12">6.5.3 Intent的FLAG</h3>

<ul>
<li>FLAG_ACTIVITY_NO_HISTORY：Activity一旦退出，就不会存在于栈中。同样的，也可以在AndroidManifest.xml中设置“android:noHistory”。</li>
<li>FLAG_ACTIVITY_MULTIPLE_TASK：需要和FLAG_ACTIVITY_NEW_TASK一同使用才有效果，系统会启动一个新的栈来容纳新启动的Activity.</li>
<li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：Activity不会被放入到“最近启动的Activity”列表中。</li>
<li>FLAG_ACTIVITY_BROUGHT_TO_FRONT：这个标志位通常不是由应用程序中的代码设置的，而是Launch Mode为singleTask时，由系统自动加上的。</li>
<li>FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY：这个标志位通常不是由应用程序中的代码设置的，而是从历史记录中启动的（长按Home键调出）。</li>
<li>FLAG_ACTIVITY_CLEAR_TASK：需要和FLAG_ACTIVITY_NEW_TASK一同使用才有效果，用于清除与启动的Activity相关栈的所有其他Activity。</li>
</ul>

<h3 id="toc_13">6.5.4 taskAffinity</h3>

<p>我们可以在AndroidManifest.xml设置android:taskAffinity，用来指定Activity希望归属的栈， 默认情况下，同一个应用程序的所有的Activity都有着相同的taskAffinity。taskAffinity在下面两种情况时会产生效果：</p>

<ul>
<li>askAffinity与FLAG_ACTIVITY_NEW_TASK或者singleTask配合。如果新启动Activity的taskAffinity和栈的taskAffinity相同（栈的taskAffinity取决于根Activity的taskAffinity）则加入到该栈中。如果不同，就会创建新栈。</li>
<li>taskAffinity与allowTaskReparenting配合。如果allowTaskReparenting为true，说明Activity具有转移的能力。</li>
</ul>

<p><img src="media/15537009469734/15770737826060.jpg" alt="" style="width:567px;"/></p>

<h2 id="toc_14">6.6 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15536970943141.html">
                
                  <h1>06 设计模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html'>进阶之光</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15518627036171.html">
                
                  <h1>07 Android动画深入分析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/06</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15536971035774.html">
                
                  <h1>07 事件总线</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>为了简化并且更加高质量地在Activity、Fragment、Thread和Service等之间的通信，同时解决组件之间 高耦合的同时仍能继续高效地通信，事件总线设计出现了。</p>

<h2 id="toc_0">7.1　解析EventBus</h2>

<p>EventBus是一款针对Android优化的发布-订阅事件总线。它简化了应用程序内各组件间、组件与后台线 程间的通信。其优点是开销小，代码更优雅，以及将发送者和接收者解耦。</p>

<h3 id="toc_1">7.1.1　使用EventBus</h3>

<p>EventBus的三要素如下。</p>

<ul>
<li>Event：事件。
<ul>
<li>可以是任意类型的对象。</li>
</ul></li>
<li>Subscriber：事件订阅者。
<ul>
<li>在 EventBus 3.0 之前消息处理的方法只能限定于 onEvent、 onEventMainThread、onEventBackgroundThread和onEventAsync，它们分别代表4种线程模型。</li>
<li>而在EventBus 3.0之后，事件处理的方法可以随便取名，但是需要添加一个注解@Subscribe，并且要指定线程模型(默认 为POSTING)。4种线程模型下面会讲到。</li>
</ul></li>
<li>Publisher：事件发布者。
<ul>
<li>可以在任意线程任意位置发送事件， 直接调用 EventBus 的post(Object)方法。可以自己实例化EventBus对象，但一般使用 EventBus.getDefault()就可以。根据post函数参数的类型，会自动调用订阅相应类型事件的函数。</li>
</ul></li>
</ul>

<p>EventBus的4种ThreadMode(线程模型)如下。</p>

<ul>
<li>POSTING(默认)：
<ul>
<li>如果使用事件处理函数指定了线程模型为POSTING，那么该事件是在哪个线程 发布出来的，事件处理函数就会在哪个线程中运行，也就是说发布事件和接收事件在同一个线程中。在线 程模型为POSTING的事件处理函数中尽量避免执行耗时操作，因为它会阻塞事件的传递，甚至有可能会引 起ANR。</li>
</ul></li>
<li>MAIN：
<ul>
<li>事件的处理会在UI线程中执行。事件处理的时间不能太长，长了会导致ANR。</li>
</ul></li>
<li>BACKGROUND：
<ul>
<li>如果事件是在UI线程中发布出来的，那么该事件处理函数就会在新的线程中运行; 如果事件本来就是在子线程中发布出来的，那么该事件处理函数直接在发布事件的线程中执行。在此事件 处理函数中禁止进行UI更新操作。</li>
</ul></li>
<li>ASYNC：
<ul>
<li>无论事件在哪个线程中发布，该事件处理函数都会在新建的子线程中执行;同样，此事件 处理函数中禁止进行UI更新操作。</li>
</ul></li>
</ul>

<p><strong>EventBus基本用法</strong><br/>
(1)自定义一个事件类<br/>
(2)在需要订阅事件的地方注册事件<br/>
<code>EventBus.getDefault().register(this);</code> <br/>
(3)发送事件 <br/>
<code>EventBus.getDefault().post(messageEvent);</code><br/>
(4)处理事件<br/>
(5)取消事件订阅<br/>
<code>EventBus.getDefault().unregister(this);</code></p>

<p><strong>EventBus的黏性事件</strong><br/>
除了上面讲的普通事件外，EventBus还支持发送黏性事件，就是在发送事件之后再订阅该事件也能收到该事件，这跟黏性广播类似。<br/>
(1)订阅者处理黏性事件 <code>sticky = true</code><br/>
(2)发送黏性事件<br/>
<code>EventBus.getDefault().postSticky(new MessageEvent (&quot;黏性事件&quot;)) ;</code></p>

<h3 id="toc_2">7.1.2　源码解析EventBus</h3>

<h2 id="toc_3">7.2　解析otto</h2>

<h3 id="toc_4">7.2.1　使用otto</h3>

<h3 id="toc_5">7.2.2　源码解析otto</h3>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html'>进阶之光</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009631998.html">
                
                  <h1>07 理解WindowManager</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">7.1 Window、WindowManager和WMS</h2>

<ul>
<li>Window是一个抽象类，具体的实现类为PhoneWindow,它对View进行管理。</li>
<li>WindowManager 是一个接口类，继承自接口ViewManager，它是用来管理Window的，它的实现类为WindowManagerImpl。如果我们]想要对Window (View)进行添加、更新和删除操作就可以使用WindowManager,。</li>
<li>WindowManager 会将具体的工作交由WMS来处理，WindowManager 和WMS通过Binder来进行跨进程通信，WMS作为系统服务有很多API是不会暴露给WindowManager的，这一点与ActivityManager和AMS的关系有些类似。</li>
</ul>

<p><img src="media/15537009631998/15770744667327.jpg" alt="" style="width:494px;"/></p>

<p>Window包含了View并对View进行管理，Window用虚线来表示是因为Window是一个抽象概念，用来描述一个窗口，并不是真实存在的，Window 的实体其实也是View。WindowManager用来管理Window,而WindowManager所提供的功能最终会由WMS进行处理。</p>

<h2 id="toc_1">7.2 WindowManager的关联类</h2>

<p><img src="media/15537009631998/15770829130238.jpg" alt="" style="width:874px;"/></p>

<h2 id="toc_2">7.3 Window的属性</h2>

<h3 id="toc_3">7.3.1 Window的类型和显示次序</h3>

<p>Window的类型总体来说分为三大类：</p>

<ul>
<li>Application Window（应用程序窗口）</li>
<li>Sub Window（子窗口）</li>
<li>System Window（系统窗口）</li>
</ul>

<p><strong>应用程序窗口</strong></p>

<pre><code class="language-text">public static final int FIRST_APPLICATION_WINDOW = 1;//1
public static final int TYPE_BASE_APPLICATION   = 1;//窗口的基础值，其他的窗口值要大于这个值
public static final int TYPE_APPLICATION        = 2;//普通的应用程序窗口类型
public static final int TYPE_APPLICATION_STARTING = 3;//应用程序启动窗口类型，用于系统在应用程序窗口启动前显示的窗口。
public static final int TYPE_DRAWN_APPLICATION = 4;
public static final int LAST_APPLICATION_WINDOW = 99;//2
</code></pre>

<p>应用程序窗口的Type值范围为1到99。</p>

<p><strong>子窗口</strong></p>

<p>子窗口，不能独立的存在，需要附着在其他窗口才可以，PopupWindow就属于子窗口。子窗口的Type值范围为1000到1999。</p>

<p><strong>系统窗口</strong><br/>
Toast、输入法窗口、系统音量条窗口、系统错误窗口都属于系统窗口。系统窗口的类型定义如下所示：系统窗口的类型值有接近40个，这里只列出了一小部分， 系统窗口的Type值范围为2000到2999。</p>

<p><strong>窗口显示次序</strong></p>

<p>当一个进程向WMS申请一个窗口时，WMS会为窗口确定显示次序。为了方便窗口显示次序的管理，手机屏幕可以虚拟的用X、Y、Z轴来表示，其中Z轴垂直于屏幕，从屏幕内指向屏幕外，这样确定窗口显示次序也就是确定窗口在Z轴上的次序，这个次序称为Z-Oder。Type值是Z-Oder排序的依据，我们知道应用程序窗口的Type值范围为1到99，子窗口1000到1999 ，系统窗口 2000到2999，，一般情况下，Type值越大则Z-Oder排序越靠前，就越靠近用户。</p>

<h3 id="toc_4">7.3.2 Window的标志</h3>

<p>Window的标志也就是Flag，用于控制Window的显示，同样被定义在WindowManager的内部类LayoutParams中。</p>

<p><img src="media/15537009631998/15770840899344.jpg" alt="" style="width:823px;"/></p>

<p>设置Window的Flag有三种方法：</p>

<ul>
<li>第一种是通过Window的addFlags方法；</li>
<li>第二种通过Window的setFlags方法；</li>
<li>第三种则是给LayoutParams设置Flag，并通过WindowManager的addView方法进行添加。</li>
</ul>

<h3 id="toc_5">7.3.3 软键盘相关模式</h3>

<p>为了使得软键盘窗口能够按照期望来显示，WindowManager的静态内部类LayoutParams中定义了软键盘相关模式：<br/>
<img src="media/15537009631998/15770845654108.jpg" alt="" style="width:879px;"/></p>

<p>设置SoftInputMode：</p>

<ul>
<li>AndroidManifest中Activity的属性android:windowSoftInputMode；</li>
<li>Java代码<code>getWindow().setSoftInputMode</code>。</li>
</ul>

<h2 id="toc_6">7.4 Window的操作</h2>

<p>对于Window的操作，最终都是交由WMS来进行处理。窗口的操作分为两大部分，一部分是WindowManager处理部分，另一部分是WMS处理部分。</p>

<p><img src="media/15537009631998/15771763898405.jpg" alt="" style="width:392px;"/></p>

<h3 id="toc_7">7.4.1 系统窗口的添加过程</h3>

<p><img src="media/15537009631998/15771764592662.jpg" alt="" style="width:869px;"/></p>

<h3 id="toc_8">7.4.2 Activity的添加过程</h3>

<ol>
<li>Activity 在启动过程中，如果Activity所在的进程不存在则会创建新的进程，创建新的进程之后就会运行代表主线程的实例ActivityThread；</li>
<li>当界面要与用户进行交互时，会调用ActivityThread 的handleResumeActivity方法；</li>
<li>performResumeActivity方法最终会调用Activity 的onResume方法；</li>
<li>得到ViewManager类型的对象后，调用了ViewManager 的addView方法，而addView方法则是在WindowManagerImpl中实现的，addView方法的第一个参数为DecorView。</li>
</ol>

<h3 id="toc_9">7.4.3 Window的更新过程</h3>

<p>Window的更新过程和Window的添加过程是类似的。</p>

<ol>
<li>调用ViewManager的updateViewLayout方法，updateViewLayout 方法在WindowManagerImpl 中实现，WindowManagerImpl的updateViewLayout方法会调用WindowManagerGlobal的updateViewI ayout方法</li>
<li>更新的参数设置到View中，得到要更新的窗口在View列表中的索引在ViewRootImpl列表中根据索引得到窗口的ViewRootlmpl，更新布局参数列表，调用ViewRootImpl的setLayoutParams方法将更新的参数设置到ViewRootImpl 中，ViewRootImpl的setLayoutParams 方法在最后会调用ViewRootImpl的scheduleTraversals方法。</li>
<li>在TraversalRunnable的run方法中调用了doTraversal方法，在doTraversal方法中又调用了performTraversals 方法，performTraversals 方法使得ViewTree开始View的工作流程：
<ol>
<li>relayoutWindow方法内部会调用IWindowSession 的relayout方法来更新Window视图，最终会调用WMS的relayoutWindow方法。</li>
<li>performTraversals 方法分别调用performMeasure、performLayout和performDraw方法,它们的内部又会调用View的measure、layout和draw方法，这样就完成了View 的工作流程。</li>
</ol></li>
<li>在performTraversals方法中更新了Window视图，又执行Window中的View的工作流程，这样就完成了Window 的更新。</li>
</ol>

<h2 id="toc_10">7.5 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15536971152612.html">
                
                  <h1>08 函数响应式编程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>函数式编程是一种编程范式。我们常见的编程范式有命令式编程、函数式编程和逻辑式编程。我们常见的面向对象编程是一种命令式编程。命令式编程是面向计算机硬件的抽象，有变量、赋值语句、表达式和控制语句。而函数式编程是面向数学的抽象，将计算描述为一种表达式求值，函数可以在任何地方定 义，并且可以对函数进行组合。<br/>
响应式编程是一种面向数据流和变化传播的编程范式，数据更新是相关联的。把函数式编程里的一套思路和响应式编程合起来就是函数响应式编程。<br/>
函数响应式编程可以极大地简化项目，特别是处理嵌套回调的异步事件、复杂的列表过滤和变换或者 时间相关问题。在 Android 开发中使用函数响应式编程的主要有两大框架:一个是RxJava，另一个是Goodle 推出的Agera。</p>

<h2 id="toc_0">8.1　RxJava基本用法</h2>

<h3 id="toc_1">8.1.1　RxJava概述</h3>

<p><strong>1.ReactiveX与RxJava</strong></p>

<p>RxJava是ReactiveX的一种Java实现。 Rx是一个函数库，让开发者可以利用可观察序列和LINQ风格查询操作符来编写异步和基于事件的程序。开发者可以用Observables表示异步数据流，用LINQ操作符查询异步数据流，用Schedulers参数化异步数据流的并发处理。</p>

<p><strong>2.为何要用RxJava</strong></p>

<p>RxJava的原理就是创建一个Observable对象，然后使用各种操作符建立起来的链式操作，就如同流水线一样，把你想要处理的数据一步一步地加工成你想要的成品，然后发射给Subscriber处理。</p>

<p><strong>3.RxJava与观察者模式</strong></p>

<p>RxJava的异步操作是通过扩展的观察者模式来实现的。RxJava有4个角色Observable、Observer、Subscriber和Suject。Observable和 Observer 通过subscribe方法实现订阅关系，Observable就可以在需要的时候通知Observer。</p>

<h3 id="toc_2">8.1.2　RxJava基本实现</h3>

<p>RxJava的基本用法分为如下3个步骤。</p>

<ol>
<li>创建Observer(观察者) <code>onCompleted</code> <code>onError</code> <code>onNext</code></li>
<li>创建 Observable(被观察者) <code>create</code> <code>just</code> <code>from</code></li>
<li>Subscribe(订阅)</li>
</ol>

<h3 id="toc_3">8.1.3　RxJava的不完整定义回调</h3>

<h2 id="toc_4">8.2　RxJava的Subject</h2>

<p>Subject 既可以是一个 Observer 也可以是一个 Observerable，它是连接 Observer 和Observerable的桥梁。</p>

<ol>
<li>PublishSubject</li>
<li>BehaviorSubject</li>
<li>ReplaySubject</li>
<li>AsyncSubject</li>
</ol>

<h2 id="toc_5">8.3　RxJava操作符入门</h2>

<h3 id="toc_6">8.3.1　创建操作符</h3>

<ol>
<li><code>interval</code> 按固定时间间隔发射整数序列</li>
<li><code>range</code> 发射指定范围的整数序列</li>
<li><code>repeat</code> 重复发射特定数据</li>
</ol>

<h3 id="toc_7">8.3.2　变换操作符</h3>

<p>变换操作符的作用是对Observable发射的数据按照一定规则做一些变换操作，然后将变换后的数据发射出去。</p>

<ol>
<li><code>map</code> 变换</li>
<li><code>flatMap</code> 集合变换</li>
<li><code>cast</code> 转换</li>
<li><code>concatMap</code> 连续变换</li>
<li><code>flatMapIterable</code></li>
<li><code>buffer</code> 缓存x个</li>
<li><code>groupBy</code> 分组</li>
</ol>

<h3 id="toc_8">8.3.3　过滤操作符</h3>

<p>过滤操作符用于过滤和选择Observable发射的数据序列，让Observable只返回满足我们条件的数据。</p>

<ol>
<li><code>filter</code> 过滤</li>
<li><code>elementAt</code> 第x个</li>
<li><code>distinct</code> 去重</li>
<li><code>skip</code> 跳过</li>
<li><code>take</code> 只取x个</li>
<li><code>ignoreElements</code> 忽略</li>
<li><code>throttleFirst</code> 发射第一个</li>
<li><code>throttleWithTimeOut</code> 超时限流</li>
</ol>

<h3 id="toc_9">8.3.4　组合操作符</h3>

<p>组合操作符可以同时处理多个Observable来创建我们所需要的Observable。</p>

<ol>
<li><code>startWith</code> 插入数据</li>
<li><code>merge</code> 合并</li>
<li><code>concat</code> 顺序合并</li>
<li><code>zip</code> 合并</li>
<li><code>combineLastest</code></li>
</ol>

<h3 id="toc_10">8.3.5　辅助操作符</h3>

<ol>
<li><code>delay</code> 延迟</li>
<li><code>Do</code> 添加回调
<ul>
<li>doOnEach</li>
<li>doOnNext</li>
<li>doOnSubscribe</li>
<li>doOnUnsubscribe</li>
<li>doOnCompleted</li>
<li>doOnError</li>
<li>doOnTerminate</li>
<li>finallyDo</li>
</ul></li>
<li><code>subscribeOn</code> <code>observeOn</code> 指定线程</li>
<li><code>timeout</code> 超时</li>
</ol>

<h3 id="toc_11">8.3.6　错误处理操作符</h3>

<p>RxJava在错误出现的时候就会调用Subscriber的onError方法将错误分发出去，由Subscriber自己来处理错 误。</p>

<ol>
<li><code>catch</code>
<ul>
<li>onErrorReturn</li>
<li>onErrorResumeNext</li>
<li>onExceptionResumeNext</li>
</ul></li>
<li><code>retry</code></li>
</ol>

<h3 id="toc_12">8.3.7　条件操作符和布尔操作符</h3>

<p>条件操作符和布尔操作符可用于根据条件发射或变换Observable，或者对它们做布尔运算。</p>

<ul>
<li><strong>条件操作符</strong>有<code>amb</code>、<code>defaultIfEmpty</code>、<code>skipUntil</code>、<code>skipWhile</code>、<code>takeUntil</code>和<code>takeWhile</code>等；</li>
<li><strong>布尔操作符</strong>有<code>all</code>、<code>contains</code>、<code>isEmpty</code>、<code>exists</code>和<code>sequenceEqual</code>。</li>
</ul>

<h3 id="toc_13">8.3.8　转换操作符</h3>

<p>转换操作符用来将 Observable 转换为另一个对象或数据结构。转换操作符有 <code>toList</code>、<code>toSortedList</code>、<code>toMap</code>、toMultiMap、getIterator和nest等。</p>

<h2 id="toc_14">8.4　RxJava的线程控制</h2>

<p><strong>1.内置的Scheduler</strong><br/>
如果我们不指定线程，默认是在调用subscribe方法的线程上进行回调的。如果我们想切换线程，就需要使用Scheduler。RxJava 已经内置了如下5个Scheduler。</p>

<ul>
<li>Schedulers.immediate()：直接在当前线程运行，它是timeout、timeInterval和timestamp操作符的默认调度器。</li>
<li>Schedulers.newThread()：总是启用新线程，并在新线程执行操作。</li>
<li>Schedulers.io()：I/O操作(读写文件、读写数据库、网络信息交互等)所使用的 Scheduler。</li>
<li>Schedulers.computation()：计算所使用的 Scheduler，例如图形的计算。</li>
<li>Schedulers.trampoline()：当我们想在当前线程执行一个任务时，并不是立即时，可以用trampoline()将它入队。</li>
<li>AndroidSchedulers.mainThread()：RxAndroid库中提供的Scheduler，它指定的操作在主线程中运行。</li>
</ul>

<p><strong>2.控制线程</strong><br/>
在RxJava中用subscribeOn和observeOn操作符来控制线程。</p>

<h2 id="toc_15">8.5　RxJava的使用场景</h2>

<h3 id="toc_16">8.5.1　RxJava结合OkHttp访问网络</h3>

<h3 id="toc_17">8.5.2　RxJava结合Retrofit访问网络</h3>

<h3 id="toc_18">8.5.3　用RxJava实现RxBus</h3>

<h2 id="toc_19">8.6　RxJava源码解析</h2>

<h3 id="toc_20">8.6.1 RxJava的订阅过程</h3>

<h3 id="toc_21">8.6.2　RxJava的变换过程</h3>

<h3 id="toc_22">8.6.3　RxJava的线程切换过程</h3>

<h2 id="toc_23">8.7　本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html'>进阶之光</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009745315.html">
                
                  <h1>08 理解WindowManagerService</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">8.1 WMS的职责</h2>

<p><strong>窗口管理</strong><br/>
<strong>窗口动画</strong><br/>
<strong>输入系统的中转站</strong><br/>
<strong>Surface管理</strong></p>

<p><img src="media/15537009745315/15771805499610.jpg" alt="" style="width:846px;"/></p>

<h2 id="toc_1">8.2 WMS的创建过程</h2>

<p><img src="media/15537009745315/15771806852964.jpg" alt="" style="width:550px;"/></p>

<h2 id="toc_2">8.3 WMS的重要成员</h2>

<h2 id="toc_3">8.4 Window的添加过程（WMS处理部分）</h2>

<p>addWindow方法分了3个部分来进行讲解，主要就是做了下面4件事：</p>

<ol>
<li>对所要添加的窗口进行检查，如果窗口不满足一些条件，就不会再执行下面的代码逻辑。</li>
<li>WindowToken相关的处理，比如有的窗口类型需要提供WindowToken，没有提供的话就不会执行下面的代码逻辑，有的窗口类型则需要由WMS隐式创建WindowToken。</li>
<li>WindowState的创建和相关处理，将WindowToken和WindowState相关联。</li>
<li>创建和配置DisplayContent，完成窗口添加到系统前的准备工作。</li>
</ol>

<h2 id="toc_4">8.5 Window的删除过程</h2>

<p>Window的删除过程：</p>

<ol>
<li>检查删除线程的正确性，如果不正确就抛出异常。</li>
<li>从ViewRootImpl列表、布局参数列表和View列表中删除与V对应的元素。</li>
<li>判断是否可以直接执行删除操作，如果不能就推迟删除操作。</li>
<li>执行删除操作，清理和释放与V相关的一切资源。</li>
</ol>

<h2 id="toc_5">8.6 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15518627558192.html">
                
                  <h1>08 理解Window和WindowManager</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">8.1 Window和WindowManager</h2>

<p>Window表示的是一个窗口的概念，它的具体实现是PhoneWindow,创建一个Window很简单，只需要WindowManager去实现，WindowManager是外界访问Window的入口，Window的具体实现是在WindowManagerService中，他们两个的交互是一个IPC的过程，Android中的所有视图都是通过Window来实现的。</p>

<p><strong>Flag参数</strong></p>

<ul>
<li>FLAG_NOT_FOCUSABLE
<ul>
<li>表示窗口不需要获取焦点，也不需要接收各种事件，最终的事件会传递给下层的具体焦点的window</li>
</ul></li>
<li>FLAG_NOT_TOUCH_MODAL
<ul>
<li>在此模式下，系统会将当前window区域以外的单击事件传递给底层的Window，此前的Window区域以内的单机事件自己处理，</li>
</ul></li>
<li>FLAG_SHOW_WHEN_LOCKED
<ul>
<li>开启这个属性可以让window显示在锁屏上</li>
</ul></li>
</ul>

<p>Type参数表示window的类型，window有三种类型，分别是应用，子，系统，应用window对应一个Activity,子Window不能单独存在，需要依赖一个父Window。</p>

<p>Window是分层的，每个Window对应着z-ordered,层级大的会覆盖在层级小的Window上面，这和HTML中的z-index的概念是一致的，在这三类中，应用是层级范围是1-99，子window的层级是1000-1999，系统的层级是2000-2999。这些范围对应着type参数，如果想要window在最顶层，那么层级范围设置大一点就好了，很显然系统的值要大一些，系统的值很多，我们一般会选择TYPE_SYSTEM_OVERLAY和TYPE_SYSTEM_ERROR，还需要声明权限。</p>

<p>WindowManager所提供的功能很简单，常用的有三个方法，添加View,更新View,删除View,这三个方法定义在ViewManager中，而WindowManager继承自ViewManager。</p>

<pre><code class="language-text">    public interface ViewManager {
        public void addView(View view, ViewGroup.LayoutParams params);
        public void updateViewLayout(View view, ViewGroup.LayoutParams params);
        public void removeView(View view);
    }
</code></pre>

<p>我们常见的可以拖动的View，其实也很好实现，就是不断的更改他xy的位置：</p>

<pre><code class="language-text">    btn.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                int rawX = (int) event.getRawX();
                int rawY = (int) event.getRawY();
                switch (event.getAction()) {
                    case MotionEvent.ACTION_MOVE:
                        layout.x = rawX;
                        layout.y = rawY;
                        wm.updateViewLayout(btn,layout);
                        break;
                }
                return false;
            }
        });
</code></pre>

<h2 id="toc_1">8.2 Window的内部机制</h2>

<p>Window是一个抽象的概念,每一个Window都对应着一个View和一个ViewRootlmpl,Window和View通过ViewRootImpl 来建立联系，因此Window并不是实际存在的，它是以View的形式存在。这点从WindowManager的定义也可以看出，它提供的三个接口方法addView、updateViewLayout以及removeView都是针对View的，这说明View才是Window存在的实体。在实际使用中无法直接访问Window, 对Window 的访问必须通过WindowManager。为了分析Window的内部机制，这里从Window的添加、删除以及更新说起。</p>

<h3 id="toc_2">8.2.1 Window的添加过程</h3>

<p>WindowManagerImpl并没有直接去实现一个Window的三大操作，而是全部交给了WindowManagerGlobal来处理，WindowManagerGlobal是一个工厂的性质提供自己的实现。WindowManagerImpl这种工作模式就是典型的桥接模式，将所有的操作全部委托给WindowManagerGlobal去实现，WindowManagerGlobal的addView方法主要分如下几步：</p>

<ol>
<li>检查参数是否合法，如果是子Window还需要调整一下参数</li>
<li>创建ViewRootImpl并将View添加到列表中</li>
<li>通过ViewRootImpl来更新界面并完成Window的添加</li>
</ol>

<h3 id="toc_3">8.2.2 Window的删除过程</h3>

<h3 id="toc_4">8.2.3 Window的更新过程</h3>

<h2 id="toc_5">8.3 Window的创建过程</h2>

<h3 id="toc_6">8.3.1 Activity的Window创建过程</h3>

<h3 id="toc_7">8.3.2 Dialog的Window创建过程</h3>

<h3 id="toc_8">8.3.3 Toast的Window创建过程</h3>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/06</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537009893410.html">
                
                  <h1>09 JNI原理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15518627494454.html">
                
                  <h1>09 四大组件的工作过程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">9.1 四大组件的运行状态 / 316</h2>

<p><strong>1、Activity（展示型组件）</strong></p>

<p>Activity的主要作用是展示一个界面并和用户交互，它扮演的是一种前台界面的角色。</p>

<ul>
<li>需要借助Intent启动。有显示Intent和隐式Intent。隐式Intent指向一个或多个目标Activity组件，当然也可能没有任何一个Activity组件可以处理这个隐式Intent。</li>
<li>可以具有特定的启动模式，比如singleTop、singleTask等。</li>
<li>通过Activity的finish方法来结束一个Activity组件的运行。</li>
</ul>

<p><strong>2、Service（计算型组件）</strong></p>

<p>Service用于在后台执行一系列计算任务。</p>

<ul>
<li>启动状态：做后台计算，不需要和外界有直接的交互。</li>
<li>绑定状态：这个时候Service内部同样可以进行后台计算，但是处于这种状态时外界可以很方便的和Service组件进行通信。</li>
<li>尽管Service组件用于执行后台计算，但它本身是运行在主线程中的，因此耗时的后台计算仍然需要在单独的线程中去完成。</li>
<li>灵活采用stopService和unBindService这两个方法才能完全停止一个Service组件。</li>
</ul>

<p><strong>3、BroadcastReceiver（消息型组件）</strong></p>

<p>BroadcastReceiver用于在不同的组件乃至不同的应用之间传递消息。</p>

<ul>
<li>可以在AndroidManifest中静态注册</li>
<li>动态注册，Context.registerReceiver（）和 Context.unRegisterReceiver（）</li>
<li>通过Context的一系列send方法来发送广播，发送和接收过程的匹配是通过广播接收者的<intent-filter>来描述的。</li>
<li>不适合用来执行耗时操作。</li>
<li>BroadcastReceiver组件一般来说不需要停止，它也没有停止的概念。</li>
</ul>

<p><strong>4、ContentProvider（数据共享型组件）</strong></p>

<p>ContentProvider用于向其他组件乃至其他应用共享数据。</p>

<ul>
<li>它的内部需要实现增删查改这四种操作，在它的内部维持着一份数据集合，这个数据集合既可以通过数据库来实现，也可以采用其他任何类型来实现，比如List和Map，ContentProvider对数据集合的具体实现并没有任何要求。</li>
<li>ContentProvider内部的insert、deleted、update和query方法需要处理好线程同步，因为这几个方法是在Binder线程池中被调用的。</li>
<li>ContentProvider无需手动停止。</li>
</ul>

<h2 id="toc_1">9.2 Activity的工作过程 / 318</h2>

<p><img src="media/15518627494454/15762322249731.jpg" alt=""/></p>

<p>performLaunchActivity主要完成：</p>

<ol>
<li>从ActivityClientRecord中获取待启动的Activity的组件信息</li>
<li>通过Instrumentation的newActivity方法使用类加载器创建Activity对象</li>
<li>通过LoadedApk的makeApplication方法来尝试创建新的Application对象</li>
<li>创建ContextImpl对象并通过Activity的attach方法来完成一些重要数据的初始化</li>
<li>调用Activity的onCreate()方法</li>
</ol>

<h2 id="toc_2">9.3 Service的工作过程 / 336</h2>

<h3 id="toc_3">9.3.1 Service的启动过程 / 336</h3>

<p><img src="media/15518627494454/15764643787210.jpg" alt=""/></p>

<p>handleCreateService主要完成</p>

<ol>
<li>通过类加载器创建Service的实例</li>
<li>创建Application对象并调用onCreate()</li>
<li>创建ContextImpl并通过Service的attach方法建立联系</li>
<li>调用Service的onCreate方法并将Service对象存储到ActivityThread的一个列表中</li>
</ol>

<h3 id="toc_4">9.3.2 Service的绑定过程 / 344</h3>

<p><img src="media/15518627494454/15764645501108.jpg" alt=""/></p>

<h2 id="toc_5">9.4 BroadcastReceiver的工作过程 / 352</h2>

<p><img src="media/15518627494454/15764650622524.jpg" alt=""/></p>

<h3 id="toc_6">9.4.1 广播的注册过程 / 353</h3>

<h3 id="toc_7">9.4.2 广播的发送和接收过程 / 356</h3>

<h2 id="toc_8">9.5 ContentProvider的工作过程 / 362</h2>

<p><img src="media/15518627494454/15764651187428.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/06</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15536971258250.html">
                
                  <h1>09 注入与依赖注入框架</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">9.1　注解</h2>

<p>从JDK 5开始，Java增加了注解，注解是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过 使用注解，开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充的信息。代码分析工具、 开发工具和部署工具可以通过这些补充信息进行验证、处理或者进行部署。</p>

<h3 id="toc_1">9.1.1　注解分类</h3>

<p>注解分为标准注解和元注解。</p>

<p><strong>1.标准注解</strong></p>

<p>标准注解有以下4种：</p>

<ul>
<li>@Override:
<ul>
<li>对覆盖超类中的方法进行标记，如果被标记的方法并没有实际覆盖超类中的方法，则编 译器会发出错误警告。</li>
</ul></li>
<li>@Deprecated:
<ul>
<li>对不鼓励使用或者已过时的方法添加注解，当编程人员使用这些方法时，将会在编译 时显示提示信息。</li>
</ul></li>
<li>@SuppressWarnings:
<ul>
<li>选择性地取消特定代码段中的警告。</li>
</ul></li>
<li>@SafeVarargs:J
<ul>
<li>DK 7新增，用来声明使用了可变长度参数的方法，其在与泛型类一起使用时不会出现类型安全问题。 </li>
</ul></li>
</ul>

<p><strong>2.元注解</strong></p>

<p>元注解，它用来注解其他注解，从而创建新的注解。元注解有以下几种。 </p>

<ul>
<li>@Targe:
<ul>
<li>注解所修饰的对象范围。</li>
</ul></li>
<li>@Inherited:
<ul>
<li>表示注解可以被继承。</li>
</ul></li>
<li>@Documented:
<ul>
<li>表示这个注解应该被JavaDoc工具记录。 * @Retention:用来声明注解的保留策略。</li>
</ul></li>
<li>@Repeatable:
<ul>
<li>JDK 8 新增，允许一个注解在同一声明类型(类、属性或方法)上多次使用。</li>
</ul></li>
</ul>

<p>其中@Targe注解取值是一个ElementType类型的数组，其中有以下几种取值，对应不同的对象范围。</p>

<ul>
<li> ElementType.TYPE:能修饰类、接口或枚举类型。</li>
<li> ElementType.FIELD:能修饰成员变量。</li>
<li> ElementType.METHOD:能修饰方法。</li>
<li> ElementType.PARAMETER:能修饰参数。</li>
<li> ElementType.CONSTRUCTOR:能修饰构造方法。</li>
<li> ElementType.LOCAL_VARIABLE:能修饰局部变量。</li>
<li> ElementType.ANNOTATION_TYPE:能修饰注解。</li>
<li> ElementType.PACKAGE:能修饰包。</li>
<li> ElementType.TYPE_PARAMETER:类型参数声明。</li>
<li> ElementType.TYPE_USE:使用类型。</li>
</ul>

<p>其中@Retention注解有3种类型，分别表示不同级别的保留策略。</p>

<ul>
<li> RetentionPolicy.SOURCE:源码级注解。
<ul>
<li> 注解信息只会保留在.java源码中，源码在编译后，注解信息被丢弃，不会保留在.class中。</li>
</ul></li>
<li> RetentionPolicy.CLASS:编译时注解。
<ul>
<li> 注解信息会保留在.java 源码以及.class 中。当运行Java程序时， JVM会丢弃该注解信息，不会保留在JVM中。</li>
</ul></li>
<li> RetentionPolicy.RUNTIME:运行时注解。
<ul>
<li> 当运行Java程序时，JVM也会保留该注解信息，可以通过反射获取该注解信息。</li>
</ul></li>
</ul>

<h3 id="toc_2">9.1.2　定义注解</h3>

<p>1）基本定义</p>

<p>定义新的注解类型使用@interface关键字</p>

<pre><code class="language-text">//定义
public @interface Swordsman{}

//使用
@Swordsman
public class AnnotationTest{}
</code></pre>

<p>2）定义成员变量</p>

<p>注解只有成员变量，没有方法。注解的成员变量在注解定义中以“无形参的方法”形式来声明，其“方法名”定义了该成员变量的名字，其返回值定义了该成员变量的类型。还可以使用default关键字为其指定默认值。</p>

<pre><code class="language-text">//定义注解和成员变量
public @interface Swordsman{
    String name();
    int age();
}
//使用
public class AnnotationTest{
    @Swordsman(name=&quot;张无忌&quot;,age=23)
    public void fighting(){ }
}
//default指定默认值
public @interface Swordsman{
    String name() default &quot;张无忌&quot;;
    int age() default 23;
}
</code></pre>

<p>3）定义运行时/编译时注解</p>

<p>可以用@Retention来设定注解的保留策略，这 3个策略的生命周期长度为 SOURCE &lt;CLASS&lt; RUNTIME。生命周期短的能起作用的地方，生命周期长的一定也能起作用。</p>

<ul>
<li>一般如果需要在运行时去动态获取注解信息，那只能用RetentionPolicy.RUNTIME;</li>
<li>如果要在编译时进行一些预处理操作，比如生成一些辅助代码，就用 RetentionPolicy.CLASS;</li>
<li>如果只是做一些检查性的操作，比如@Override 和 @SuppressWarnings，则可选用RetentionPolicy.SOURCE。当设定为RetentionPolicy.RUNTIME时，这个注解就是运行时注解。</li>
</ul>

<h3 id="toc_3">9.1.3　注解处理器</h3>

<p>对于不同的注解有不同的注解处理器。 虽然注解处理器的编写会千变万化，但是其也有处理标准，比如:针对运行时注解会采用反射机制处理， 针对编译时注解会采用 AbstractProcessor 来处理。</p>

<p><strong>1.运行时注解处理器</strong></p>

<p>处理运行时注解需要用到反射机制。通过反射获得Field、Method等信息，调用<code>getAnnotation()</code>方法即可获得注解信息。</p>

<p><strong>2.编译时注解处理器</strong></p>

<ol>
<li>定义注解</li>
<li>编写注解处理器
<ol>
<li>注解处理器ClassProcessor，它继承AbstractProcessor</li>
<li>方法有init、process、getSupportedAnnotationTypes、getSupportedSourceVersion等。</li>
</ol></li>
<li>注册注解处理器
<ol>
<li>使用Google 开源的AutoService</li>
<li>在ClassProcessor中添加@AutoService(Processor.class)</li>
</ol></li>
<li>应用注解</li>
<li>使用android-apt插件
<ol>
<li>仅仅在编译时期去依赖注解处理器所在的函数库并进行工作，但不会打包到APK中。</li>
<li>为注解处理器生成的代码设置好路径，以便Android Studio能够找到它。</li>
</ol></li>
</ol>

<h2 id="toc_4">9.2　依赖注入的原理</h2>

<h3 id="toc_5">9.2.1　控制反转与依赖注入</h3>

<p><strong>1.控制反转</strong></p>

<p>IoC是Inversion of Control的缩写，即控制反转，借助于“第三方”实现具有依赖关系的对象之间的解耦。</p>

<ol>
<li>引入IoC容器之前：对象A依赖于对象B，那么对象A在初始化的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建对象B还是使用对象B，控制权都在自己手上。</li>
<li>引入IoC容器之后：由于IoC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IoC容器会主动创建一个对象B注入到对象A需要的地方。</li>
<li>通过引入Ioc容器前后的对比，可以看出：对象A获得依赖对象B的过程，由主动行为变为被动行为，控制权颠倒过来了，这就是<strong>控制反转</strong>这个名称的由来。</li>
</ol>

<p><strong>2.依赖注入</strong></p>

<p>Martin Fowler提问：<br/>
控制反转是“哪些方面的控制被反转了呢?”<br/>
答:“获得依赖对象的过程被反转了”。</p>

<p>控制被反转之后，获得依赖对象的过程由自身管理变为由IoC容器主动注入。于是，他给控制反转取了一个更合适的名字，叫作依赖注入(Dependency Injection)，简称DI。所谓依赖注入，是指由IoC容器在运行期间，动态地将某种依赖关系注入到对象中。</p>

<h3 id="toc_6">9.2.2　依赖注入的实现方式</h3>

<p>这里举一个汽车的例子，汽车类Car包含了引擎Engine等组件：</p>

<pre><code class="language-text">public class Car{
    private Engine mEngine;
    public Car(){
        mEngine = new PetrolEngine();
    }
}
</code></pre>

<ol>
<li><p>构造方法注入</p>
<pre><code class="language-text">public class Car{
    private Engine mEngine;<br/>
    public Car(Engine mEngine){<br/>
        this.mEngine = mEngine;<br/>
    }<br/>
}
</code></pre></li>
<li><p>Setter方法注入</p>
<pre><code class="language-text">public class Car{
    private Engine mEngine;<br/>
    public void set(Engine mEngine){<br/>
        this.mEngine = mEngine;<br/>
    }<br/>
}
</code></pre></li>
<li><p>接口注入</p>
<pre><code class="language-text">public interface ICar{
    public void setEngine(Engine engine);<br/>
}<br/>
public class Car implements ICar{<br/>
    private Engine mEngine;<br/>
    @Override<br/>
    public void setEngine(Engine engine){<br/>
        this.mEngine = engine;<br/>
    }<br/>
}
</code></pre></li>
</ol>

<h2 id="toc_7">9.3　依赖注入框架</h2>

<h3 id="toc_8">9.3.1　为何使用依赖注入框架</h3>

<h3 id="toc_9">9.3.2　解析ButterKnife</h3>

<p><strong>1.ButterKnife的注解使用方法</strong></p>

<ol>
<li>添加依赖库</li>
<li>绑定控件
<ul>
<li>@BindView</li>
</ul></li>
<li>绑定资源
<ul>
<li>@BindString、@BindArray、@BindBool、@BindColor、@BindDimen、@BindDrawable和@BindBitmap</li>
</ul></li>
<li>绑定监听
<ul>
<li>@OnClick、@OnLongClick、@OnTextChanged、@OnTouch、@OnItemClick</li>
</ul></li>
<li>可选绑定
<ul>
<li>@Nullable防止找不到资源</li>
</ul></li>
</ol>

<p><strong>2. ButterKnife原理解析</strong></p>

<ol>
<li>ButterKnifeProcessor源码分析
<ol>
<li>ButterKnifeProcessor#process#findAndParseTargets：查找所有注解并解析</li>
<li>brewJava：方法将使用注解的类生成一个JavaFile</li>
</ol></li>
<li>ButterKnife的bind方法<br/>
    1. 得到Activity的 DecorView，findBindingConstructorForClass方法获得构造器并生成实例</li>
<li>生成的辅助类分析
<ol>
<li>DecorView传入这个类中，通过findViewById将View返回。</li>
</ol></li>
</ol>

<h3 id="toc_10">9.3.3　解析Dagger2</h3>

<p>Dagger2是一个基于JSR-330(Java依赖注入)标准的依赖注入框架，在编译期间自动生成代码，负责依赖对象的创建。</p>

<p><strong>1.注解使用方法</strong></p>

<ol>
<li>添加依赖库</li>
<li><p>@Inject和@Component</p>
<ol>
<li>@Inject：用于标记需要注入的依赖</li>
<li>@Component：注入器，可以编译生成类，调用注入方法</li>
</ol>
<pre><code class="language-text">@Component
public interface MainActivityComponent {<br/>
    void inject (MainActivity activity) ;<br/>
}<br/>
public class MainActivity extends AppCompatActivity {<br/>
    @Inject<br/>
    Watch watch;<br/>
    @Override<br/>
    protected void onCreate (Bundle savedInstanceState) {<br/>
        super.onCreate(savedInstanceState);<br/>
        setContentView(R.layout.activity_main);<br/>
        Dagger MainActivityComponent.create().inject(this);<br/>
        watch.work();<br/>
    }<br/>
}
</code></pre></li>
<li><p>@Module和@Provides</p>
<ol>
<li>如果项目中使用了第三方的类库，或需要注入的类是抽象类，可以采用@Module和@Provides提供注入器。</li>
</ol>
<pre><code class="language-text">@Module
public class GsonModule {<br/>
    @Provides<br/>
    public Gson provideGson() {<br/>
        return new Gson();<br/>
    }<br/>
}<br/>
@Component (modules = GsonModule.class)<br/>
public interface MainActivityComponent {<br/>
    void inject (MainActivity activity);<br/>
}
</code></pre></li>
<li><p>@Named和@Qualifier</p>
<ol>
<li>@Qualifier 是限定符，@Named 则是@Qualifier 的一种实现。</li>
<li>当有两个相同的依赖时，它们都继承同一个父类或者均实现同一个接口。当它们被提供给高层时，Component 就不知道我们到底要提供哪一个依赖 对象了，因为它找到了两个。</li>
<li>或者通过自定义注解来实现。</li>
</ol>
<pre><code class="language-text">@Module
public class Eng ineModule {<br/>
    @Provides<br/>
    @Named(&quot;Gasoline&quot;)<br/>
    public Engine provideGasoline() {<br/>
        return new GasolineEngine() ;<br/>
    }<br/>
    @Provides<br/>
    @Named(&quot;Diesel&quot;)<br/>
    public Engine provideDiesel() {<br/>
        return new DieselEngine() ;<br/>
    }<br/>
}<br/>
public class Car {<br/>
    private Engine engine;<br/>
    @Inject<br/>
    public Car(@Named(&quot;Diesel&quot;) Engine engine) {<br/>
        this.engine = engine;<br/>
    }<br/>
}
</code></pre>
<pre><code class="language-text">@Qualifier
@Retention(RUNTIME)<br/>
public dinterface Gasoline {}<br/>
@Qualifier<br/>
@Retention(RUNTIME)<br/>
public dinterface Diesel {}<br/>
@Module<br/>
public class EngineModule {<br/>
    @Provides<br/>
    @Gasoline<br/>
    public Engine provideGasoline() {<br/>
        return new Gasol ineEngine();<br/>
    }<br/>
    @Provides<br/>
    @Diesel<br/>
    public Engine provideDiesel() {<br/>
        return new DieselEngine();<br/>
    }<br/>
}<br/>
public class Car {<br/>
    private Engine engine;<br/>
    @Inject<br/>
    public Car(@Gasoline Engine engine) {<br/>
        this.engine = engine;<br/>
    }<br/>
    public String run() {<br/>
        return engine.work();<br/>
    }<br/>
}
</code></pre></li>
<li><p>@Singleton和@Scope</p>
<ol>
<li>@Scope是用来自定义注解的，而@Singleton则是用来配合实现局部单例和全局单例的。@Singleton本身不具备创建单例的能力。</li>
<li>如果想实现全局单例，我们可以用@Scope结合Application来实现。</li>
</ol></li>
<li><p>@Component的dependencies</p>
<ol>
<li>@Component也可以用dependencies依赖于其他Component。</li>
</ol></li>
</ol>

<p><strong>2.懒加载</strong><br/>
Dagger2提供了懒加载模式，在@Inject的时候不初始化，而是使用的时候，调用get方法来获取实例。<br/>
<strong>3.Dagger2原理解析</strong></p>

<ol>
<li>WatchModule_ProvideWatchFactory 用来生成 Watch 实例；</li>
<li>Dagger2Activity_MemberInject 将 Watch 实例赋值 给 MainActivity 的成员变量 Watch；</li>
<li>DaggerActivityComponent则作为程序入口和桥梁，负责初始化 WatchModule_ProvideWatchFactory和Dagger2Activity_MemberInject，并将它们串联起来。</li>
</ol>

<h2 id="toc_11">9.4　本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html'>进阶之光</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15518627703620.html">
                
                  <h1>10 Android的消息机制</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">10.1 Android的消息机制概述</h2>

<p>Android的消息机制主要是指Handler的运行机制，从开发的角度来说，Handler 是Android消息机制的上层接口，通过它可以轻松地将一个任务切换到Handler所在的线程中去执行。Handler 的运行需要底层的MessageQueue和Looper的支撑。</p>

<ul>
<li>MessageQueue 消息队列，内部存储了一组消息，以队列的形式对外提供插入和删除的工作，采用单链表的数据结构来存储消息列表。</li>
<li>Looper 消息循环。由于MessageQueue只是一个消息的存储单元，它不能去处理消息，而Looper就填补了这个功能，Looper 会以无限循环的形式去查找是否有新消息，如果有的话就处理消息，否则就一直等待着 。</li>
<li>ThreadLocal 并不是线程，它的作用是<mark>可以在每个线程中存储数据</mark>。我们知道，Handler 创建的时候会采用当前线程的Looper来构造消息循环系统，那么<mark>Handler内部如何获取到当前线程的Looper呢</mark>?这就要使用ThreadLocal了，ThreadLocal可以在不同的线程中互不干扰地存储并提供数据，通过ThreadLocal可以轻松获取每个线程的Looper。</li>
<li>当然需要注意的是，线程是默认没有Looper的，如果需要使用Handler就必须为线程创建Looper。我们经常提到的主线程，也叫UI线程，它就是ActivityThread， ActivityThread 被创建时就会初始化Looper，这也是在主线程中默认可以使用Handler的原因。</li>
</ul>

<h2 id="toc_1">10.2 Android的消息机制分析</h2>

<p><strong>子线程中无法访问UI</strong></p>

<ul>
<li>如何解决<code>子线程中无法访问UI</code>？
<ul>
<li>答：使用Handler，将访问UI的工作切换到主线程。</li>
</ul></li>
<li>为什么<code>子线程中无法访问UI</code>？
<ul>
<li>答：这是因为Android的UI控件<mark>不是线程安全</mark>的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态。那为什么系统不对UI控件的访问加上<strong>锁机制</strong>呢?缺点有两个：首先加上锁机制会让UI访问的<mark>逻辑变得复杂</mark>;其次锁机制会降低UI访问的<mark>效率</mark>，因为锁机制会阻塞某些线程的执行。鉴于这两个缺点，最简单且高效的方法就是采用单线程模型来处理UI操作，对于开发者来说也不是很麻烦，只是需要通过Handler切换一下UI访问的执行线程即可。</li>
</ul></li>
</ul>

<p><strong>Handler工作原理</strong></p>

<ol>
<li><strong>创建Handler和Looper。</strong>
<ol>
<li>Handler创建时会采用当前线程的Looper来构建内部的消息循环系统，如果当前线程没有Looper，那么就会报错，需要手动创建Looper。</li>
</ol></li>
<li><strong>发送消息。</strong>
<ol>
<li>通过Handler的post方法将一个Runnable投递到Handler内部的Looper中去处理，</li>
<li>也可以通过Handler的send方法发送一个消息，这个消息同样会在Looper中去处理。其实post方法最终也是通过send方法来完成的，接下来主要来看一下send方法的工作过程。</li>
<li>当Handler的send方法被调用时，它会调用MessageQueue的enqueueMesssagge方法将这个消息放入消息队列中。</li>
</ol></li>
<li><strong>处理消息。</strong>
<ol>
<li>Looper发现有新消息到来时，就会处理这个消息，最终消息中的Runnable或者Handler的handleMessage方法就会被调用。</li>
<li>注意Looper是运行在创建Handler所在的线程中的，这样一来Handler中的业务逻辑就被切换到创建Handler所在的线程中去执行了。</li>
</ol></li>
</ol>

<p><img src="media/15518627703620/15773317153495.jpg" alt="" style="width:630px;"/></p>

<h3 id="toc_2">10.2.1 ThreadLocal的工作原理</h3>

<p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。</p>

<p>在日常开发中用到ThreadLocal的地方较少，但是在某些特殊的场景下，通过ThreadLocal可以轻松地实现一些看起来很复杂的功能，这一点在Android的源码中也有所体现，比如Looper、 ActivityThread以及AMS中都用到了ThreadLocal。</p>

<p><strong>ThreadLocal的使用场景：</strong></p>

<ol>
<li>当某些数据是<mark>以线程为作用域</mark>并且<mark>不同线程具有不同的数据副本</mark>的时候，就可以考虑采用ThreadLocal。比如对于Handler来说，它需要获取当前线程的Looper， 很显然Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松实现Looper在线程中的存取。</li>
<li>ThreadLocal另一个使用场景是<mark>复杂逻辑下的对象传递</mark>，比如监听器的传递，有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口的多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以怎么做呢?其实这时就可以采用ThreadLocal，采用ThreadLocal可以让监听器作为线程内的全局对象而存在，在线程内部只要通过get方法就可以获取到监听器。</li>
</ol>

<h3 id="toc_3">10.2.2 消息队列的工作原理</h3>

<p>消息队列在Android中指的是MessageQueue, MessageQueue主要包含两个操作：插入和读取。数据结构是单链表，单链表在插入和删除上比较有优势。</p>

<ul>
<li>enqueueMessage 插入消息</li>
<li>next 读取并移除一条消息。</li>
</ul>

<p>next方法是一个无限循环的方法，如果消息队列中没有消息，那么next方法会一直阻塞在这里。 当有新消息到来时，next 方法会返回这条消息并将其从单链表中移除。</p>

<h3 id="toc_4">10.2.3 Looper的工作原理</h3>

<p>Looper在Android的消息机制中扮演着消息循环的角色，具体来说就是它会不停地从MessageQueue中查看是否有新消息,如果有新消息就会立刻处理,否则就一直阻塞在那里。</p>

<p><strong>Looper的工作原理</strong></p>

<ol>
<li>Looper.prepare()创建Looper
<ul>
<li>Looper的构造方法中会创建一个MessageQueue</li>
</ul></li>
<li>Looper.loop()开启消息轮询</li>
<li>msg.target.dispatchMessage(msg)消息的发送者Handler分发消息然后处理</li>
</ol>

<p>Looper的其他方法：</p>

<ul>
<li>prepareMainLooper方法，这个方法主要是给主线程也就是ActivityThread创建Looper使用的，其本质也是通过prepare方法来实现的。由于主线程的Looper比较特殊，所以Looper提供了一个getMainLooper方法，通过它可以在任何地方获取到主线程的Looper。</li>
<li>退出Looper，Looper提供了quit和quitSafely来退出一个Looper，二者的区别是: quit 会直接退出Looper，而quitSafely 只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全地退出。Looper 退出后，通过Handler发送的消息会失败，这个时候Handler的send方法会返回false。在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待的状态，而如果退出Looper以后，这个线程就会立刻终</li>
</ul>

<h3 id="toc_5">10.2.4 Handler的工作原理</h3>

<p>Handler的工作主要包含消息的发送和接收过程。消息的发送可以通过post 的一系列方法以及send的一 系列方法来实现, post的一系列方法最终 是通过send的一系列方法来实现的。发送一条消息的典型过程如下所示。</p>

<ol>
<li>发送消息
<ul>
<li>Handler.sendMessageDelayed -&gt; Handler.sendMessageAtTime() -&gt; MessageQueue.enqueueMessage()</li>
</ul></li>
<li>分发消息 (Handler#dispatchMessage)
<ol>
<li>使用Message的callback处理消息</li>
<li>创建Handler的实例handleCallback处理消息</li>
<li>调用Handler的handleMessage来处理消息</li>
</ol></li>
</ol>

<h2 id="toc_6">10.3 主线程的消息循环</h2>

<p>主线程ActivityThread的main方法中：</p>

<ol>
<li>创建主线程的Looper：Looper.prepareMainLooper();</li>
<li>开启主线程的消息循环：Looper.loop();</li>
</ol>

<p><strong>ActivityThread.H</strong><br/>
负责ActivityThread中的消息队列进行，它内部定义了一组消息类型，主要包含了四大组件的启动和停止等过程，如下所示。</p>

<p>Activity和四大组件通信间通信：</p>

<ol>
<li>ActivityThread通过ApplicationThread和AMS发送请求</li>
<li>AMS完成请求后回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息</li>
<li>H收到消息后将ApplicationThread的逻辑切换到Activity中去执行</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/06</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010008552.html">
                
                  <h1>10 Java虚拟机</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">10.1 概述</h3>

<h4 id="toc_1">10.1.1 Java虚拟机家族</h4>

<ol>
<li>HotSpot VM</li>
<li>J9 VM</li>
<li>Zing VM</li>
</ol>

<h4 id="toc_2">10.1.2 Java虚拟机执行流程</h4>

<p><img src="media/15537010008552/15748433740583.jpg" alt="" style="width:524px;"/><br/>
<img src="media/15537010008552/15748433876904.jpg" alt="" style="width:426px;"/></p>

<h3 id="toc_3">10.2 Java虚拟机结构</h3>

<p><img src="media/15537010008552/15748434308127.jpg" alt="" style="width:453px;"/></p>

<h4 id="toc_4">10.2.1 Class文件格式</h4>

<p><img src="media/15537010008552/15748435663601.jpg" alt="" style="width:654px;"/></p>

<h4 id="toc_5">10.2.2 类的生命周期</h4>

<p><strong>类的生命周期：</strong><br/>
一个Java文件，从<code>被加载到Java虚拟机内存中</code>到<code>从内存中卸载</code>的过程。</p>

<ol>
<li>加载：查找并加载Class文件。</li>
<li>链接
<ol>
<li>验证：确保被导入类型的正确性。</li>
<li>准备：为类的静态字段分配字段，并用默认值初始化这些字段。</li>
<li>解析：虚拟机将常量池内的符号引用替换为直接引用。</li>
</ol></li>
<li>初始化：将类变量初始化为正确的初始值。</li>
<li>使用</li>
<li>卸载</li>
</ol>

<p><img src="media/15537010008552/15748439274778.jpg" alt="" style="width:386px;"/></p>

<h4 id="toc_6">10.2.3 类加载子系统</h4>

<p>类加载子系统通过多种类加载器来查找和加载Class文件到Java虚拟机中。Java虚拟机有两种你那个类加载器：系统加载器和自定义加载器。</p>

<p><strong>系统加载器：</strong></p>

<ol>
<li>Bootstrap ClassLoader（引导类加载器）</li>
<li>Extensions ClassLoader（拓展类加载器）</li>
<li>Application ClassLoader（应用程序类加载器）</li>
</ol>

<h4 id="toc_7">10.2.4 运行时数据区域</h4>

<ol>
<li>程序计数器 </li>
<li>Java虚拟机栈</li>
<li>本地方法栈</li>
<li>Java堆</li>
<li>方法区</li>
<li>运行时常量池</li>
<li>直接内存</li>
</ol>

<h3 id="toc_8">10.3 对象的创建</h3>

<ol>
<li>判断对象对应的类是否加载、链接和初始化</li>
<li>为对象分配内存
<ol>
<li>指针碰撞</li>
<li>空闲列表</li>
</ol></li>
<li>处理并发安全问题
<ol>
<li>分配内存进行同步处理</li>
<li>本地线程分配缓冲</li>
</ol></li>
<li>初始化分配到的内存空间</li>
<li>设置对象的对象头</li>
<li>执行init方法进行初始化</li>
</ol>

<h3 id="toc_9">10.4 对象的堆内存布局</h3>

<p>以HotSpot虚拟机为例，对象在堆内存的布局分为三个区域，分别是对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。</p>

<p><img src="media/15537010008552/15748470536456.jpg" alt="" style="width:191px;"/></p>

<h3 id="toc_10">10.5 oop-klass模型</h3>

<p>oop-klass模型模型是用来描述Java对象实例的一种模型，它分为两个部分，OOP（Ordinary  Object Pointer）指普通对象指针，用来表示对象的实例信息。klass用来描述元数据。</p>

<p><img src="media/15537010008552/15748473947755.jpg" alt="" style="width:426px;"/></p>

<h3 id="toc_11">10.6 垃圾标记算法</h3>

<h4 id="toc_12">10.6.1 Java中的引用</h4>

<ol>
<li>强引用：新建对象时引用，不会回收。</li>
<li>软引用：SoftReference，内存不足时回收。</li>
<li>弱引用：WeakReference，GC时回收。</li>
<li>虚引用：PhantomReference，和对象生命周期没有关系；被回收时会收到一个系统通知。</li>
</ol>

<h4 id="toc_13">10.6.2 引用计数算法</h4>

<p>基本思想：背个对象都有一个引用计数器，当对象在某处类引用的时候，它的引用计数器加1，引用失效时减1。当引用计数器中的值为0，则该对象就不能被使用，变成了垃圾。</p>

<p>目前主流Java虚拟机并没有选择使用引用计数算法，因为它没有解决对象之间互相循环引用的问题。</p>

<h4 id="toc_14">10.6.3 根搜索算法</h4>

<p>思想：选定一些对象作为GC Roots，并组成根对象集合，然后以这些GC Roots的对象作为起始点，向下搜索，如果目标对象到GC Roots是连接着的，我们则称为该对象是可达的，如果不可达则说说明目标对象是可以被回收的对象。如图：</p>

<p><img src="media/15537010008552/15748489005643.jpg" alt="" style="width:490px;"/></p>

<p>在Java中，可以作为GC Roots的对象主要有以下几种：</p>

<ul>
<li>Java栈中引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
<li>方法区中运行时常量池引用的对象。</li>
<li>方法区中静态属性引用的对象。</li>
<li>运行中的线程。</li>
<li>由引导类加载器加载的对象。</li>
<li>GC控制的对象。</li>
</ul>

<h3 id="toc_15">10.7 Java对象在虚拟机中的生命周期</h3>

<ol>
<li>创建阶段（Created）
<ol>
<li>为对象分配存储空间</li>
<li>构造对象</li>
<li>从超类到子类对static成员进行初始化</li>
<li>递归调用超类的构造方法</li>
<li>调用子类的构造方法</li>
</ol></li>
<li>应用阶段（In Use）</li>
<li>不可见阶段（Invisible）</li>
<li>不可达阶段（Unreachable）</li>
<li>收集阶段（Collected）</li>
<li>终结阶段（Finalized）</li>
<li>对象空间重新分配阶段（Deallocated）</li>
</ol>

<h3 id="toc_16">10.8 垃圾收集算法</h3>

<h4 id="toc_17">10.8.1 标记—清除算法</h4>

<ul>
<li>标记阶段：标记处可以回收的对象</li>
<li>清除阶段：回收被标记的对象所占的空间。</li>
</ul>

<p><img src="media/15537010008552/15749105545929.jpg" alt="" style="width:435px;"/></p>

<p><strong>缺点：</strong></p>

<ul>
<li>标记和清除的效率不高。</li>
<li>容易产生大量不连续的内存碎片，碎片太多可能导致没有足够的连续内存分配给较大对象，从而触发新的一次垃圾收集动作。</li>
</ul>

<h4 id="toc_18">10.8.2 复制算法</h4>

<p>为了解决标记—清除算法效率不高的问题。</p>

<ol>
<li>它把内存空间划分为两个相等的区域，每次只使用其中一个区域；</li>
<li>在垃圾收集时，遍历当前使用的区域，把存活的对象复制到另一个区域中，最后将当前使用的区域的可回收对象进行回收。</li>
</ol>

<p><img src="media/15537010008552/15749108305016.jpg" alt="" style="width:400px;"/></p>

<ul>
<li>这种算法每次对整个半区进行内存回收，不需要考虑内存碎片问题，代价就是使用内存为原来的一般。</li>
<li>复制算法的效率与存活对象数目有很大关系，如果存活对象很少，复制算法的效率就会很高。所以复制算法广泛应用于新生代中。</li>
</ul>

<h4 id="toc_19">10.8.3 标记-压缩算法</h4>

<p>老年代不适用复制算法，因为老年代对象存活率高，会有很多复制操作，导致效率变低。</p>

<p>标记-压缩算法在标记可回收的对象后，将所有存活的对象压缩到内存的另一端，使他们紧凑地排列在一起，然后对边界以外的内存进行回收。</p>

<p><img src="media/15537010008552/15749117879560.jpg" alt="" style="width:394px;"/></p>

<h4 id="toc_20">10.8.4 分代收集算法</h4>

<p>对不同生命周期的对象采取不同的收集算法，这就是分代的概念。</p>

<ul>
<li>新生代
<ul>
<li>Eden空间</li>
<li>From Survivor空间</li>
<li>To Survivor空间</li>
</ul></li>
<li>老年代</li>
</ul>

<p>Eden空间中大多数对象生命周期很短，Eden空间和两个Survivor空间所占比例为8:1。</p>

<p>根据Java堆区的空间划分，垃圾收集的类型分为两种：</p>

<ul>
<li>Minor Collection：新生代垃圾收集</li>
<li>Full Collection ：老年代收集。又称Major Collection。</li>
</ul>

<p>Full Collection通常情况下伴随至少一次的Minor Collection，收集频率较低，耗时较长。</p>

<p><img src="media/15537010008552/15749127215885.jpg" alt="" style="width:426px;"/></p>

<h3 id="toc_21">10.9 本章小结</h3>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15536971381446.html">
                
                  <h1>10 应用架构设计</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html'>进阶之光</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15518627802999.html">
                
                  <h1>11 Android的线程和线程池</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>AsyncTask封装了线程池和Handler,它主要是为了方便开发者在子线程中更新UI。</li>
<li>HandlerThread是一种具有消息循环的线程，在它的内部可以使用Handler。</li>
<li>IntentService是一个服务，系统对其进行了封装使其可以更方便地执行后台任务，IntentService 内部采用HandlerThread来执行任务，当任务执行完毕后IntentService 会自动退出。 它不容易被系统杀死从而可以尽量保证任务的执行。</li>
</ul>

<h2 id="toc_0">11.1 主线程和子线程</h2>

<ul>
<li>主线程：进程所拥有的线程，主要处理界面交互相关的逻辑。</li>
<li>子线程：除主线程之外都是子线程，主要用于执行耗时操作。</li>
</ul>

<h2 id="toc_1">11.2 Android中的线程形态</h2>

<h3 id="toc_2">11.2.1 AsyncTask</h3>

<p>轻量级的异步任务类，可以执行后台任务以及在子线程中进行UI操作。</p>

<p><strong>主要方法：</strong></p>

<ol>
<li>onPreExecute()</li>
<li>doInBackground(Params…params)：</li>
<li>onProgressUpdate(Progress…values)</li>
<li>onPostExecute(Result result)</li>
<li>onCancelled()</li>
<li>execute(Params...params)</li>
</ol>

<h3 id="toc_3">11.2.2 AsyncTask的工作原理</h3>

<ol>
<li>AsyncTask构造方法中：
<ol>
<li>实例化Handler，类型是InternalHandler，用于切换到主线程</li>
<li>实例化mWorker，类型是WorkerRunnable，封装了Params和Result；</li>
<li>实例化mFuture，类型是FutureTask，参数为mWorker。FutureTask是一个并发类，在这里它充当了Runnable的作用。</li>
</ol></li>
<li>执行任务
<ol>
<li><code>execute</code>方法会调用<code>executeOnExecutor(sDefaultExecutor, params)</code>。
<ol>
<li>参数sDefaultExecutor，类型为<strong>SerialExecutor</strong>，是一个串行的线程池，一个进程中所有的AsyncTask全部在这个串行的线程池中<mark>排队</mark>执行。</li>
<li><strong>SerialExecutor#execute</strong>。(1) ArrayDeque.<strong>offer</strong>(Runnable)。把FutureTask对象插入到任务队列mTasks中；(2) <strong>scheduleNext()</strong>。如果没有正在活动的任务，或者当一个任务执行完后，会调用scheduleNext方法执行下一个任务，直到所有的任务都被执行。scheduleNext中，调用<strong>THREAD_POOL_EXECUTOR.execute()</strong>，<mark>真正地执行任务</mark>。</li>
</ol></li>
<li>executeOnExecutor
<ol>
<li>调用<code>onPreExecute()</code></li>
<li><strong>exec.execute</strong>(mFuture);线程池执行。</li>
</ol></li>
</ol></li>
<li>响应结果
<ol>
<li>mWorker的<strong>call()</strong>中调用<code>doInBackground(mParams)</code>和 <strong>postResult()</strong></li>
<li>postResult中，Handler调用sendToTarget()发送消息。</li>
<li>InternalHandler中，<code>onProgressUpdate</code>和<strong>finish</strong>。</li>
</ol></li>
<li><p>结束或取消<code>onCancelled</code>、<code>onPostExecute</code></p>
<p>从Android 3.0 开始，默认情况下AsyncTask是串行执行的，可以调用<code>executeOnExecutor</code>方法并行执行。</p></li>
</ol>

<h3 id="toc_4">11.2.3 HandlerThread</h3>

<ul>
<li>HandlerThread本质上是一个线程类，它继承了Thread；</li>
<li>HandlerThread有自己的内部Looper对象，可以进行looper循环；</li>
<li>通过获取HandlerThread的looper对象传递给Handler对象，可以在handleMessage方法中执行异步任务。</li>
<li>创建HandlerThread后必须先调用HandlerThread.start()方法，Thread会先调用run方法，创建Looper对象。</li>
<li>当不需要HandlerThread时，通过HandlerThread.quit()/quitSafely()方法来终止线程的执行</li>
</ul>

<h3 id="toc_5">11.2.4 IntentService</h3>

<p>可自动创建子线程来执行任务，且任务执行完毕后自动退出。</p>

<ul>
<li>在IntentService.onCreate()里创建一个Handle对象即HandlerThread，利用其内部的Looper会实例化一个ServiceHandler对象；</li>
<li>任务请求的Intent会被封装到Message并通过ServiceHandler发送给Looper的MessageQueue，最终在HandlerThread中执行；</li>
<li>在ServiceHandler.handleMessage()中会调用IntentService.onHandleIntent()，可在该方法中处理后台任务的逻辑。</li>
</ul>

<h2 id="toc_6">11.3  Android中的线程池</h2>

<p>线程池的优点：</p>

<ul>
<li>重用线程池中的线程，避免线程的创建和销毁带来的性能消耗；</li>
<li>有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致阻塞现象；</li>
<li>能够进行线程管理，提供定时/循环间隔执行等功能。</li>
</ul>

<p>Android中的线程池的概念来源于Java中的Executor, Executor是一个接口，真正的线程池的实现为ThreadPoolExecutor。ThreadPoolExecutor 提供了一系列参数来配置线程池，通过不同的参数可以创建不同的线程池。</p>

<h3 id="toc_7">11.3.1 ThreadPoolExecutor</h3>

<p>ThreadPoolExecutor构造方法：</p>

<pre><code class="language-text">public ThreadPoolExecutor(
    int corePoolSize,   //核心线程数
    int maximumPoolSize,//最大线程数
    long keepAliveTime,//非核心线程超时时间
    TimeUnit unit,//keepAliveTime参数的时间单位
    BlockingQueue&lt;Runnable&gt; workQueue,//任务队列
    ThreadFactory threadFactory,//线程工厂，可创建新线程
    RejectedExecutionHandler handler//饱和策略
)
</code></pre>

<p>ThreadPoolExecutor的默认工作策略：</p>

<ul>
<li>如果线程池中的线程数量未达到核心线程数，则会直接启动一个核心线程执行任务。</li>
<li>若线程池中的线程数量已达到或者超过核心线程数量，则任务会被插入到任务列表等待执行。</li>
<li>若任务无法插入到任务列表中，往往由于任务列表已满，此时如果：
<ul>
<li>线程数量未达到线程池最大线程数，则会启动一个非核心线程执行任务；</li>
<li>线程数量已达到线程池规定的最大值，则拒绝执行此任务</li>
</ul></li>
</ul>

<p>如果条件为否：核心线程 &gt; 任务列表 &gt; 非核心线程 &gt; 拒接任务。</p>

<p>AsyncTask的THREAD_POOL_EXECUTOR线程池配置参数：</p>

<ul>
<li>核心线程数：CPU_COUNT - 1，最小为2最大为4;</li>
<li>线程池的最大线程数：CPU_COUNT * 2+ 1;</li>
<li>核心线程无超时机制，非核心线程在闲置时的超时时间为30秒;</li>
<li>任务队列的容量为128。</li>
</ul>

<h3 id="toc_8">11.3.2 线程池的分类</h3>

<ul>
<li>FixedThreadPool：
<ul>
<li>含义：线程数量固定的线程池，所有线程都是核心线程，当线程空闲时不会被回收。</li>
<li>特点：能快速响应外界请求。</li>
</ul></li>
<li>CachedThreadPool：
<ul>
<li>含义：线程数量不定的线程池（最大线程数为Integer.MAX_VALUE），只有非核心线程，空闲线程有超时机制，60s超时回收。</li>
<li>特点：适合于执行大量的耗时较少的任务</li>
</ul></li>
<li>ScheduledThreadPool：
<ul>
<li>含义：核心线程数量固定，非核心线程数量不定。</li>
<li>特点：定时任务和固定周期的任务。</li>
</ul></li>
<li>SingleThreadExecutor：
<ul>
<li>含义：只有一个核心线程，可确保所有的任务都在同一个线程中按顺序执行。</li>
<li>特点：无需处理线程同步问题。</li>
</ul></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/06</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010053206.html">
                
                  <h1>11 Dalvik和ART</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">11.1 Dalvik虚拟机</h2>

<p>Dalvik虚拟机(Dalvik Virtual Machine )，简称Dalvik VM或者DVM。DVM是Google专门为Android平台开发的虚拟机，它运行在Android运行时库中。需要注意的是DVM并不是一个Java 虚拟机(以下简称JVM)。</p>

<h3 id="toc_1">11.1.1 DVM与JVM的区别</h3>

<p>DVM之所以不是一个 JVM,主要原因是DVM并没有遵循JVM规范来实现， DVM与JVM主要有以下区别。</p>

<ol>
<li><p>基于的架构不同<br/>
JVM基于栈则意味着需要去栈中读写数据，所需的指令会更多,这样会导致速度变慢，对于性能有限的移动设备，显然不是很适合的。DVM是基于寄存器的，它没有基于栈的虚拟机在复制数据时而使用的大量的出入栈指令，同时指令更紧凑、更简洁。但是由于显式指定了操作数,所以基于寄存器的指令会比基于栈的指令要大，但是由于指令数量的减少，总的代码数不会增加多少。</p></li>
<li><p>执行的字节码不同<br/>
在Java SE程序中，Java类被编译成一个或多个.class文件，并打包成jar文件，而后JVM会通过相应的.class文件和jar文件获取相应的字节码。执行顺序为.java文件→.class 文件→.jar文件。<br/>
而DVM会用dx工具将所有的.class文件转换为一个.dex文件，然后DVM会从该dex文件读取指令和数据。执行顺序为.java文件→.class文件一→.dex文件。</p>
<p>jar 文件里面包含多个.class文件，每个.class文件里面包含了该类的常量池、类信息、属性等。当JVM加载该jar文件的时候，会加载里面的所有的.class文件，JVM的这种加载方式很慢，对于内存有限的移动设备并不合适。而在.apk文件中只包含了一个.dex文件，这个.dex文件将所有的.class里面所包含的信息全部整合在一起了，这样再加载就加快了速度。.class 文件存在很多的冗余信息，dex 工具会去除冗余信息，并把所有的.class文件整合到.dex文件中，减少了IO操作，加快了类的查找速度。<br/>
<img src="media/15537010053206/15776932722358.jpg" alt="" style="width:590px;"/>   </p></li>
<li><p>DVM允许在有限的内存中同时运行多个进程<br/>
DVM经过优化,允许在有限的内存中同时运行多个进程。在Android中的每一个应用都运行在一个DVM实例中，每一个DVM实例都运行在一个独立的进程空间中，独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。</p></li>
<li><p>DVM由Zygote创建和初始化<br/>
我们在第2章学习过Zygote，它是一个DVM进程，同时也用来创建和初始化DVM实例。每当系统需要创建一个应用程序时 ，Zygote 就会fock 自身，快速地创建和初始化一个DVM实例，用于应用程序的运行。对于一些只读的系统库，所有的DVM实例都会和Zygote共享一块内存区域，节省了内存开销。</p></li>
<li><p>DVM有共享机制.<br/>
DVM拥有预加载一共 享的机制，不同应用之间在运行时可以共享相同的类，拥有更  高的效率。而JVM机制不存在这种共享机制，不同的程序,打包以后的程序都是彼此独立的,即便它们在包里使用了同样的类，运行时也都是单独加载和运行的，无法进行共享。</p></li>
<li><p>DVM早期没有使用JIT编译器<br/>
JVM使用了JIT编译器(Just In Time Compiler,即时编译器)，而DVM早期没有使用JIT编译器。早期的DVM每次执行代码，都需要通过解释器将dex代码编译成机器码，然后交给系统处理，效率不是很高。为了解决这一问题，从Android 2.2版本开始DVM使用了JIT 编译器，它会对多次运行的代码(热点代码)进行编译，生成相当精简的本地机器码(Native Code)，这样在下次执行到相同逻辑的时候，直接使用编译之后的本地机器码，而不是每次都需要编译。需要注意的是，应用程序每一次重新运行的时候，都要重做这个编译工作，因此每次重新打开应用程序，都需要JIT编译。</p></li>
</ol>

<h3 id="toc_2">11.1.2 DVM架构</h3>

<p><img src="media/15537010053206/15776935576868.jpg" alt="" style="width:328px;"/></p>

<p>首先Java编译器编译的.class文件经过DX工具转换为.dex文件，.dex文件由类加载器处理，接着解释器根据指令集对Dalvik字节码进行解释、执行，最后交于Linux处理。</p>

<h3 id="toc_3">11.1.3 DVM的运行时堆</h3>

<p>DVM的运行时堆使用标记一清除(Mark一Sweep) 算法进行GC，它由两个Space以及多个辅助数据结构组成，两个Space分别是Zygote Space (Zygote Heap)和Allocation Space(Active Heap)。Zygote Space用来管理Zygote进程在启动过程中预加载和创建的各种对象，Zygote Space中不会触发GC,在Zygote进程和应用程序进程之间会共享Zygote Space。在Zygote进程fork第一个子进程之前，会把Zygote Space分为两个部分，原来的已经被使用的那部分堆仍旧叫Zygote Space， 而未使用的那部分堆就叫Allocation Space， 以后的对象都会在Allocation Space上进行分配和释放。Allocation Space不是进程间共享的，在每个进程中都独立拥有一份。除了这两个Space，还包含以下数据结构。</p>

<ul>
<li>Card Table: 用于DVM Concurrent GC，当第一次进行垃圾标记后，记录垃圾信息。</li>
<li> Heap Bitmap: 有两个Heap Bitmap， 一个用来记录上次GC存活的对象，另一个用来记录这次GC存活的对象。</li>
<li>Mark Stack: DVM的运行时堆使用标记一清除(Mark一 Sweep)算法进行GC，MarkStack就是在GC的标记阶段使用的，它用来遍历存活的对象。</li>
</ul>

<h3 id="toc_4">11.1.4 DVM的GC日志</h3>

<p>在10.6.2节中提到了Java虚拟机的GC日志。DVM和ART的GC日志与Java虚拟机的日志有较大的区别。在DVM中每次垃圾收集都会将GC日志打印到logcat中，具体的格式为:</p>

<pre><code class="language-text">D/dalvikvm: &lt;GC Reason&gt; &lt;Amount freed&gt;， &lt;Heap stats&gt;，&lt;External memory stats&gt;,&lt;Pause t ime&gt;
</code></pre>

<p>可以看到DVM的日志共有5个信息，其中GCReason有很多种，这里将它单独拿出来进行介绍。</p>

<p><strong>1.引起GC的原因</strong><br/>
GC Reason就是引起GC的原因，有以下几种。</p>

<ul>
<li>GC_CONCURRENT: 当堆开始填充时，并发GC可以释放内存。</li>
<li>GC_FOR_MALLOC:当堆内存已满时，App尝试分配内存而引起的GC，系统必须停止App并回收内存。</li>
<li>GC_HPROF_DUMP_HEAP:当你请求创建HPROF文件来分析堆内存时出现的GC。</li>
<li>GC_EXPLICIT: 显式的GC，例如调用System.gc() (应该避免调用显式的GC,信任GC会在需要时运行)。</li>
<li>GC_EXTERNAL_ALLOC: 仅适用于API级别小于等于10， 且用于外部分配内存的GC。</li>
</ul>

<p><strong>2.其他的信息</strong><br/>
除了引起GC的原因，其他的信息如下。</p>

<ul>
<li>Amount freed: 本次GC释放内存的大小。</li>
<li>Heap_stats: 堆的空闲内存百分比(已用内存) / (堆的总内存)。</li>
<li>External_memory_stats: API小于等于级别10的内存分配(已分配的内存) / (引起GC的阈值)。</li>
<li>Pausetime:暂停时间，更大的堆会有更长的暂停时间。并发暂停时间会显示两个暂停时间，即一个出现在垃圾收集开始时，另一个出现在垃圾收集快要完成时。</li>
</ul>

<p><strong>3.实例分析</strong></p>

<pre><code class="language-text">D/dalvikvm: GC CONCURRENT freed 2012K, 63号 free 3213K/9291K, external 4501K/5161K,paused 2ms+2ms
</code></pre>

<p>这个GC日志的含义为:引起GC的原因是GC_CONCURRENT;本次GC释放的内存为2012KB; 堆的空闲内存百分比为63%， 已用内存为3213KB，堆的总内存为9291KB;暂停的总时长为4ms。</p>

<h2 id="toc_5">11.2 ART虚拟机</h2>

<p>ART (Android Runtime)虚拟机是Android 4.4发布的,用来替换Dalvik虚拟机，Android4.4默认采用的还是DVM,系统会提供一 个选项来开启ART。在Android 5.0版本中默认采用了ART, DVM从此退出历史舞台。</p>

<h3 id="toc_6">11.2.1 ART与DVM的区别</h3>

<ol>
<li>从11.1节我们知道，DVM中的应用每次运行时,字节码都需要通过JIT编译器编译为机器码，这会使得应用程序的运行效率降低。而在ART中，系统在安装应用程序时会进行一次AOT (ahead of time compilation, 预编译)，将字节码预先编译成机器码并存储在本地，这样应用程序每次运行时就不需要执行编译了，运行效率会大大提升，设备的耗电量也会降低。这就好比我们在线阅读漫画，DVM是我们阅读到哪就加载哪，ART则是直接加载一章的漫画,虽然一开始加载速度有些慢,但是后续的阅读体验会很流畅。采用AOT也会有缺点，主要有两个:第一个是AOT会使得应用程序的安装时间变长，尤其是一些复杂的应用;第二个是字节码预先编译成机器码，机器码需要的存储空间会多一些。为了解决上面的缺点，Android 7.0版本中的ART加入了即时编译器JIT，作为AOT的一个补充，在应用程序安装时并不会将字节码全部编译成机器码，而是在运行中将热点代码编译成机器码，从而缩短应用程序的安装时间并节省了存储空间。</li>
<li>DVM是为32位CPU设计的，而ART支持64位并兼容32位CPU,这也是DVM被淘汰的主要原因之一。</li>
<li>ART对垃圾回收机制进行了改进，比如更频繁地执行并行垃圾收集，将GC暂停由2次减少为1次等。</li>
<li>ART的运行时堆空间划分和DVM不同。</li>
</ol>

<h3 id="toc_7">11.2.2 ART的运行时堆</h3>

<p>与DVM的GC不同的是，ART采用了多种垃圾收集方案，每个方案会运行不同的垃圾收集器,默认是采用了CMS(Concurrent Mark一Sweep)方案,该方案主要使用了sticky一CMS和partial一CMS。根据不同的CMS方案，ART的运行时堆的空间也会有不同的划分，默认是由4个Space和多个辅助数据结构组成的，4个Space分别是Zygote Space、AllocationSpace、Image Space和Large Object Space。Zygote Space、Allocation Space和DVM中的作用是一样的，Image Space用来存放一些预加载类, Large Object Space用来分配一些大对象(默认大小为12KB)，其中Zygote Space和Image Space是进程间共享的。采用标记一清除算法的运行时堆空间划分如图11一3所示。</p>

<p><img src="media/15537010053206/15776955652187.jpg" alt="" style="width:775px;"/></p>

<p>除了这四个Space，ART的Java堆中还包括两个Mod Union Table, 一个Card Table,两个Heap Bitmap,两个Object Map，以及三个Object Stack。</p>

<h3 id="toc_8">11.2.3 ART的GC日志</h3>

<p>ART的GC日志与DVM不同，ART会为那些主动请求的垃圾收集事件或者认为GC速度慢时才会打印GC日志。GC速度慢指的是GC暂停超过5ms或者GC持续时间超过100ms。如果App未处于可察觉的暂停进程状态，那么它的GC不会被认为是慢速的。<br/>
ART的GC日志具体的格式为:</p>

<pre><code class="language-text">I/art: &lt;GC_Reason&gt; &lt;GC_Name&gt; &lt;0bjects_freed&gt; (&lt;Size_freed&gt;) AllocSpace Objects,&lt;Large_objects_freed&gt; (&lt;Large_object_size_freed&gt;) &lt;Heap_stats&gt; LOS objects,
&lt;Pause time(s)&gt;
</code></pre>

<p><strong>1.引起GC原因</strong><br/>
ART的引起GC原因(GC_Reason) 要比DVM多一些，有以下几种。</p>

<ul>
<li>Concurrent: 并发GC,不会使App的线程暂停，该GC是在后台线程运行的，并不会阻止内存分配。</li>
<li>Alloc: 当堆内存已满时，App尝试分配内存而引起的GC，这个GC会发生在正在.分配内存的线程中。</li>
<li>Explicit: App 显示的请求垃圾收集，例如调用System.gc()。与DVM一样，最佳做法是应该信任GC并避免显式地请求GC,显式地请求GC会阻止分配线程并不必要地浪费CPU周期。如果显式地请求GC导致其他线程被抢占,那么有可能会导致jank(App同一帧画了多次)。</li>
<li>NativeAlloc: Native 内存分配时，比如为Bitmaps或者RenderScript分配对象，这会导致Native内存压力，从而触发GC。</li>
<li>CollectorTransition: 由堆转换引起的回收，这是运行时切换GC而引起的。收集器转换包括将所有对象从空闲列表空间复制到碰撞指针空间(反之亦然)。 当前，收集器转换仅在以下情况下出现:在内存较小的设备.上，App将进程状态从可察觉的暂停状态变更为可察觉的非暂停状态(反之亦然)。</li>
<li>HomogeneousSpaceCompact: 齐性空间压缩是指空闲列表到压缩的空闲列表空间，通常发生在当App已经移动到可察觉的暂停进程状态时。这样做的主要原因是减少了内存使用并对堆内存进行碎片整理。</li>
<li>DisableMovingGc: 不是真正触发GC的原因，发生并发堆压缩时，由于使用了GetPrimitiveArrayCritical，收集会被阻塞。在一般情况下，强烈建议不要使用GetPrimitiveArrayCritical，因为它在移动收集器方面具有限制。</li>
<li>HeapTrim: 不是触发GC的原因，但是请注意，收集会一直被阻塞，直到堆内存整理完毕。</li>
</ul>

<p><strong>2.垃圾收集器名称</strong><br/>
GC_Name指的是垃圾收集器名称，有以下几种。</p>

<ul>
<li>Concurrent Mark Sweep (CMS)：CMS 收集器是一种以获取最短收集暂停时间为目标的收集器，采用了标记一清除算法实现。它是完整的堆垃圾收集器，能释放除了Image Space外的所有的空间。</li>
<li>Concurrent Partial Mark Sweep：部分完整的堆垃圾收集器，能释放除了Image Space和Zygote Space外的所有空间。</li>
<li>Concurrent Sticky Mark Sweep：粘性收集器，基于分代的垃圾收集思想，它只能释放自.上次GC以来分配的对象。这个垃圾收集器比一个完整的或部分完整的垃圾收集器扫描得更频繁，因为它更快并且有更短的暂停时间。</li>
<li>Marksweep + Semispace：非并发的GC,复制GC用于堆转换以及齐性空间压缩(堆碎片整理)。</li>
</ul>

<p><strong>3.其他信息</strong></p>

<ul>
<li>Objects freed：本次GC从非Large Object Space中回收的对象的数量。</li>
<li>Size_ freed： 本次GC从非Large Object Space中回收的字节数。</li>
<li>Large objects freed：本次GC从Large Object Space中回收的对象的数量。</li>
<li>Large object size freed：本次GC从Large Object Space中回收的字节数。</li>
<li>Heap stats：堆的空闲内存百分比，即(已用内存) / (堆的总内存)。<br/>
Pause times： 暂停时间， 暂停时间与在GC运行时修改的对象引用的数量成比例。目前，ART的CMS收集器仅有一次暂停，它出现在GC的结尾附近。移动的垃圾收集器暂停时间会很长，会在大部分垃圾回收期间持续出现。</li>
</ul>

<p><strong>4.实例分析</strong></p>

<pre><code class="language-text">I/art : Explicit concurrent mark sweep GC freed 104710 (7MB) AllocSpace objects,21 (416KB) LOS objects， 33号free, 25MB/ 38MB, paused 1.230ms total 67.21 6ms
</code></pre>

<p>这个GC日志的含义为引起GC原因是Explicit; 垃圾收集器为CMS收集器;释放对象的数量为104710个，释放字节数为7MB;释放大对象的数量为21个，释放大对象字节数为416KB;堆的空闲内存百分比为33%，已用内存为25MB,堆的总内存为38MB; GC暂停时长为1.230ms， GC总时长为67.216ms。</p>

<h2 id="toc_9">11.3 DVM和ART的诞生</h2>

<h2 id="toc_10">11.4 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15536972323571.html">
                
                  <h1>11 系统架构与MediaPlayer框架</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html'>进阶之光</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15518627622491.html">
                
                  <h1>12 Bitmap的加载和Cache</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">12.1 Bitmap的高效加载</h2>

<p>BitmapFactory类提供了四类方法：decodeFile、decodeResource、decodeStream和decodeByteArray，分别用于支持从文件系统、资源、输入流以及字节数组中加载出一个Bitmap对象，其中decodeFile和decodeResource又间接调用了decodeStream方法，这四类方法最终是在Android的底层实现的，对应着BitmapFactory类的几个native方法。</p>

<p>如何高效地加载Bitmap 呢?其实核心思想也很简单，那就是采用BitmapFactory.Options来加载所需尺寸的图片。通过BitmapFactory.Options来缩放图片，主要是用到了它的inSampleSize参数，即采样率。</p>

<p>通过采样率即可有效地加载图片,那么到底如何获取采样率呢?获取采样率也很简单，遵循如下流程:</p>

<ol>
<li>将BitmapFactory.Options的inJustDecodeBounds参数设为true并加载图片。</li>
<li>从BitmapFactory.Options 中取出图片的原始宽高信息，它们对应于outWidth 和outHeight参数。</li>
<li>根据采样率的规则并结合目标View的所需大小计算出采样率inSampleSize。</li>
<li>将BitmapFactory.Options的inJustDecodeBounds 参数设为false, 然后重新加载图片。</li>
</ol>

<p>这里说明一下inJustDecodeBounds参数，当此参数设为true时，BitmapFactory 只会解析图片的原始宽/高信息，并不会去真正地加载图片，所以这个操作是轻量级的。</p>

<h2 id="toc_1">12.2 Android中的缓存策略</h2>

<p>缓存策略：内次缓存+存储缓存。当应用打算从网络上请求一张图片时，程序首先从内存中去获取，如果内存中没有那就从存储设备中去获取，如果存储设备中也没有，那就从网络上下载这张图片。</p>

<p>一般来说， 缓存策略主要包含缓存的添加、获取和删除这三类操作。删除缓存目前常用的一种缓存算法是LRU（Least Recently Used）,LRU是近期最少使用算法，它的核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。采用LRU算法的缓存有两种：LruCache和DiskLruCache，LruCache用于实现内存缓存，而DiskLruCache则充当了存储设备缓存。</p>

<h3 id="toc_2">12.2.1 LruCache</h3>

<p>LruCache它是一个泛型类，它内部采用一个LinkedHashMap，当强引用的方式存储外界的缓存对象，其提供了get和put方法来完成缓存的获取和添加操作，当缓存满时，LruCache会移除较早使用的缓存对象，然后再添加新的缓存对象。</p>

<ul>
<li>强引用：直接的对象引用</li>
<li>软引用：当一个对象只有软引用存在时，系统内存不足时此对象会被gc回收。</li>
<li>弱引用：当一个对象只有弱引用存在时，此对象会随时被gc回收。</li>
</ul>

<p>LruCache是线程安全的，因为用到了LinkedHashMap。</p>

<ul>
<li><code>sizeOf</code> 计算缓存对象的大小</li>
<li><code>LruCache.get(key)</code> 获取一个缓存对象</li>
<li><code>LruCache.put(key, bitmap)</code> 添加一个缓存对象</li>
<li><code>LruCache.remove</code>删除一个指定的缓存对象。</li>
<li><code>entryRemoved</code> 移除旧缓存时会调用
<ul>
<li>可以进行一些资源回收工作</li>
</ul></li>
</ul>

<h3 id="toc_3">12.2.2 DiskLruCache</h3>

<p>DiskLruCache用于实现存储设备缓存，即磁盘存储，它通过将缓存对象写入文件系统从而实现缓存的效果。</p>

<ol>
<li>DiskLruCache 的创建 <code>open</code></li>
<li>DiskLruCache 的缓存添加 <code>edit</code> <code>commit</code> <code>abort</code></li>
<li>DiskLruCache的缓存查找和删除 <code>get</code> <code>remove</code> <code>delete</code></li>
</ol>

<h3 id="toc_4">12.2.3 ImageLoader的实现</h3>

<p>一般来说，一个优秀的ImageLoader应该具备如下功能：</p>

<ul>
<li>图片的同步加载</li>
<li>图片的异步加载</li>
<li>图片压缩</li>
<li>内存缓存</li>
<li>磁盘缓存</li>
<li>网络拉取</li>
</ul>

<p>实现步骤：</p>

<ol>
<li>图片压缩功能的实现
<ol>
<li>根据宽高修改BitmapFactory.Options采样率</li>
</ol></li>
<li>内存缓存和磁盘缓存的实现
<ol>
<li>LruCache和DiskLruCache</li>
</ol></li>
<li>同步加载和异步加载接口的设计
<ol>
<li>使用线程池和Handler</li>
</ol></li>
</ol>

<h2 id="toc_5">12.3 ImageLoader的使用</h2>

<h3 id="toc_6">12.3.1 照片墙效果</h3>

<h3 id="toc_7">12.3.2 优化列表的卡顿现象</h3>

<ul>
<li>不要在getView中执行耗时操作。</li>
<li>控制异步任务的执行频率。可以考虑在列表滑动的时候，停止加载图片，尽管这个过程是异步的，等列表停下来以后在加载图片仍然可以获得良好的用户体验。</li>
<li>开启硬件加速可以解决莫名的卡顿问题，通过设置<code>android:hardwareAccelerated = &quot;true&quot;</code>即可为Activity开启硬件加速。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/06</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010145803.html">
                
                  <h1>12 理解ClassLoader</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">12.1 Java中的ClassLoader</h2>

<p>类加载子系统，主要作用就是通过多种类加载器（ClassLoader）来查找和加载Class文件到Java虚拟机中。</p>

<h3 id="toc_1">12.1.1 ClassLoader的类型</h3>

<ul>
<li>系统类加载器
<ul>
<li>Bootstrap ClassLoader</li>
<li>Extensions ClassLoader</li>
<li>Application ClassLoader</li>
</ul></li>
<li>自定义类加载器</li>
</ul>

<p><strong>Bootstrap ClassLoader 引导类加载器</strong><br/>
C/C++代码实现的加载器，用于加载指定的JDK核心类库，比如<code>java.lang.</code>、<code>java.util.</code>等系统类。它用来加载以下目录中的类库 :</p>

<ul>
<li>$JAVA HOME/jre/lib 目录。</li>
<li>-Xbootclasspath 参数指定的目录 。<br/>
Java 虚拟机的启动就是通过 Bootstrap ClassLoader 创建一个初始类来完成的。</li>
</ul>

<p><strong>Extensions ClassLoader</strong><br/>
Java 中的实现类为 ExtClassLoader，因此可以简称为ExtClassLoader，它用于加载 Java的拓展类，提供除了系统类之外的额外功能。 ExtClassLoader用来加载以下目录中的类库:</p>

<ul>
<li>加载$JAVA_HOME/jre/lib/ext 目录。</li>
<li>系统属性 java.ext.dir所指定的目录。</li>
</ul>

<p><strong>Application ClassLoader</strong><br/>
简称为APPClassLoader，又称为System ClassLoader（系统类加载器），它用来加载以下目录的类库：</p>

<ul>
<li>当前程序的Classpath目录。</li>
<li>系统属性java.class.path指定的目录。</li>
</ul>

<h3 id="toc_2">12.1.2 ClassLoader的继承关系</h3>

<p><img src="media/15537010145803/15753436684706.jpg" alt="" style="width:383px;"/></p>

<h3 id="toc_3">12.1.3 双亲委托模式</h3>

<p>双亲委托模型：</p>

<ol>
<li>首先判断该Class是否已经加载，如果没有则委托父加载器进行查找</li>
<li>依次进行递归，直到委托到最顶层的Bootstrap ClassLoader</li>
<li>如果Bootstrap ClassLoader找到了该Class，直接返回；如果没有找到，则继续依次向下查找，如果还没找到最后交由自身去查找。
<img src="media/15537010145803/15753458406302.jpg" alt="" style="width:465px;"/></li>
</ol>

<p>双亲委托模型的好处：</p>

<ul>
<li>避免重复加载。</li>
<li>更加安全。比如无法通过自定义String类替代系统的String类。</li>
</ul>

<h3 id="toc_4">12.1.4 自定义ClassLoader</h3>

<p>系统提供的类加载器只能够加载指定目录下的 jar 包和 Class 文件，如果想要加载网络上的或者 D 盘某一文件中的 jar 包和 Class 文件则需要自定义 ClassLoader。实现自定义ClassLoader 需要如下两个步骤:</p>

<ol>
<li>定义一个自定义 ClassLoade 并继承抽象类 ClassLoader。</li>
<li>复写 findClass 方法，并在 findClass 方提中调用 defineClass 方法。</li>
</ol>

<h2 id="toc_5">12.2 Android中的ClassLoader</h2>

<h3 id="toc_6">12.2.1 ClassLoader的类型</h3>

<h3 id="toc_7">12.2.2 ClassLoader的继承关系</h3>

<h3 id="toc_8">12.2.3 ClassLoader的加载过程</h3>

<h3 id="toc_9">12.2.4 BootClassLoader的创建</h3>

<h3 id="toc_10">12.2.5 PathClassLoader的创建</h3>

<h2 id="toc_11">12.3 本章小结 311</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010271155.html">
                
                  <h1>13 热修复原理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">13.1 热修复的产生</h2>

<h2 id="toc_1">13.2 热修复框架的种类和对比</h2>

<h2 id="toc_2">13.3 资源修复</h2>

<h3 id="toc_3">13.3.1 Instant Run概述</h3>

<p>Instant Run是Android Studio 2.0以后新增的一个运行机制， 能够显著减少开发人员第二次及以后的构建和部署时间。在没有使用Instant Run前，我们编译部署应用程序的流程如图所示。</p>

<p><img src="media/15537010271155/15777597312743.jpg" alt="" style="width:608px;"/></p>

<p>从图13一1可以看出,传统的编译部署需要重新安装App和重启App,这显然会很耗时,Instant Run会避免这一情况， 如图所示。</p>

<p><img src="media/15537010271155/15777597727284.jpg" alt="" style="width:879px;"/></p>

<p>从上图可以看出InstantRun的构建和部署都是基于更改的部分的。InstantRun部署有三种方式，Instant Run会根据代码的情况来决定采用哪种部署方式，无论哪种方式都不需要重新安装App,这一点就已经提高了不少的效率。</p>

<ul>
<li>Hotswap:从名称也可以看出HotSwap是效率最高的部署方式，代码的增量改变不需要重启App,甚至不需要重启当前的Activity。 修改一个现有方法中的代码时会采用Hot Swap。</li>
<li>Warm Swap: App不需重启，但是Activity 需要重启。修改或删除一个现有的资源文件时会采用WarmSwap。</li>
<li>Cold Swap: App 需要重启，但是不需要重新安装。采用Cold Swap的情况很多，比如添加、删除或修改一个字段和方法、添加一个类等。</li>
</ul>

<h3 id="toc_4">13.3.2 Instant Run的资源修复</h3>

<p>Instant Run中的资源热修复可以简单地总结为两个步骤:</p>

<ol>
<li>创建新的AssetManager, 通过反射调用addAssetPath方法加载外部的资源，这样新创建的AssetManager就含有了外部资源。</li>
<li>将AssetManager类型的mAssets字段的引用全部替换为新创建的AssetManager。</li>
</ol>

<h2 id="toc_5">13.4 代码修复</h2>

<p>代码修复主要有3个方案，分别是底层替换方案、类加载方案和Instant Run方案。</p>

<h3 id="toc_6">13.4.1 类加载方案</h3>

<p>类加载方案基于Dex分包方案，什么是Dex分包方案呢?这个得先从65536限制和LinearAlloc限制说起。</p>

<p><strong>1. 65536限制</strong></p>

<p>随着应用功能越来越复杂，代码量不断地增大，引入的库也越来越多，可能会在编译时提示如下异常:</p>

<pre><code class="language-text">com. android. dex. DexIndexOverflowException: method ID not in [0， 0xffff] : 65536
</code></pre>

<p>这说明应用中引用的方法数超过了最大数65536个。产生这一问题的原因就是系统的65536限制，65536 限制的主要原因是DVM Bytecode的限制，DVM指令集的方法调用指令invoke-kind索引为16bits, 最多能引用65535个方法。</p>

<p><strong>2. LinearAlloc 限制</strong></p>

<p>在安装应用时可能会提示INSTALL_FAILED_DEXOPT,产生的原因就是LinearAlloc限制，DVM中的LinearAlloc是一个固定的缓存区，当方法数超出了缓存区的大小时会报错。</p>

<p>为了解决65536限制和LinearAlloc限制，从而产生了Dex分包方案。Dex 分包方案主要做的是在打包时将应用代码分成多个Dex,将应用启动时必须用到的类和这些类的直接引用类放到主Dex中，其他代码放到次Dex中。当应用启动时先加载主Dex，等到应用启动后再动态地加载次Dex，从而缓解了主Dex的65536限制和LinearAlloc限制。</p>

<p>Dex分包方案主要有两种，分别是Google官方方案、Dex自动拆包和动态加载方案。</p>

<p>在12.2.3节中学习了ClassLoader的加载过程，其中一个环节就是调用DexPathList 的findClass的方法，如下所示:</p>

<pre><code class="language-text"> public Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) {
        for (Element element : dexElements) {//1
            Class&lt;?&gt; clazz = element.findClass(name, definingContext, suppressed);//2
            if (clazz != null) {
                return clazz;
            }
        }
        if (dexElementsSuppressedExceptions != null) {
            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
        }
        return null;
    }
</code></pre>

<p>Element内部封装了DexFile，DexFile用于加载dex文件，因此每个dex文件对应一个Element。</p>

<p>多个Element组成了有序的Element数组dexElements。当要查找类时，会在注释1处遍历Element数组dexElements（相当于遍历dex文件数组），注释2处调用Element的findClass方法，其方法内部会调用DexFile的loadClassBinaryName方法查找类。如果在Element中（dex文件）找到了该类就返回，如果没有找到就接着在下一个Element中进行查找。<br/>
根据上面的查找流程，我们将有bug的类Key.class进行修改，再将Key.class打包成包含dex的补丁包Patch.jar，放在Element数组dexElements的第一个元素，这样会首先找到Patch.dex中的Key.class去替换之前存在bug的Key.class，排在数组后面的dex文件中的存在bug的Key.class根据ClassLoader的双亲委托模式就不会被加载，这就是类加载方案，如下图所示。</p>

<p><img src="media/15537010271155/15777610942927.jpg" alt="" style="width:641px;"/></p>

<p>类加载方案需要重启App后让ClassLoader重新加载新的类，为什么需要重启呢？这是因为类是无法被卸载的，因此要想重新加载新的类就需要重启App，因此采用类加载方案的热修复框架是不能即时生效的。<br/>
虽然很多热修复框架采用了类加载方案，但具体的实现细节和步骤还是有一些区别的：</p>

<ul>
<li>QQ空间的超级补丁和Nuwa是按照上面说得将补丁包放在Element数组的第一个元素得到优先加载。</li>
<li>微信Tinker将新旧apk做了diff，得到patch.dex，然后将patch.dex与手机中apk的classes.dex做合并，生成新的classes.dex，然后在运行时通过反射将classes.dex放在Element数组的第一个元素。</li>
<li>饿了么的Amigo则是将补丁包中每个dex 对应的Element取出来，之后组成新的Element数组，在运行时通过反射用新的Element数组替换掉现有的Element 数组。</li>
</ul>

<p>采用类加载方案的主要是以腾讯系为主，包括微信的Tinker、QQ空间的超级补丁、手机QQ的QFix、饿了么的Amigo和Nuwa等等。</p>

<h3 id="toc_7">13.4.2 底层替换方案</h3>

<p>与类加载方案不同的是，底层替换方案不会再次加载新类，而是直接在Native层修改原有类，由于是在原有类进行修改限制会比较多，不能够增减原有类的方法和字段，如果我们增加了方法数，那么方法索引数也会增加，这样访问方法时会无法通过索引找到正确的方法，同样的字段也是类似的情况。</p>

<p>底层替换方案和反射的原理有些关联，就拿方法替换来说，</p>

<ol>
<li>方法反射我们可以调用java.lang.Class.getDeclaredMethod.invoke()</li>
<li>invoke方法是个native方法，对应Jni层的代码为：<code>art/runtime/native/java_lang_reflect_Method.cc</code></li>
<li>Method_invoke函数中又调用了InvokeMethod函数：<code>art/runtime/reflection.cc</code></li>
<li>然后可以获取传入的javaMethod（Key的show方法）在ART虚拟机中对应的一个ArtMethod指针，ArtMethod结构体中包含了Java方法的所有信息，包括执行入口、访问权限、所属类和代码执行地址等等</li>
<li>ArtMethod结构中比较重要的字段是dex_cache_resolved_methods_和的entry_point_from_quick_compiled_code_，它们是方法的执行入口，当我们调用某一个方法时（比如Key的show方法），就会取得show方法的执行入口，通过执行入口就可以跳过去执行show方法。替换ArtMethod结构体中的字段或者替换整个ArtMethod结构体，这就是底层替换方案。</li>
</ol>

<p>AndFix采用的是替换ArtMethod结构体中的字段，这样会有兼容问题，因为厂商可能会修改ArtMethod结构体，导致方法替换失败。Sophix采用的是替换整个ArtMethod结构体，这样不会存在兼容问题。</p>

<p>底层替换方案直接替换了方法，可以立即生效不需要重启。采用底层替换方案主要是阿里系为主，包括AndFix、Dexposed、阿里百川、Sophix。</p>

<h3 id="toc_8">13.4.3 Instant Run方案</h3>

<p>除了资源修复，代码修复同样也可以借鉴Instant Run的原理， 可以说Instant Run的出现推动了热修复框架的发展。<br/>
Instant Run在第一次构建apk时，使用ASM在每一个方法中注入了类似如下的代码：</p>

<pre><code class="language-text">IncrementalChange localIncrementalChange = $change;//1
        if (localIncrementalChange != null) {//2
            localIncrementalChange.access$dispatch(
                    &quot;onCreate.(Landroid/os/Bundle;)V&quot;, new Object[] { this,
                            paramBundle });
            return;
        }
</code></pre>

<ol>
<li>其中注释1处是一个成员变量localIncrementalChange ，它的值为\(change，\)change实现了IncrementalChange这个抽象接口。</li>
<li>当我们点击InstantRun时，如果方法没有变化则$change为null，就调用return，不做任何处理。</li>
<li>如果方法有变化，就生成替换类，
<ol>
<li>这里我们假设MainActivity的onCreate方法做了修改，就会生成替换类MainActivity$override，这个类实现了IncrementalChange接口，同时也会生成一个AppPatchesLoaderImpl类，</li>
<li>这个类的getPatchedClasses方法会返回被修改的类的列表（里面包含了MainActivity），</li>
<li>根据列表会将MainActivity的$change设置为MainActivity$override，因此满足了注释2的条件，会执行MainActivity$override的access$dispatch方法，</li>
<li>accessdispatch方法中会根据参数&#39;onCreate.(Landroid/os/Bundle;)V;&#39;，执行&#39;MainActivityoverride&#39;的onCreate方法，从而实现了onCreate方法的修改。</li>
</ol></li>
</ol>

<p>借鉴Instant Run的原理的热修复框架有Robust和Aceso。</p>

<h2 id="toc_9">13.5 动态链接库的修复</h2>

<p>Android平台的动态链接库主要指的是so库，为了更好地理解，本章动态链接库简称为so。热修复框架的so的修复的主要是更新so，换句话说就是重新加载so，因此so的修复的基础原理就是加载。</p>

<h3 id="toc_10">13.5.1 System的load和loadLibarary方法</h3>

<p>加载so主要用到了System类的load和loadLibarary方法。</p>

<ul>
<li>System的load方法传入的参数是so在磁盘的完整路径,用于加载指定路径的so。</li>
<li>System的loadLibrary方法传入的参数是so的名称，用于加载App安装后自动从apk包中复制到/data/data/ packagename/lib下的so。</li>
</ul>

<p><strong>1. System的load方法</strong></p>

<ol>
<li>Runtime.getRuntime()会得到当前Java应用程序的运行环境Runtime</li>
<li>调用了doLoad方法，并将加载该类的类加载器作为参数传入进去:</li>
<li>doLoad方法会调用native方法nativeLoad</li>
</ol>

<p><strong>2. System的loadLibrary方法</strong></p>

<ol>
<li>先调用Runtime的loadLibrary0方法，loadLibrary0方法分为两个部分，一个是传入的ClassLoader不为null的部分，另一个是ClassLoader为null的部分</li>
<li>我们先来看ClassLoader 为null的部分。先遍历getLibPaths方法，这个方法会返回java.library.path选项配置的路径数组，然后拼接出so路径作为参数调用doLoad方法中。</li>
<li>当ClassLoader不为null时，先通过ClassLoader的findLibrary方法来得到fileName，然后调用doLoad 方法。</li>
<li><strong>findLibrary</strong>：ClassLoader的findLibrary方法在实现类BaseDexClassLoader中实现，然后会调用DexPathList的findLibrary方法，这和13.3.1 节讲到的DexPathList的findClass方法类似，
<ol>
<li>在NativeLibraryElement数组中的每一个NativeLibraryElement对应一个so库，</li>
<li>然后调用NativeLibraryElement的findNativeLibrary方法就可以返回so的路径。结合的类加载方案，就可以得到so的修复的一种方案，就是：</li>
<li>将so补丁插入到NativeLibraryElement数组的前部，让so补丁的路径先被返回，并调用Runtime的doLoad方法进行加载，</li>
<li>在doLoad方法中会调用native 方法nativeLoad。</li>
</ol></li>
</ol>

<h3 id="toc_11">13.5.2 nativeLoad方法分析</h3>

<p>LoadNativeLibrary函数的行数很多，这里来做一个总结，LoadNativeLibrary 函数主要做了如下3方面工作：</p>

<ol>
<li>判断so是否被加载过，两次ClassLoader是否是同一个，避免so重复加载。</li>
<li>打开so并得到so句柄，如果so句柄获取失败,就返回false。创建新的SharedLibrary,如果传入path对应的library 为空指针，就将新创建的SharedIibrary赋值给library, 并将library存储到libraries_中。</li>
<li>查找JNI_OnLoad 的函数指针，根据不同情况设置was_successful 的值，最终返回该was_successful。</li>
</ol>

<p><img src="media/15537010271155/15777663637419.jpg" alt=""/></p>

<p>讲到这里总结一下so修复主要有两个方案:</p>

<ol>
<li>将so补丁插入到NativeLibraryElement数组的前部，让so补丁的路径先被返回和加载。</li>
<li>调用System的load方法来接管so的加载入口。</li>
</ol>

<h2 id="toc_12">13.6 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15789729257987.html">
                
                  <h1>13 综合技术</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010310819.html">
                
                  <h1>14 Hook技术</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>说到Hook技术得先提到逆向工程，逆向工程源于商业及军事领域中的硬件分析，其主要目的是在不能轻易获得必要的生产信息的情况下，直接从成品分析，推导出产品的设计原理。</p>

<p>逆向分析分为静态分析和动态分析，其中静态分析指的是一种在不执行程序的情况下对程序行为进行分析的技术;动态分析是指在程序运行时对程序进行调试的技术。</p>

<p>Hook技术就属于动态分析，它不仅在Android平台中被应用，早在Windows平台中就已经被应用了。</p>

<h2 id="toc_0">14.1 Hook技术概述</h2>

<p>我们知道应用程序进程之间是彼此独立的，应用程序进程和系统进程之间也是如此，想要在应用程序进程更改系统进程的某些行为很难直接实现，有了Hook 技术，我们就可以在进程间进行行为更改，如图所示。</p>

<p><img src="media/15537010310819/15777731979912.jpg" alt="" style="width:730px;"/></p>

<p>可以看到Hook可以将自己融入到它所要劫持的对象(对象B)所在的进程中，成为系统进程的一部分，这样我们就可以通过Hook来更改对象B的行为。被劫持的对象(对象B)，称作Hook点，为了保证Hook的稳定性，Hook点一般选择容易找到并且不易变化的对象，静态变量和单例就符合这一条件。</p>

<h2 id="toc_1">14.2 Hook技术分类</h2>

<p>Hook技术知识点比较多，因此Hook技术根据不同的角度会有很多种分类，这里介绍其中的三种分类。</p>

<ul>
<li>根据Hook的API语言划分，分为Hook Java和Hook Native。
<ul>
<li>Hook Java主要通过反射和代理来实现，应用于在SDK开发环境中修改Java代码。</li>
<li>HookNative则应用于在NDK开发环境和系统开发中修改Native代码。</li>
</ul></li>
<li>根据Hook的进程划分，分为应用程序进程Hook和全局Hook。
<ul>
<li>应用程序进程Hook只能Hook当前所在的应用程序进程。</li>
<li>应用程序进程是Zygote进程fock出来的，如果对Zygote进行Hook, 就可以实现Hook系统所有的应用程序进程，这就是全局Hook。</li>
</ul></li>
<li>根据Hook的实现方式划分，分为如下两种。
<ul>
<li>通过反射和代理实现，只能Hook当前的应用程序进程。</li>
<li>通过Hook框架来实现，比如Xposed， 可以实现全局Hook, 但是需要root。</li>
</ul></li>
</ul>

<p>Hook Native、全局Hook和通过Hook框架实现这些分类和插件化技术关联不大，本章主要需要学习的是Hook Java,想要更好地学习Hook Java,首先要了解代理模式。</p>

<h2 id="toc_2">14.3 代理模式</h2>

<p>代理模式也叫委托模式，是结构型设计模式的一一种。在现实生活中我们用到类似代理模式的场景有很多，比如代购、代理上网、打官司等。</p>

<p>定义：为其他对象提供一种代理以控制对这个对象的访问称为代理模式。</p>

<p>在代理模式中有如下角色。</p>

<ul>
<li>Subject: 抽象主题类，声明真实主题与代理的共同接口方法。</li>
<li>RealSubject: 真实主题类，定义了代理所表示的集体对象，客户端通过代理类间接调用真实主题类的方法。</li>
<li>Proxy: 代理类，持有对真实主题类的引用，在其所实现的接口方法中调用真实主题类中相应的接口方法执行。</li>
<li>Client: 客户端类。</li>
</ul>

<p><img src="media/15537010310819/15777735922722.jpg" alt="" style="width:639px;"/></p>

<h3 id="toc_3">14.3.1 代理模式简单实现</h3>

<h3 id="toc_4">14.3.2 动态代理的简单实现</h3>

<p>从编码的角度来说，代理模式分为静态代理和动态代理。</p>

<ul>
<li>静态代理，在代码运行前就已经存在了代理类的class编译文件</li>
<li><p>动态代理则是在代码运行时通过反射来动态地生成代理类的对象，并确定到底来代理谁。Java 提供了动态的代理接口InvocationHandler,实现该接口需要重写invoke方法。</p></li>
</ul>

<ol>
<li>创建代理类，实现InvocationHandler接口</li>
<li><p>客户端类代码：</p>
<pre><code class="language-text">public class Client {
    public static void main(String[] args) {<br/>
        //创建LiuWangShu<br/>
        IShop liuwangshu = new LiuWangShu() ;<br/>
        //创建动态代理<br/>
        DynamicPurchasing mDynamicPurchasing = new DynamicPurchasing(liuwangshu) ; <br/>
        //创建LiuWangShu的ClassLoader<br/>
        ClassLoader loader = liuwangshu.getClass().getClassLoader() ;<br/>
        //动态创建代理类<br/>
        IShop purchasing = (IShop)Proxy.newProxyInstance(loader, new Class[] {IShop.class}, mDynamicPurchasing) ;<br/>
        purchasing.buy() ;<br/>
    }<br/>
}
</code></pre></li>
</ol>

<h2 id="toc_5">14.4 Hook startActivity方法</h2>

<p>我们知道Hook可以用来劫持对象，被劫持的对象叫作Hook点，用代理对象来替代Hook点，这样我们就可以在代理上实现自己想做的操作。这里以Hook常用的startActivity方法来举例，startActivity 方法分为两个，如下所示:</p>

<ul>
<li>startActivity (intent) ;</li>
<li>getApplicationContext () . startActivity (intent) ;</li>
</ul>

<p>第一个是Actvity的startActivity方法，第二个是Context的startActivity 方法。</p>

<h3 id="toc_6">14.4.1 Hook Activity的startActivity方法</h3>

<h3 id="toc_7">14.4.2 Hook Context的startActivity方法</h3>

<h3 id="toc_8">14.4.3 Hook startActivity总结</h3>

<h2 id="toc_9">14.5 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15789729370090.html">
                
                  <h1>14 JNI和NDK编程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15518627896387.html">
                
                  <h1>15 性能优化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>本节介绍了一些有效的性能优化方法，主要内容包括布局优化、绘制优化、内存泄露优化、响应速度优化、ListView 优化、Bitmap 优化、线程优化以及一些性能优化建议，在介绍响应速度优化的同时还介绍了ANR日志的分析方法。</p>

<h3 id="toc_0">15.1.1 布局优化</h3>

<p>布局优化的思想很简单，就是尽量减少布局文件的层级，布局中的层级少了，这就意味着Android绘制时的工作量少了，那么程序的性能自然就高了。</p>

<p>首先删除布局中无用的控件和层级，其次有选择地使用性能较低的ViewGroup。布局优化的另外一种手段是采用<include>标签、<merge> 标签和ViewStub。</p>

<ul>
<li><include>标签主要用于布局重用；</li>
<li><merge>标签一般和<include>配合使用，它可以降低减少布局的层级；</li>
<li>ViewStub则提供了按需加载的功能，当需要时才会将ViewStub中的布局加载到内存，这提高了程序的初始化效率。</li>
</ul>

<h3 id="toc_1">15.1.2 绘制优化</h3>

<p>绘制优化是指View的onDraw方法要避免执行大量的操作，这主要体现在两个方面。</p>

<ol>
<li>首先，onDraw中不要创建新的局部对象，这是因为onDraw方法可能会被频繁调用，这样就会在一瞬间产生大量的临时对象，这不仅占用了过多的内存而且还会导致系统更加频繁gc，降低了程序的执行效率。</li>
<li>另外一方面，onDraw 方法中不要做耗时的任务，也不能执行成千上万次的循环操作，尽管每次循环都很轻量级，但是大量的循环仍然十分抢占CPU的时间片，这会造成View的绘制过程不流畅。按照Google官方给出的性能优化典范中的标准，View 的绘制帧率保证60fps是最佳的，这就要求每帧的绘制时间不超过16ms ( 16ms= 1000/ 60)，虽然程序很难保证16ms这个时间，但是尽量降低onDraw方法的复杂度总是切实有效的。</li>
</ol>

<h3 id="toc_2">15.1.3 内存泄露优化</h3>

<p>内存泄露的优化分为两个方面，一方面是在开发过程中避免写出有内存泄露的代码，另一方 面是通过一些分析工具比如来找出潜在的内存泄露继而解决。</p>

<ul>
<li>场景1:静态变量导致的内存泄露</li>
<li>场景2:单例模式导致的内存泄露</li>
<li>场景3:属性动画导致的内存泄露</li>
</ul>

<h3 id="toc_3">15.1.4 响应速度优化和ANR日志分析</h3>

<p>响应速度优化的核心思想是避免在主线程中做耗时操作，但是有时候的确有很多耗时操作，怎么办呢?<br/>
可以将这些耗时操作放在线程中去执行，即采用异步的方式执行耗时操作。响应速度过慢更多地体现在Activity 的启动速度上面，如果在主线程中做太多事情，会导致Activity启动时出现黑屏现象，甚至出现ANR。<br/>
Android 规定，Activity 如果5秒钟之内无法响应屏幕触摸事件或者键盘输入事件就会出现ANR，而BroadcastReceiver 如果10秒钟之内还未执行完操作也会出现ANR。<br/>
在实际开发中，ANR是很难从代码上发现的，如果在开发过程中遇到了ANR,那么怎么定位问题呢?其实当一个进程发生ANR了以后，系统会在<code>/data/anr</code>目录下创建一个文件traces.txt,通过分析这个文件就能定位出ANR的原因。</p>

<h3 id="toc_4">15.1.5 ListView和Bitmap优化</h3>

<p>ListView的优化（适用于GridView）：</p>

<ol>
<li>首先要采用ViewHolder并避免在getView中执行耗时操作；</li>
<li>其次要根据列表的滑动状态来控制任务的执行频率，比如当列表快速滑动时显然是不太适合开启大量的异步任务的;</li>
<li>最后可以尝试开启硬件加速来使Listview的滑动更加流畅。</li>
</ol>

<p>Bitmap的优化，主要是通过BitmapFactory.Options来根据需要对图片进行采样，采样过程中主要用到了BitmapFactory.Options 的inSampleSize参数。</p>

<h3 id="toc_5">15.1.6 线程优化</h3>

<p>线程优化的思想是采用线程池，避免程序中存在大量的Thread。线程池可以重用内部的线程，从而避免了线程的创建和销毁所带来的性能开销，同时线程池还能有效地控制线程池的最大并发数，避免大量的线程因互相抢占系统资源从而导致阻塞现象的发生。因此在实际开发中，我们要尽量采用线程池，而不是每次都要创建一个 Thread对象。</p>

<h3 id="toc_6">15.1.7 一些性能优化建议</h3>

<ul>
<li>避免创建过多的对象;</li>
<li>不要过多使用枚举，枚举占用的内存空间要比整型大;</li>
<li>常量请使用static final来修饰;</li>
<li>使用一 些Android 特有的数据结构，比如SparseArray和Pair等，它们都具有更好的性能;</li>
<li>适当使用软引用和弱引用;</li>
<li>采用内存缓存和磁盘缓存:</li>
<li>尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄露。</li>
</ul>

<h2 id="toc_7">15.2 内存泄露分析之MAT工具</h2>

<h2 id="toc_8">15.3 提高程序的可维护性</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/06</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html'>开发艺术探索</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010351262.html">
                
                  <h1>15 插件化技术</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>插件化技术和热修复技术都属于动态加载技术。</p>

<h2 id="toc_0">15.1 动态加载技术</h2>

<p>在Android传统开发中，一旦应用的代码被打包成APK并被上传到各个渠道市场，我们就不能修改应用的源码了，只能通过服务器来控制应用中预留的分支代码。但是很多时候我们无法提前预知需求和突然发生的情况，也就不能提前在应用代码中预留分支代码，这时就需要采用动态加载技术。</p>

<p>在应用程序运行时，动态加载一些程序中原本不存在的可执行文件并运行这些文件里的代码逻辑。可执行文件总的来说分为两种，一种是动态链接库so，另一种是dex相关文件(dex 以及包含dex的jar/apk文件)。</p>

<p>随着应用开发技术和业务的逐步发展，动态加载技术派生出两个技术，分别是热修复技术和插件化技术，其中热修复技术主要用来修复Bug, 插件化技术则主要用于解决应用越来越庞大以及功能模块的解耦。</p>

<h2 id="toc_1">15.2 插件化的产生</h2>

<h3 id="toc_2">15.2.1 应用开发的痛点和瓶颈</h3>

<ol>
<li>业务复杂，模块耦合</li>
<li>应用间的接入</li>
<li>65536限制，内存占用大</li>
</ol>

<h3 id="toc_3">15.2.2 插件化思想</h3>

<h3 id="toc_4">15.2.3 插件化定义</h3>

<p>插件化的客户端由宿主和插件两个部分组成。宿主就是指先被安装到手机中的APK,就是平常我们加载的普通APK。插件一般是指经过处理的APK.so和dex等文件，插件可以被宿主进行加载，有的插件也可以作为APK独立运行。</p>

<p>讲到这里就可以引出插件化的定义：将一个应用按照插件的方式进行改造的过程就叫作插件化。</p>

<p>在协作方面，插件可以由一个人或者一个小组来进行开发，这样各个插件之间，以及插件和宿主之间的耦合度会降低。应用间的接入和维护也变得便捷，每个应用团队只需要负责自己的那一部分就可以了。应用以及主dex的体积也会相应变小，间接地避免了65536限制。第一次加载到内存的只有淘宝主客户端，当使用到其他插件时才会加载相应插件到内存，这样就减少了内存的占用。</p>

<h2 id="toc_5">15.3 插件化框架对比</h2>

<h2 id="toc_6">15.4 Activity插件化</h2>

<p>四大组件的插件化是插件化技术的核心知识点，而Activity 插件化更是重中之重，Activity插件化主要有3种实现方式，分别是反射实现、接口实现和Hook技术实现。反射实现会对性能有所影响，主流的插件化框架没有采用此方式，关于接口实现可以阅读dynamic-load-apk的源码，目前Hook技术实现是主流，因此本章主要介绍Hook技术实现。</p>

<p>Hook技术实现主要有两种解决方案，一种是通过Hook IActivityManager来实现，另一种是Hook Instrumentation实现。在讲到这两个解决方案前,我们需要从整体上了解Activity的启动流程。</p>

<h3 id="toc_7">15.4.1 Activity的启动过程回顾</h3>

<p><img src="media/15537010351262/15777798479991.jpg" alt="" style="width:611px;"/></p>

<p>首先Launcher进程向AMS请求创建根Activity, AMS会判断根Activity所需的应用程序进程是否存在并启动，如果不存在就会请求Zygote进程创建应用程序进程。应用程序进程启动后, AMS会请求应用程序进程创建并启动根Activity。</p>

<p>普通Activity和根Activity的启动过程大同小异，不涉及应用程序进程的创建，与Launcher也没关系：</p>

<p><img src="media/15537010351262/15777799240155.jpg" alt="" style="width:676px;"/></p>

<p>在应用程序进程中的Activity 向AMS请求创建普通Activity (步骤1)，AMS会对这个Activity的生命周期和栈进行管理，校验Activity等。如果Activity 满足AMS的校验，AMS就会请求应用程序进程中的ActivityThread去创建并启动普通Activity (步骤2)。</p>

<h3 id="toc_8">15.4.2 Hook IActivityManager方案实现</h3>

<p>AMS存在于SystemServer 进程中,我们无法直接修改,只能在应用程序进程中做文章。可以采用预先占坑的方式来解决没有在AndroidManifest.xml 中显式声明的问题，具体做法就是先使用一个在AndroidManifest.xml中注册的Activity来进行占坑，用来通过AMS的校验。接着用插件Activity替换占坑的Activity。</p>

<ol>
<li>注册Activity进行占坑</li>
<li>使用占坑Activity通过AMS验证</li>
<li>还原插件Activity</li>
<li>插件Activity的生命周期</li>
</ol>

<p><img src="media/15537010351262/15779367744180.jpg" alt="" style="width:697px;"/></p>

<h3 id="toc_9">15.4.3 Hook Instrumentation方案实现</h3>

<p>Hook Instrumentation 实现同样也需要用到占坑Activity,与Hook IActivityManager实现不同的是，用占坑Activity替换插件Activity以及还原插件Activity 的地方不同。</p>

<p><img src="media/15537010351262/15779368438324.jpg" alt="" style="width:682px;"/></p>

<h3 id="toc_10">15.4.4 总结</h3>

<h2 id="toc_11">15.5 Service插件化</h2>

<h3 id="toc_12">15.5.1 插件化方面Service与Activity的不同</h3>

<p><img src="media/15537010351262/15779370174333.jpg" alt="" style="width:693px;"/></p>

<p><img src="media/15537010351262/15779370330965.jpg" alt="" style="width:795px;"/></p>

<p>我们需要了解在插件化方面Activity和Service有何不同：</p>

<ul>
<li>Activity是基于栈管理的，一个栈中的Activity的数量不会太多，因此插件化框架处理的插件Activity 数量是有限的，可以声明有限的占坑Activity 来实现。除去硬件和系统限制，插件化框架处理的插件Service的数量可以是近乎无限的，无法用有限的占坑Service来实现。</li>
<li>在Standard模式下多次启动同一个占坑Activity 可以创建多个Activity 实例，但是多次启动占坑Service并不会创建多个Service实例。</li>
<li>用户和界面的交互会影响到Activity 的生命周期，因此插件Activity 的生命周期需要交由系统来管理，Hook IActivityManager方案中还原插件Activity 就是为了这一点。Service的生命周期不受用户影响，可以由开发者管理生命周期，没有必要还原插件。</li>
</ul>

<h3 id="toc_13">15.5.2 代理分发实现</h3>

<p>Activity插件化的重点在于要保证它的生命周期，而Service插件化的重点是保证它的优先级，这就需要用一个真正的Service 来实现，而不是像占坑Activity那样起一个占坑的作用。当启动插件Service时，就会先启动代理Service,当这个代理Service 运行起来之后，在它的onStartCommand等方法里面进行分发，执行插件TargetService 的onCreate等方法,这一方案就叫作代理分发。</p>

<ol>
<li>启动代理Service</li>
<li>代理分发</li>
</ol>

<h2 id="toc_14">15.6 ContentProvider插件化</h2>

<h3 id="toc_15">15.6.1 ContentProvider的启动过程回顾</h3>

<p><img src="media/15537010351262/15779372880299.jpg" alt="" style="width:765px;"/></p>

<h3 id="toc_16">15.6.2 VirtualApk的实现</h3>

<ol>
<li>VirtualApk 初始化</li>
<li>启动代理ContentProvider</li>
<li>代理分发</li>
</ol>

<h2 id="toc_17">15.7 BroadcastReceiver的插件化</h2>

<h3 id="toc_18">15.7.1 广播插件化思路</h3>

<p>IntentFilter的，讲到这里我们得到了一个新思路，那就是将静态注册的BroadcastReceiver全部转换为动态注册来处理，虽然静态和动态的BroadcastReceiver 的生命周期不同，但是为了实现插件化，这个缺点显然不是关键问题。</p>

<h3 id="toc_19">15.7.2 VirtualApk的实现</h3>

<h2 id="toc_20">15.8 资源的插件化</h2>

<h3 id="toc_21">15.8.1 系统资源加载</h3>

<h3 id="toc_22">15.8.2 VirtualApk实现</h3>

<p>资源的插件化方案主要有两种:一种是合并资源方案，将插件的资源全部添加到宿主的Resources中，这种方案插件可以访问宿主的资源。另一 种是构建插件资源方案，每个插件都构造出独立的Resources，这种方案插件不可以访问宿主资源。VirtualApk 采用了以上两种方案。</p>

<h2 id="toc_23">15.9 so的插件化</h2>

<p>so热修复主要有两种方案:</p>

<ul>
<li>将so补丁插入到NativeLibraryElement数组的前部，让so补丁的路径先被返回和加载。</li>
<li>调用System的load方法来接管so的加载入口。</li>
</ul>

<p>so的插件化的方案和so热修复第一种方案类似，简单来说就是将so插件插入到NativeLibraryElement数组中，并且将存储so插件的文件添加到nativeLibraryDirectories 集合中就可以了。</p>

<h2 id="toc_24">15.10 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010402151.html">
                
                  <h1>16 绘制优化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">16.1 绘制性能分析</h2>

<p>Android应用需要将自己的界面展示给用户，用户会和界面进行交互,界面的流畅度至关重要，这一节我们就来学习绘制性能分析，首先讲解绘制原理，接着介绍绘制性能分析的工具: Profile GPU Rendering、Systrace 和Traceview。</p>

<h3 id="toc_1">16.1.1 绘制原理</h3>

<p>View的绘制流程有3个步骤，分别是measure、layout 和draw，它们主要运行在系统的应用框架层,而真正将数据渲染到屏幕上的则是系统Native层的SurfaceFlinger 服务来完成的。</p>

<p>绘制过程主要由CPU来进行Measure、Layout.、Record、Execute的数据计算工作, GPU负责栅格化、渲染。CPU和GPU是通过图形驱动层来进行连接的，图形驱动层维护了一个队列，CPU将displaylist添加到该队列中，这样GPU就可以从这个队列中取出数据进行绘制。</p>

<p>说到绘制性能就需要提到帧数这个概念。帧数就是在1秒时间里传输的图片的量，也可以理解为图形处理器每秒钟能够刷新几次，通常用FPS (Frames Per Second)表示。每一帧其实就是静止的图像，通过快速连续地显示帧便形成了运动的假象。如果画面在60fps则不会感觉到卡顿，如果低于60fps，比如50fps则会感觉到卡顿。要想画面保持在60fps，需要屏幕在1秒内刷新60次，也就是每16.6667ms 刷新一次(绘制时长在16ms以内)。</p>

<p>Android系统每隔16ms 发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps, 那什么是VSYNC呢? VSYNC是VerticalSynchronization (垂直同步)的缩写，是一种定时中断，一旦收到VSYNC信号，CPU就开始处理各帧数据。如果某个操作要花费24ms,这样系统在得到VSYNC信号时无法进行正常的渲染，会发生丢帧，用户会在32ms中看到同一帧的画面。</p>

<p>产生卡顿原因有很多，主要有以下几点:</p>

<ul>
<li>布局Layout过于复杂，无法在16ms内完成渲染。</li>
<li>同一时间动画执行的次数过多，导致CPU或GPU负载过重。</li>
<li>View过度绘制，导致某些像素在同一帧时间内被绘制多次。</li>
<li>在UI线程中做了稍微耗时的操作。</li>
<li>GC回收时暂停时间过长或者频繁的GC产生大量的暂停时间。</li>
</ul>

<h3 id="toc_2">16.1.2 Profile GPU Rendering</h3>

<h3 id="toc_3">16.1.3 Systrace</h3>

<h3 id="toc_4">16.1.4 Traceview</h3>

<h2 id="toc_5">16.2 布局优化</h2>

<h3 id="toc_6">16.2.1 布局优化工具</h3>

<h3 id="toc_7">16.2.2 布局优化方法</h3>

<h3 id="toc_8">16.2.3 避免GPU过度绘制</h3>

<h2 id="toc_9">16.3 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15537010506228.html">
                
                  <h1>17 内存优化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">17.1 避免可控的内存泄漏</h2>

<h3 id="toc_1">17.1.1 什么是内存泄漏</h3>

<p>每个应用程序都需要内存来完成工作，为了确保Android系统的每个应用都有足够的内存，Android系统需要有效地管理内存分配。当内存不足时,Android运行时就会触发GC,GC采用的垃圾标记算法为根搜索算法。</p>

<p>内存泄漏就是指没有用的对象到GC Roots 是可达的(对象被引用)，导致GC无法回收该对象。</p>

<h3 id="toc_2">17.1.2 内存泄漏的场景</h3>

<ol>
<li>非静态内部类的静态实例
<ol>
<li>非静态内部类会持有外部类实例的引用，如果非静态内部类的实例是静态的，就会间接地长期维持着外部类的引用，阻止被系统回收。</li>
</ol></li>
<li>多线程相关的匿名内部类/非静态内部类</li>
<li>Handler内存泄漏</li>
<li>未正确使用Context</li>
<li>静态View</li>
<li>WebView</li>
<li>资源对象未关闭</li>
<li>集合中对象没清理</li>
<li>Bitmap对象</li>
<li>监听器未关闭</li>
</ol>

<h2 id="toc_3">17.2 Memory Monitor</h2>

<h3 id="toc_4">17.2.1 使用Memory Monitor</h3>

<h3 id="toc_5">17.2.2 大内存申请与GC</h3>

<h3 id="toc_6">17.2.3 内存抖动</h3>

<p>内存抖动一般指在很短的时间内发生了多次内存分配和释放，严重的内存抖动还会导致应用程序卡顿。内存抖动出现的原因主要是短时间频繁地创建对象(可能在循环中创建对象)，内存为了应对这种情况，也会频繁地进行GC。非并行GC在进行时，其他线程都会被挂起，等待GC操作完成后恢复工作。如果是频繁的GC就会产生大量的暂停时间，这会导致界面绘制时间减少，从而使得多次绘制一帧的时长超过了16ms， 产生的现象就是界面卡顿。综合起来就产生了内存抖动，产生了锯齿状的<br/>
抖动图。</p>

<h2 id="toc_7">17.3 Allocation Tracker</h2>

<h3 id="toc_8">17.3.1 使用Allocation Tracker</h3>

<h3 id="toc_9">17.3.2 alloc文件分析</h3>

<h2 id="toc_10">17.4 Heap Dump</h2>

<h3 id="toc_11">17.4.1 使用Heap Dump</h3>

<h3 id="toc_12">17.4.2 检测内存泄漏</h3>

<h2 id="toc_13">17.5 内存分析工具MAT</h2>

<h3 id="toc_14">17.5.1 生成hprof文件</h3>

<h3 id="toc_15">17.5.2 MAT分析hprof文件</h3>

<h2 id="toc_16">17.6 LeakCanary</h2>

<h3 id="toc_17">17.6.1 使用LeakCanary</h3>

<h3 id="toc_18">17.6.2 LeakCanary应用举例</h3>

<h2 id="toc_19">17.7 本章小结</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html'>进阶解密</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2.html"><strong>开发艺术探索</strong></a>
        
            <a href="%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89.html"><strong>进阶之光</strong></a>
        
            <a href="%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86.html"><strong>进阶解密</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15789721660565.html">0 Android开发艺术探索-目录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15789731325545.html">0 Android进阶之光-目录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15789733843338.html">0 Android进阶解密-目录</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15511960673056.html">01 Activity的生命周期和启动模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15536968610805.html">01 Android新特性</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
